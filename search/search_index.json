{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This is an unofficial Unity SRP Doc Just trying to make browsing and searching LWRP, HDRP, Shader Graph doc easier Last Doc Update: 2018-12-12","title":"This is an unofficial Unity SRP Doc"},{"location":"#this-is-an-unofficial-unity-srp-doc","text":"Just trying to make browsing and searching LWRP, HDRP, Shader Graph doc easier Last Doc Update: 2018-12-12","title":"This is an unofficial Unity SRP Doc"},{"location":"Core/ScriptableRenderPipeline/","text":"Scriptable Render Pipeline What is the Scriptable Render Pipeline (SRP) The SRP is a new Unity feature that has been designed to give artists and developers full control over the Unity rendering pipeline, giving them the tools they need to create modern, high-fidelity graphics in Unity. SRP allows developers to write C# scripts to control the way Unity renders each frame. By exposing the Unity rendering pipeline to C#, Unity becomes less of a \u201cblack box\u201d as developers can see and control exactly what happens during the rendering process. Developers can use the two built-in pipelines that are provided as part of SRP (the Lightweight Pipeline and the High-Definition Rendering Pipeline(HDRP)), they can develop their own pipelines from scratch or they can modify the provided pipelines to adapt them to their own requirements. Documentation is subject to change and may be incomplete.","title":"Scriptable Render Pipeline"},{"location":"Core/ScriptableRenderPipeline/#scriptable-render-pipeline","text":"","title":"Scriptable Render Pipeline"},{"location":"Core/ScriptableRenderPipeline/#what-is-the-scriptable-render-pipeline-srp","text":"The SRP is a new Unity feature that has been designed to give artists and developers full control over the Unity rendering pipeline, giving them the tools they need to create modern, high-fidelity graphics in Unity. SRP allows developers to write C# scripts to control the way Unity renders each frame. By exposing the Unity rendering pipeline to C#, Unity becomes less of a \u201cblack box\u201d as developers can see and control exactly what happens during the rendering process. Developers can use the two built-in pipelines that are provided as part of SRP (the Lightweight Pipeline and the High-Definition Rendering Pipeline(HDRP)), they can develop their own pipelines from scratch or they can modify the provided pipelines to adapt them to their own requirements. Documentation is subject to change and may be incomplete.","title":"What is the Scriptable Render Pipeline (SRP)"},{"location":"HDRP/HDRenderPipeline/","text":"High Definition Render Pipeline The High Definition Render Pipeline (HDRP) is a high-fidelity Scriptable Render Pipeline built by Unity to target modern (Compute Shader compatible) platforms. The HDRP utilizes Physically-Based Lighting techniques, linear lighting, HDR lighting and a configurable hybrid Tile/Cluster deferred/Forward lighting architecture and gives you the tools you need to create games, technical demos, animations and more to a high graphical standard. NOTE: Projects made using HDRP are not compatible with the Lightweight Render Pipeline. You must decide which render pipeline your project will use before starting development as HDRP features are not cross-compatible between HDRP and Lightweight. This section contains the information you need to begin creating applications using HDRP; including information on Lighting, Materials and Shaders, Cameras, debugging and information for advanced users. HRDP is only supported on the following platforms: Note: HDRP will only work on the following platforms if the device used supports Compute Shaders. I.e: HDRP will only work on iOS if the iPhone model used supports Compute Shaders. Windows and Windows Store, with DirectX 11 or DirectX 12 and Shader Model 5.0 macOS and iOS using Metal graphics Android, Linux and Windows platforms with Vulkan Modern consoles (Sony PS4 and Microsoft Xbox One) HDRP does not support OpenGL or OpenGL ES devices. Getting Started with High Definition Render Pipeline This page details the initial setup of a project using the High Definition Render Pipeline (HDRP) and notes on upgrading existing projects to HDRP. Setting up a new Project Using Unity Hub To set up a new HDRP project using Unity Hub, click the New button, then select High Definition - Preview from the Template drop-down box. After clicking Create Project, Unity will automatically create a Project with the High Definition Render Pipeline package installed. Upgrading an Existing Project To upgrade an existing Project, you must first download the High Definition Render Pipeline using the Package Manager UI. Navigate to Window > Package Manager to open the Package Manager UI. Then click the All button to open the packages list. Left click on Render-pipelines.high-definition to select it, then click the Install button to add HDRP to your project. After you have installed HDRP from the Package Manager UI you must add the HDRP Asset to the Scriptable Render Pipeline Graphics settings field. Navigate to Edit > Settings > Graphics Settings, then Assign the HDRP Asset to the Scriptable Render Pipeline field by dragging in the HDRP Asset, or using the radio button to select the Asset from the popup window. Building from source code The latest version of the Scriptable Render Pipeline (SRP) repo can be found at the following link: https://github.com/Unity-Technologies/ScriptableRenderPipeline Github Desktop or Git command line tools Cloning the repo using the GitHub Desktop App: Open the GitHub Desktop App and click Clone a Repository. Click the URL tab in the Clone a Repository window Enter the following URL: https://github.com/Unity-Technologies/ScriptableRenderPipeline Click the Choose\u2026 button to navigate to your project\u2019s Asset folder. Click the Clone button. After the repo has been cloned you must run the following console commands from the ScriptableRenderPipeline folder: git checkout Unity-2018.1.0b2 (or the latest tag) git submodule update --init --recursive --remote Cloning the repo using Git console commands: Enter the following commands in your console application of choice: cd <Path to your Unity project>/Assets git clone https://github.com/Unity-Technologies/ScriptableRenderPipeline cd ScriptableRenderPipeline git checkout Unity-2018.1.0b2 (or the latest tag) git submodule update --init --recursive --remote Once you have cloned the repo, re-open your project and follow the below instructions: Navigate to Edit > Project Settings > Graphics and add the HDRenderPipelineAsset Asset to the Render Pipeline Settings field. Create a copy of the HDRenderPipelineAsset and store it outside of the Scriptable Render Pipeline folder. This ensures that your HDRP settings are not lost when merging new changes from the SRP repo. HDRP will be ready to use in your project after following the above instructions. Upgrading Shaders The built-in Unity shaders are incompatible with Scriptable Render Pipelines, as such, any preexisting Shaders in your project must be updated to work with the HDRP. Navigate to Edit > Render Pipelines > Upgrade Project Materials to High Definition Materials to run the automatic upgrade script. This script with automatically update all preexisting shaders in your project to the new HDRP shaders. The HD Render Pipeline Lit Shader The lit shader is the default shader when using HDRenderPipeline (HDRP). This shader can be set with subsurface scattering, iridescence, vertex or pixel displacement and many other new parameters. This shader allows to users to produce more realistic assets with the use of HDRP. A version call LitTessellation is used to activate the tessellation. Creating a Lit Shader In HDRP, when a new material is created it is by default a lit shader. How to set a Lit Shader? Surface options Surface type: Surface can be set as Opaque or Transparent. Transparent is an alpha blend and it is more costly. Alpha Cutoff: This check box enable the alpha cutoff to use an alpha test. The handle set the value of the test. All the values under the handle value is totally transparent and the values equal or above the handle value is opaque. Double sided: This option allows the double side. The faces are rendered on the two sides. The normal mode manages the normal behaviour on the backfaces. By default the mode is mirror. Material type: Material type introduces new behaviour for shaders to create realistic assets. Standard: Common use with basic parameters. The standard type uses a metallic workflow. Subsurface scattering (SSS): Mainly use to do a skin shader. This material type simulates the light transport inside a material and create softer micro shadows. Also a new parameter appears: Enable transmission. This parameter simulate the translucency of an object and it is managed by a thickness map. SSS and transmission are setting by a diffusion profile explain later in this document. Anisotropy: The anisotropy determines the shape of the highlight. The surface vector is managed by a tangent map, an anisotropy map modulate the anisotropy intensity and a handle modulate and orient to horizontally or vertical the anisotropic effect. These parameters are more explain later in the documentation. Iridescence: Use to create an iridescent effect. The effect is modulate by an iridescence mask, iridescence thickness map and an handle iridescence thickness. Specular Color: Instead of standard type, the specular color type uses a specular workflow. In this way the specular can be colorize even for a not metallic matter. Translucent: This type is used to simulate only the transmission. It can be handy for vegetation and more light than a SSS type.This type use a profile like the SSS type to manage the transmission. Enable Decal: Allow the material to receive decals. Enable MotionVector For Vertex Animation: Use it to remove ghosting coming from vertex animation. Displacement mode: None: no change. Vertex displacement: Use a height map to displace the vertices. Pixel displacement: Use a height map to displace the pixels. Use it only on plane surface. The surface can be only digged. Vertex animation / Enable wind Prototype feature, don\u2019t use it. Inputs Base color + opacity : RGB channels are used as base color and alpha channel is used for opacity. Smoothness handle: This handle modulate (0 to 1) the smoothness value coming from the Mask map alpha channel. Mask map: Red channel: Metallic mask. 0 = not metallic, 1 = metallic. Green channel: Ambient occlusion. Blue channel: Detail map mask. Alpha channel: Smoothness. Normal map space: By default the normal map space is in tangent space. The normal map space can be set to object space. Normal map: Use to assign the normal map. The handle modulate the normal intensity between 0 and 2. Bent normal map: The bent normal is used to have a better ambient occlusion. It works only with diffuse lighting like lightmap or light probe. Coat Mask: By default the value is 0. The mask is used to modulate the clear coat effect base on the handle value (0 to 1). Base UV mapping: UV can be set to UV0, UV1 (used by the lightmap), UV2, UV3, planar or triplanar. Planar and triplanar use a world scale. This ratio depends about the size of the textures and the texel ratio wanted. By default it is 1, that means the material is applied on 1 meter. A value of 0.5 applies the material on 2 meters. Tiling: Set the X/Y values to tile the material. Offset: Set on X/Y offset for the UV. Detail inputs The detail map is a composited map used to add micro details into the material. The detail map visibility is managed by the blue channel of the Mask map. Detail map: Red channel: Grey scale used as albedo. Green channel: Green channel of the detail normal map. Blue channel: Detail smoothness. Alpha channel: Red channel of the detail normal map. Channels are organised like this due the different compressions quality of each channels. Detail UV mapping: UV0, UV1, UV2 or UV3 can be set. If the material UV are set to planar or triplanar, the detail UV are also set to planar or triplanar. Lock to base Tiling/Offset: By default a detail texture is linked to the material aspect because it is done to add a micro detail in it. If for any reason the link have to be removed, just uncheck this checkbox. Tiling: Set the tiling of the detail texture inside a tile of the material. For example if the material is tiled by 2 on a plane and the detail texture is also tile by 2, the detail will appears tile by 4 on the plane. In this condition the tile of the material can be changed without set another time the detail UV to keep the good appearance. Offset: Set on X/Y offset for the detail UV. Detail AlbedoScale: This handle modulate (0 to 2) the detail albedo (red channel) like an overlay effect. The default value is 1 and has no scale. Detail NormalScale: This handle modulate (0 to 2) the intensity of the detail normal map. The default value is 1 and has no scale. Detail SmoothnessScale: This handle modulate (0 to 2) the detail smoothness (blue channel) like an overlay effect. The default value is 1 and has no scale. Emissive inputs Emissive color: The emissive color can be managed by a map or a single color. If both are used they are multiplied. Emissive intensity: Set the power of the emissive effect. By default the value is 0 and doesn\u2019t produce any emissive effect. Albedo Affect Emissive: By default it is on and allows the albedo to produce color for the emissive. In this case the albedo is multiplied by emissive color and color picker to produce the emissive final color. For example the emissive color map can be used as an emissive mask, the albedo used to do the color and the color picker to modulate it. Advanced options: Enable GPU instancing: If objects are not static batched and identical, all objects with this material become instanced. For example, objects with an animation base on the object pivot can\u2019t be static batched (unique pivot for all) but they can be instanced by GPU. Enable Specular Occlusion from Bent normal: This option used the bent normal assign in the bent normal slot to do a specular occlusion for the reflection probe. Specific setting from material type Subsurface scattering Enable transmission: On/off the transmission effect. The transmission is managed by a profile and a thickness map. More the object is set thin more lighting cross it. Specific subsurface settings: Diffusion profile: Rollout menu to choose the profile. Profiles are set in the SSSSettings.asset file. Goto button select the the SSSSettings file. Subsurface mask map: This map uses the red channel to manage the visibility (0 = not visible, 1= totally visible) of the SSS effect. This map is modulated by the handle value (0 to 1, 1 is the default). Thickness map: This map uses the red channel to set the thickness inside the range set in the profile. 0 is the min range value and 1 is the max range value. The profile: Name: Name of the profile Scattering value: It is a HDR value to manage the color and the scatter of the SSS. Max radius: It is an information value and linked to the scattering value. It is the effective radius in millimeters. The blur is energy-preserving, so a wide result in a large area provides a small contribution of individual samples. A short distance increases the sharpness of the result. Index of Refraction: To set the real index of refraction. It is 1.4 for skin and between 1.3 and 1.5 for most other material. World scale: Set the size of the world unit in meters. Default it is 1 and shouldn\u2019t be modified except if the world unit used is customized. Subsurface scattering only: Texturing mode: Specifies when the diffuse texture should be applied. Transmission only: Transmission mode: Regular or Thin object. Really thin object need a specific use. Transmission tint: Set a HDR value to color the transmission. Min/Max thickness (mm): Set the range of the thickness. This range is modulate by the thickness map (0 = min, 1 = max). Thickness remap: This setting allows to remap the thickness without to change the min/max values. The range can be moved without losing the thickness values. Profile preview: Shows the fraction of lights scattered from the source located in the center.The distance to the boundary of the image corresponds to the max radius. Display is not HDR, so the intensity of pixels around the center may be clipped. Transmission preview: Shows the fraction of light passing through the object for thickness values from the remap. Can be viewed as a cross section of a slab of material illuminated by white light from the left. Anisotropy Anisotropic materials don\u2019t have an uniform specular shape. Real anisotropy example: Anisotropy is used to deform the specular shape on an axe. Tangent map: It is a vector map. Red and Green channel orient the specular shape. Anisotropy: This handle modulate the intensity of the anisotropic effect and modify the shape orientation, horizontally or vertically, coming from the tangent map. Anisotropy map: This map uses the red channel to modulate the anisotropic effect intensity. Iridescence The iridescence (Thin-film interference) is a natural phenomenon in which lightwaves reflected by the upper and lower boundaries of a thin film interfere with one another, either enhancing or reducing the reflected light. Iridescence Mask: This map uses the red channel to manage the visibility of the iridescence effect. The handle can modulate the mask or the visibility if no mask is assigned. Iridescence Layer thickness map: If no map is assigned, by default the value is 1. The iridescence gradient color is linked to the thickness. When the thickness change the gradient color change too. The handle modulate the thickness also and it is multiplied when a map is assigned. FYI: If the base color is white no iridescence can be visible. For a white base color no lighting enter the matter. All the lighting is reflected to produce a pure white color, so no iridescence can be produce. Specular color When the specular color shader type is chosen, the specular color is defined by a dedicated map not anymore by the albedo value. Specular color: RGB map to set the specular color. When no map is assigned the default value is 1. Picker color: Uniform color used for the specular. It is multiply by the Specular color map. Translucent The translucency is the transmission of a part of light across the matter. The translucency is manage by a profile and a thickness map like for the subsurface scattering. How to set a Lit Shader Tessellation? From a lit shader, use the shader rollout menu to choose the LayeredLitTessellation shader. In case of lit shader tessellation only standard, subsurface scattering and translucent types are available. Displacement mode: None: No displacement is applied. The tessellation is used only to smooth the surface. Tessellation displacement: A height map (red channel) is used in the inputs to displace the mesh vertices. Lock with object scale: the height map appearance doesn\u2019t change when the object is scaled. Lock with height map tiling rate: the height map appearance doesn\u2019t change when the material is tiled. Tessellations options: Tessellation mode: None: no smooth is aplied. Phong: the tessellation applied a smooth effect. Tessellation factor: Between 0 and 64 this factor modulate the tessellation quantity. Higher value mean a surface more tessellated. Above 15 is costly. For XBox one and Playstation4 the maximum is set to 15. Start fade distance: It is the distance (in Unity unit) to the camera where the tessellation start to fade out. End fade distance: It is the maximum distance (in Unity unit) to the camera where triangle are tessellated. Triangle size: Desired screen space size of triangle (in pixel). A smaller value mean smaller triangle. Height map parameterization: Two parametrizations are available. Min/Max: In this mode the base of the height map is linked to the base of the mesh. It is used if the height map has uniform values on the map. Min: Set the height value for the 0 value on the map. Max: Set the height value for the 1 (255) value on the map. Offset: Can up and down the height map without modify the min/max values. Amplitude: Amplitude mode is more used in case of height map with a dedicated center. In this case the height map uses often none uniform values. In case of non uniform values a range of the map is not used to store values, it is clamped in positive or negative. Amplitude: The amplitude is the double value of the maximum value in negative or in positive. Base: It is the reference of the base mesh into the height map. By default the base is at 0.5. Offset: Can up and down the height map without modify the other values. Sky and Fog In HDRP, sky and fog are setup via the interpolation volume framework. The goal is for the user to be able to dynamically change the look of the sky and fog depending on the camera position. We also provide the necessary tools to offer consistent baking of lightmaps and probes. The Sky Framework used by HDRP is also designed in a way that it is easy for users to write their own custom sky and use it in their project with minimal effort. As part of the Volume framework, all local settings components described below are actually VolumeComponents which need to be added to a VolumeComponent on a regular GameObject. As such, all their parameters can be interpolated between different volumes. Setting up the Sky Setting up a sky has two goals: The first one is to define what will be displayed in the background of the scene for a given camera. The second one is to define environment lighting, namely sky reflection and sky ambient probe which is then later used to render lightmaps (real-time or baked). Settings are split between global settings which are per project/platform and local settings that use the volume framework and can change depending on the scene or camera position. Global Sky Settings Global settings for the sky are in the HDRenderPipeline configuration asset: Sky Reflection Size This parameter drives the size of the cubemap generated from the sky and used for fallback reflection when no local reflection probes are present. It has no effect on the quality of the sky rendered in the background. Sky Lighting Override Mask In some cases, users may want to dissociate lighting environment from what is rendered in the background (a typical example is to have a very dark sky at night but have a brighter lighting so that the player can still see). In order to achieve this, users can define the sky lighting override mask which is a Layer mask. If any volumes are present in this layer then environment lighting will use these volumes instead of those from the main camera. If this mask is set to Nothing or if there are no volume in this mask then lighting will come from volumes setup in the main camera volume layer mask. In practice this means that user can define two sets of masks, one for the visual sky and the other for the lighting. Both sets of volume will then be interpolated independently from each other. Note that lighting override does not affect baked lighting. Local Sky Settings Once global parameters are set, users need to setup volumes with the correct components to setup local parameters for the sky. Currently HDRP provides two different kind of skies. Procedural Sky This sky is similar to the procedural sky provided with the built-in Unity Render Pipelines. Property Function Enable Sun Disk Display sun disk Sun Size Size of the sun disk Sun Size Convergence Atmospheric Thickness Sky Tint Color of the sky hemisphere Ground Color Color of the ground hemisphere Exposure Exposure applied to the sky Multiplier Multiplier applied to the sky Update Mode Rate at which the sky environment (reflection en ambient probe) should be updated On Changed Sky environment is updated when one of its parameter changes On Demand Sky Environment is explicitly updated by the script Realtime Sky environment is updated regularly Update Period Period (in seconds) at which the realtime sky is updated (0 means every frame) HDRI Sky Simple sky represented by a cubemap texture. Property Function Hdri sky Cubemap representing the sky Exposure Exposure applied to the sky Multiplier Multiplier applied to the sky Rotation Rotation applied to the cubemap in degrees Update Mode Rate at which the sky environment (reflection en ambient probe) should be updated On Changed Sky environment is updated when one of its parameter changes On Demand Sky Environment is explicitly updated by the script Realtime Sky environment is updated regularly Update Period Period (in seconds) at which the realtime sky is updated (0 means every frame) Baking Global Illumination with the sky In HDRP the sky is completely controlled by the volume system. It means that in the editor, the current state of the sky will depend on the camera position. The consequence is that for users to get a consistent lighting baking, we can\u2019t rely on what is in the scene. Instead the sky used for baking is set explicitly by the user through the Baking Sky component. User should select a volume profile which contains the sky intended to be used for baking and then choose the right type (in case the profile contains different kinds of skies). If the component is added to a game object that already has a Volume, the profile property will be automatically populated with the corresponding profile asset. This sky setting will live outside of the volume framework and thus will never be interpolated based on the camera position. Any time the baking is required, this is the sky that will be used. Only one such component can be present in the editor at any given time. Any additional component of the same type will generate a warning and be ignored. Setting up the Fog Fog is the effect of overlaying a color onto objects dependant on the distance from the camera. This is used to simulate fog or mist in outdoor environments and is also typically used to hide clipping of objects when a camera\u2019s far clip plane has been moved forward for performance. In HDRP, users can choose between two different kind of fogs, linear and exponential fog. All types of materials (lit or unlit) will react correctly to the fog. Depending on the type of fog, density will evolve differently with respect to distance from camera and world space height. Instead of using a constant color, both types of fog can choose to use the background sky as a source for color. In this case, the color will be sampled from different mip maps of the cubemap generated from the current sky settings. Chosen mip will vary linearly between the blurriest one to the highest resolution one depending on the distance from camera and the \"Mip Fog\" parameters. Users can also choose to limit the resolution of the higher mip used. For both types of fog, density is computed from camera distance and world space height independently and then multiplied together to obtain the final result. Linear Fog Density will increase linearly with view distance and world space height depending on the provided parameters. Property Function Density Global multiplier for the fog density Color Mode Source of the fog color Constant Color Fog is a constant color Color Color of the fog Sky Color Fog color is sampled from the sky Mip Fog Near Distance at which the blurriest sky mip is used Mip Fog Far Distance at which the higher sky mip (see \"Mip Fog Max Mip\" ) is used Mip Fog Max Mip Maximum mip map used to sample the color (1.0 being highest resolution and 0.0 lowest resolution). Fog Start Distance from camera at which fog density starts to increase from zero. Fog End Distance from camera at which fog density is maximum. Fog Height Start Height at which fog density starts to decrease Fog Height End Height at which fog density is zero Exponential Fog Density will increase exponentially with view distance and world space height depending on the provided parameters. Property Function Density Global multiplier for the fog density Color Mode Source of the fog color Constant Color Fog is a constant color Color Color of the fog Sky Color Fog color is sampled from the sky Mip Fog Near Distance at which the blurriest sky mip is used Mip Fog Far Distance at which the higher sky mip (see \"Mip Fog Max Mip\" ) is used Mip Fog Max Mip Maximum mip map used to sample the color (1.0 being highest resolution and 0.0 lowest resolution). Fog Distance Distance from camera at will reach maximum Fog Base Height World space height at which fog density starts to decrease from 1.0 Fog Height Attenuation Fall off of height fog attenuation (bigger values will make attenuation sharper) Visual Environment Once the proper components have been setup, users need to specify what kind of sky and fog should be used for rendering. This is done through the Visual Environment component. Property Function Sky Type Type of sky used for rendering. This list will be automatically updated with any custom sky written by users Fog Type Type of fog used for rendering To help setting things up more easily, users can use the contextual menu to directly create a game object named \"Scene Settings\" and go from there. This game object is already setup with a default procedural sky and exponential fog inside a global Volume (it also contains default shadow settings). Writing Custom Sky Renderers The sky system is setup in a way that allows users to develop their own kind of sky with their own parameters and shaders. Three things are needed in order to write your own sky. SkySettings Create a new class that inherits from SkySettings . This class will contain all parameters specific to the particular sky renderer user is writing. Please refer to the Volume system documentation to learn how to declare volume parameters. Three things are mandatory to write: SkyUniqueID attribute: This must be an integer unique to this particular sky. Must not clash with any other sky settings. The SkyType enum is available for users to see what values are already used by HDRP. GetHashCode: This is used by the sky system to determine when to re-render the sky reflection cubemap. CreateRenderer: This is used by the sky system to instantiate the proper renderer. Exemple: HDRI Sky [SkyUniqueID(87248]<br/> public class HDRISky : SkySettings { [Tooltip(\"Cubemap used to render the sky.\")] public CubemapParameter hdriSky = new CubemapParameter(null); public override SkyRenderer CreateRenderer() { return new HDRISkyRenderer(this); } public override int GetHashCode() { int hash = base.GetHashCode(); unchecked { hash = hdriSky.value != null ? hash * 23 + hdriSky.GetHashCode() : hash; } return hash; } } \u200b SkyRenderer This is the class that will actually render the sky, either into a cubemap for lighting or on the background. This is where users must implement all their specific rendering. It must implement this interface: public abstract class SkyRenderer { // Method used to initialize any resource for the sky rendering (shaders, \u2026) public abstract void Build(); // Method used to clean up any resource previously allocated public abstract void Cleanup(); // SkyRenderer is responsible for setting up render targets provided in builtinParams public abstract void SetRenderTargets(BuiltinSkyParameters builtinParams); // renderForCubemap: When rendering into a cube map, no depth buffer is available so user has to make sure not to use depth testing or the depth texture. public abstract void RenderSky(BuiltinSkyParameters builtinParams, bool renderForCubemap); // Returns true if provided sky setting parameters are valid. public abstract bool IsValid(); } Exemple: HDRISkyRenderer: public class HDRISkyRenderer : SkyRenderer<br/>{ Material m_SkyHDRIMaterial; // Renders a cubemap into a render texture (can be cube or 2D) MaterialPropertyBlock m_PropertyBlock; HDRISky m_HdriSkyParams; public HDRISkyRenderer(HDRISky hdriSkyParams) { m_HdriSkyParams = hdriSkyParams; m_PropertyBlock = new MaterialPropertyBlock(); } public override void Build() { var hdrp = GraphicsSettings.renderPipelineAsset as HDRenderPipelineAsset; m_SkyHDRIMaterial = CoreUtils.CreateEngineMaterial(hdrp.renderPipelineResources.hdriSky); } public override void Cleanup() { CoreUtils.Destroy(m_SkyHDRIMaterial); } public override void SetRenderTargets(BuiltinSkyParameters builtinParams) { if (builtinParams.depthBuffer == BuiltinSkyParameters.nullRT) { HDUtils.SetRenderTarget(builtinParams.commandBuffer, builtinParams.hdCamera, builtinParams.colorBuffer); } else { HDUtils.SetRenderTarget(builtinParams.commandBuffer, builtinParams.hdCamera, builtinParams.colorBuffer, builtinParams.depthBuffer); } } public override void RenderSky(BuiltinSkyParameters builtinParams, bool renderForCubemap) { m_PropertyBlock.SetTexture(HDShaderIDs._Cubemap, m_HdriSkyParams.hdriSky); m_PropertyBlock.SetVector(HDShaderIDs._SkyParam, new Vector4(m_HdriSkyParams.exposure, m_HdriSkyParams.multiplier, -m_HdriSkyParams.rotation, 0.0f)); // -rotation to match Legacy... // This matrix needs to be updated at the draw call frequency. m_PropertyBlock.SetMatrix(HDShaderIDs._PixelCoordToViewDirWS, builtinParams.pixelCoordToViewDirMatrix); CoreUtils.DrawFullScreen(builtinParams.commandBuffer, m_SkyHDRIMaterial, m_PropertyBlock, renderForCubemap ? 0 : 1); } public override bool IsValid() { return m_HdriSkyParams != null && m_SkyHDRIMaterial != null; } } Rendering Shader This is highly dependent on what the particular sky is supposed to look like. Here we\u2019ll just show the example of HDRISky. Note that we implemented two passes, one that uses Depth Test for rendering the sky in the background (so that it\u2019s occluded by geometry) and the other that does not for when the sky is rendered into the reflection cubemap. Shader \"Hidden/HDRenderPipeline/Sky/HDRISky\"<br/>{ HLSLINCLUDE #pragma vertex Vert #pragma fragment Frag #pragma target 4.5 #pragma only_renderers d3d11 ps4 xboxone vulkan metal #include \"CoreRP/ShaderLibrary/Common.hlsl\" #include \"CoreRP/ShaderLibrary/Color.hlsl\" #include \"CoreRP/ShaderLibrary/CommonLighting.hlsl\" TEXTURECUBE(_Cubemap); SAMPLER(sampler_Cubemap); float4 _SkyParam; // x exposure, y multiplier, z rotation float4x4 _PixelCoordToViewDirWS; // Actually just 3x3, but Unity can only set 4x4 struct Attributes { uint vertexID : SV_VertexID; }; struct Varyings { float4 positionCS : SV_POSITION; }; Varyings Vert(Attributes input) { Varyings output; output.positionCS = GetFullScreenTriangleVertexPosition(input.vertexID, UNITY_RAW_FAR_CLIP_VALUE); return output; } float4 Frag(Varyings input) : SV_Target { // Points towards the camera float3 viewDirWS = normalize(mul(float3(input.positionCS.xy, 1.0), (float3x3)_PixelCoordToViewDirWS)); // Reverse it to point into the scene float3 dir = -viewDirWS; // Rotate direction float phi = DegToRad(_SkyParam.z); float cosPhi, sinPhi; sincos(phi, sinPhi, cosPhi); float3 rotDirX = float3(cosPhi, 0, -sinPhi); float3 rotDirY = float3(sinPhi, 0, cosPhi); dir = float3(dot(rotDirX, dir), dir.y, dot(rotDirY, dir)); float3 skyColor = ClampToFloat16Max(SAMPLE_TEXTURECUBE_LOD(_Cubemap, sampler_Cubemap, dir, 0).rgb * exp2(_SkyParam.x) * _SkyParam.y); return float4(skyColor, 1.0); } ENDHLSL SubShader { Pass { ZWrite Off ZTest Always Blend Off Cull Off HLSLPROGRAM ENDHLSL } Pass { ZWrite Off ZTest LEqual Blend Off Cull Off HLSLPROGRAM ENDHLSL } } Fallback Off } After doing all this, the new Sky should automatically appear in the combo box in the Visual Environment component.","title":"High Definition Render Pipeline"},{"location":"HDRP/HDRenderPipeline/#high-definition-render-pipeline","text":"The High Definition Render Pipeline (HDRP) is a high-fidelity Scriptable Render Pipeline built by Unity to target modern (Compute Shader compatible) platforms. The HDRP utilizes Physically-Based Lighting techniques, linear lighting, HDR lighting and a configurable hybrid Tile/Cluster deferred/Forward lighting architecture and gives you the tools you need to create games, technical demos, animations and more to a high graphical standard. NOTE: Projects made using HDRP are not compatible with the Lightweight Render Pipeline. You must decide which render pipeline your project will use before starting development as HDRP features are not cross-compatible between HDRP and Lightweight. This section contains the information you need to begin creating applications using HDRP; including information on Lighting, Materials and Shaders, Cameras, debugging and information for advanced users. HRDP is only supported on the following platforms: Note: HDRP will only work on the following platforms if the device used supports Compute Shaders. I.e: HDRP will only work on iOS if the iPhone model used supports Compute Shaders. Windows and Windows Store, with DirectX 11 or DirectX 12 and Shader Model 5.0 macOS and iOS using Metal graphics Android, Linux and Windows platforms with Vulkan Modern consoles (Sony PS4 and Microsoft Xbox One) HDRP does not support OpenGL or OpenGL ES devices.","title":"High Definition Render Pipeline"},{"location":"HDRP/HDRenderPipeline/#getting-started-with-high-definition-render-pipeline","text":"This page details the initial setup of a project using the High Definition Render Pipeline (HDRP) and notes on upgrading existing projects to HDRP.","title":"Getting Started with High Definition Render Pipeline"},{"location":"HDRP/HDRenderPipeline/#setting-up-a-new-project","text":"","title":"Setting up a new Project"},{"location":"HDRP/HDRenderPipeline/#using-unity-hub","text":"To set up a new HDRP project using Unity Hub, click the New button, then select High Definition - Preview from the Template drop-down box. After clicking Create Project, Unity will automatically create a Project with the High Definition Render Pipeline package installed.","title":"Using Unity Hub"},{"location":"HDRP/HDRenderPipeline/#upgrading-an-existing-project","text":"To upgrade an existing Project, you must first download the High Definition Render Pipeline using the Package Manager UI. Navigate to Window > Package Manager to open the Package Manager UI. Then click the All button to open the packages list. Left click on Render-pipelines.high-definition to select it, then click the Install button to add HDRP to your project. After you have installed HDRP from the Package Manager UI you must add the HDRP Asset to the Scriptable Render Pipeline Graphics settings field. Navigate to Edit > Settings > Graphics Settings, then Assign the HDRP Asset to the Scriptable Render Pipeline field by dragging in the HDRP Asset, or using the radio button to select the Asset from the popup window.","title":"Upgrading an Existing Project"},{"location":"HDRP/HDRenderPipeline/#building-from-source-code","text":"The latest version of the Scriptable Render Pipeline (SRP) repo can be found at the following link: https://github.com/Unity-Technologies/ScriptableRenderPipeline","title":"Building from source code"},{"location":"HDRP/HDRenderPipeline/#github-desktop-or-git-command-line-tools","text":"","title":"Github Desktop or Git command line tools"},{"location":"HDRP/HDRenderPipeline/#cloning-the-repo-using-the-github-desktop-app","text":"Open the GitHub Desktop App and click Clone a Repository. Click the URL tab in the Clone a Repository window Enter the following URL: https://github.com/Unity-Technologies/ScriptableRenderPipeline Click the Choose\u2026 button to navigate to your project\u2019s Asset folder. Click the Clone button. After the repo has been cloned you must run the following console commands from the ScriptableRenderPipeline folder: git checkout Unity-2018.1.0b2 (or the latest tag) git submodule update --init --recursive --remote","title":"Cloning the repo using the GitHub Desktop App:"},{"location":"HDRP/HDRenderPipeline/#cloning-the-repo-using-git-console-commands","text":"Enter the following commands in your console application of choice: cd <Path to your Unity project>/Assets git clone https://github.com/Unity-Technologies/ScriptableRenderPipeline cd ScriptableRenderPipeline git checkout Unity-2018.1.0b2 (or the latest tag) git submodule update --init --recursive --remote Once you have cloned the repo, re-open your project and follow the below instructions: Navigate to Edit > Project Settings > Graphics and add the HDRenderPipelineAsset Asset to the Render Pipeline Settings field. Create a copy of the HDRenderPipelineAsset and store it outside of the Scriptable Render Pipeline folder. This ensures that your HDRP settings are not lost when merging new changes from the SRP repo. HDRP will be ready to use in your project after following the above instructions.","title":"Cloning the repo using Git console commands:"},{"location":"HDRP/HDRenderPipeline/#upgrading-shaders","text":"The built-in Unity shaders are incompatible with Scriptable Render Pipelines, as such, any preexisting Shaders in your project must be updated to work with the HDRP. Navigate to Edit > Render Pipelines > Upgrade Project Materials to High Definition Materials to run the automatic upgrade script. This script with automatically update all preexisting shaders in your project to the new HDRP shaders.","title":"Upgrading Shaders"},{"location":"HDRP/HDRenderPipeline/#the-hd-render-pipeline-lit-shader","text":"The lit shader is the default shader when using HDRenderPipeline (HDRP). This shader can be set with subsurface scattering, iridescence, vertex or pixel displacement and many other new parameters. This shader allows to users to produce more realistic assets with the use of HDRP. A version call LitTessellation is used to activate the tessellation.","title":"The HD Render Pipeline Lit Shader"},{"location":"HDRP/HDRenderPipeline/#creating-a-lit-shader","text":"In HDRP, when a new material is created it is by default a lit shader.","title":"Creating a Lit Shader"},{"location":"HDRP/HDRenderPipeline/#how-to-set-a-lit-shader","text":"","title":"How to set a Lit Shader?"},{"location":"HDRP/HDRenderPipeline/#surface-options","text":"Surface type: Surface can be set as Opaque or Transparent. Transparent is an alpha blend and it is more costly. Alpha Cutoff: This check box enable the alpha cutoff to use an alpha test. The handle set the value of the test. All the values under the handle value is totally transparent and the values equal or above the handle value is opaque. Double sided: This option allows the double side. The faces are rendered on the two sides. The normal mode manages the normal behaviour on the backfaces. By default the mode is mirror. Material type: Material type introduces new behaviour for shaders to create realistic assets. Standard: Common use with basic parameters. The standard type uses a metallic workflow. Subsurface scattering (SSS): Mainly use to do a skin shader. This material type simulates the light transport inside a material and create softer micro shadows. Also a new parameter appears: Enable transmission. This parameter simulate the translucency of an object and it is managed by a thickness map. SSS and transmission are setting by a diffusion profile explain later in this document. Anisotropy: The anisotropy determines the shape of the highlight. The surface vector is managed by a tangent map, an anisotropy map modulate the anisotropy intensity and a handle modulate and orient to horizontally or vertical the anisotropic effect. These parameters are more explain later in the documentation. Iridescence: Use to create an iridescent effect. The effect is modulate by an iridescence mask, iridescence thickness map and an handle iridescence thickness. Specular Color: Instead of standard type, the specular color type uses a specular workflow. In this way the specular can be colorize even for a not metallic matter. Translucent: This type is used to simulate only the transmission. It can be handy for vegetation and more light than a SSS type.This type use a profile like the SSS type to manage the transmission. Enable Decal: Allow the material to receive decals. Enable MotionVector For Vertex Animation: Use it to remove ghosting coming from vertex animation. Displacement mode: None: no change. Vertex displacement: Use a height map to displace the vertices. Pixel displacement: Use a height map to displace the pixels. Use it only on plane surface. The surface can be only digged.","title":"Surface options"},{"location":"HDRP/HDRenderPipeline/#vertex-animation-enable-wind","text":"Prototype feature, don\u2019t use it.","title":"Vertex animation / Enable wind"},{"location":"HDRP/HDRenderPipeline/#inputs","text":"Base color + opacity : RGB channels are used as base color and alpha channel is used for opacity. Smoothness handle: This handle modulate (0 to 1) the smoothness value coming from the Mask map alpha channel. Mask map: Red channel: Metallic mask. 0 = not metallic, 1 = metallic. Green channel: Ambient occlusion. Blue channel: Detail map mask. Alpha channel: Smoothness. Normal map space: By default the normal map space is in tangent space. The normal map space can be set to object space. Normal map: Use to assign the normal map. The handle modulate the normal intensity between 0 and 2. Bent normal map: The bent normal is used to have a better ambient occlusion. It works only with diffuse lighting like lightmap or light probe. Coat Mask: By default the value is 0. The mask is used to modulate the clear coat effect base on the handle value (0 to 1). Base UV mapping: UV can be set to UV0, UV1 (used by the lightmap), UV2, UV3, planar or triplanar. Planar and triplanar use a world scale. This ratio depends about the size of the textures and the texel ratio wanted. By default it is 1, that means the material is applied on 1 meter. A value of 0.5 applies the material on 2 meters. Tiling: Set the X/Y values to tile the material. Offset: Set on X/Y offset for the UV.","title":"Inputs"},{"location":"HDRP/HDRenderPipeline/#detail-inputs","text":"The detail map is a composited map used to add micro details into the material. The detail map visibility is managed by the blue channel of the Mask map. Detail map: Red channel: Grey scale used as albedo. Green channel: Green channel of the detail normal map. Blue channel: Detail smoothness. Alpha channel: Red channel of the detail normal map. Channels are organised like this due the different compressions quality of each channels. Detail UV mapping: UV0, UV1, UV2 or UV3 can be set. If the material UV are set to planar or triplanar, the detail UV are also set to planar or triplanar. Lock to base Tiling/Offset: By default a detail texture is linked to the material aspect because it is done to add a micro detail in it. If for any reason the link have to be removed, just uncheck this checkbox. Tiling: Set the tiling of the detail texture inside a tile of the material. For example if the material is tiled by 2 on a plane and the detail texture is also tile by 2, the detail will appears tile by 4 on the plane. In this condition the tile of the material can be changed without set another time the detail UV to keep the good appearance. Offset: Set on X/Y offset for the detail UV. Detail AlbedoScale: This handle modulate (0 to 2) the detail albedo (red channel) like an overlay effect. The default value is 1 and has no scale. Detail NormalScale: This handle modulate (0 to 2) the intensity of the detail normal map. The default value is 1 and has no scale. Detail SmoothnessScale: This handle modulate (0 to 2) the detail smoothness (blue channel) like an overlay effect. The default value is 1 and has no scale.","title":"Detail inputs"},{"location":"HDRP/HDRenderPipeline/#emissive-inputs","text":"Emissive color: The emissive color can be managed by a map or a single color. If both are used they are multiplied. Emissive intensity: Set the power of the emissive effect. By default the value is 0 and doesn\u2019t produce any emissive effect. Albedo Affect Emissive: By default it is on and allows the albedo to produce color for the emissive. In this case the albedo is multiplied by emissive color and color picker to produce the emissive final color. For example the emissive color map can be used as an emissive mask, the albedo used to do the color and the color picker to modulate it.","title":"Emissive inputs"},{"location":"HDRP/HDRenderPipeline/#advanced-options","text":"Enable GPU instancing: If objects are not static batched and identical, all objects with this material become instanced. For example, objects with an animation base on the object pivot can\u2019t be static batched (unique pivot for all) but they can be instanced by GPU. Enable Specular Occlusion from Bent normal: This option used the bent normal assign in the bent normal slot to do a specular occlusion for the reflection probe.","title":"Advanced options:"},{"location":"HDRP/HDRenderPipeline/#specific-setting-from-material-type","text":"","title":"Specific setting from material type"},{"location":"HDRP/HDRenderPipeline/#subsurface-scattering","text":"Enable transmission: On/off the transmission effect. The transmission is managed by a profile and a thickness map. More the object is set thin more lighting cross it. Specific subsurface settings: Diffusion profile: Rollout menu to choose the profile. Profiles are set in the SSSSettings.asset file. Goto button select the the SSSSettings file. Subsurface mask map: This map uses the red channel to manage the visibility (0 = not visible, 1= totally visible) of the SSS effect. This map is modulated by the handle value (0 to 1, 1 is the default). Thickness map: This map uses the red channel to set the thickness inside the range set in the profile. 0 is the min range value and 1 is the max range value. The profile: Name: Name of the profile Scattering value: It is a HDR value to manage the color and the scatter of the SSS. Max radius: It is an information value and linked to the scattering value. It is the effective radius in millimeters. The blur is energy-preserving, so a wide result in a large area provides a small contribution of individual samples. A short distance increases the sharpness of the result. Index of Refraction: To set the real index of refraction. It is 1.4 for skin and between 1.3 and 1.5 for most other material. World scale: Set the size of the world unit in meters. Default it is 1 and shouldn\u2019t be modified except if the world unit used is customized. Subsurface scattering only: Texturing mode: Specifies when the diffuse texture should be applied. Transmission only: Transmission mode: Regular or Thin object. Really thin object need a specific use. Transmission tint: Set a HDR value to color the transmission. Min/Max thickness (mm): Set the range of the thickness. This range is modulate by the thickness map (0 = min, 1 = max). Thickness remap: This setting allows to remap the thickness without to change the min/max values. The range can be moved without losing the thickness values. Profile preview: Shows the fraction of lights scattered from the source located in the center.The distance to the boundary of the image corresponds to the max radius. Display is not HDR, so the intensity of pixels around the center may be clipped. Transmission preview: Shows the fraction of light passing through the object for thickness values from the remap. Can be viewed as a cross section of a slab of material illuminated by white light from the left.","title":"Subsurface scattering"},{"location":"HDRP/HDRenderPipeline/#anisotropy","text":"Anisotropic materials don\u2019t have an uniform specular shape. Real anisotropy example: Anisotropy is used to deform the specular shape on an axe. Tangent map: It is a vector map. Red and Green channel orient the specular shape. Anisotropy: This handle modulate the intensity of the anisotropic effect and modify the shape orientation, horizontally or vertically, coming from the tangent map. Anisotropy map: This map uses the red channel to modulate the anisotropic effect intensity.","title":"Anisotropy"},{"location":"HDRP/HDRenderPipeline/#iridescence","text":"The iridescence (Thin-film interference) is a natural phenomenon in which lightwaves reflected by the upper and lower boundaries of a thin film interfere with one another, either enhancing or reducing the reflected light. Iridescence Mask: This map uses the red channel to manage the visibility of the iridescence effect. The handle can modulate the mask or the visibility if no mask is assigned. Iridescence Layer thickness map: If no map is assigned, by default the value is 1. The iridescence gradient color is linked to the thickness. When the thickness change the gradient color change too. The handle modulate the thickness also and it is multiplied when a map is assigned. FYI: If the base color is white no iridescence can be visible. For a white base color no lighting enter the matter. All the lighting is reflected to produce a pure white color, so no iridescence can be produce.","title":"Iridescence"},{"location":"HDRP/HDRenderPipeline/#specular-color","text":"When the specular color shader type is chosen, the specular color is defined by a dedicated map not anymore by the albedo value. Specular color: RGB map to set the specular color. When no map is assigned the default value is 1. Picker color: Uniform color used for the specular. It is multiply by the Specular color map.","title":"Specular color"},{"location":"HDRP/HDRenderPipeline/#translucent","text":"The translucency is the transmission of a part of light across the matter. The translucency is manage by a profile and a thickness map like for the subsurface scattering.","title":"Translucent"},{"location":"HDRP/HDRenderPipeline/#how-to-set-a-lit-shader-tessellation","text":"From a lit shader, use the shader rollout menu to choose the LayeredLitTessellation shader. In case of lit shader tessellation only standard, subsurface scattering and translucent types are available. Displacement mode: None: No displacement is applied. The tessellation is used only to smooth the surface. Tessellation displacement: A height map (red channel) is used in the inputs to displace the mesh vertices. Lock with object scale: the height map appearance doesn\u2019t change when the object is scaled. Lock with height map tiling rate: the height map appearance doesn\u2019t change when the material is tiled. Tessellations options: Tessellation mode: None: no smooth is aplied. Phong: the tessellation applied a smooth effect. Tessellation factor: Between 0 and 64 this factor modulate the tessellation quantity. Higher value mean a surface more tessellated. Above 15 is costly. For XBox one and Playstation4 the maximum is set to 15. Start fade distance: It is the distance (in Unity unit) to the camera where the tessellation start to fade out. End fade distance: It is the maximum distance (in Unity unit) to the camera where triangle are tessellated. Triangle size: Desired screen space size of triangle (in pixel). A smaller value mean smaller triangle. Height map parameterization: Two parametrizations are available. Min/Max: In this mode the base of the height map is linked to the base of the mesh. It is used if the height map has uniform values on the map. Min: Set the height value for the 0 value on the map. Max: Set the height value for the 1 (255) value on the map. Offset: Can up and down the height map without modify the min/max values. Amplitude: Amplitude mode is more used in case of height map with a dedicated center. In this case the height map uses often none uniform values. In case of non uniform values a range of the map is not used to store values, it is clamped in positive or negative. Amplitude: The amplitude is the double value of the maximum value in negative or in positive. Base: It is the reference of the base mesh into the height map. By default the base is at 0.5. Offset: Can up and down the height map without modify the other values.","title":"How to set a Lit Shader Tessellation?"},{"location":"HDRP/HDRenderPipeline/#sky-and-fog","text":"In HDRP, sky and fog are setup via the interpolation volume framework. The goal is for the user to be able to dynamically change the look of the sky and fog depending on the camera position. We also provide the necessary tools to offer consistent baking of lightmaps and probes. The Sky Framework used by HDRP is also designed in a way that it is easy for users to write their own custom sky and use it in their project with minimal effort. As part of the Volume framework, all local settings components described below are actually VolumeComponents which need to be added to a VolumeComponent on a regular GameObject. As such, all their parameters can be interpolated between different volumes.","title":"Sky and Fog"},{"location":"HDRP/HDRenderPipeline/#setting-up-the-sky","text":"Setting up a sky has two goals: The first one is to define what will be displayed in the background of the scene for a given camera. The second one is to define environment lighting, namely sky reflection and sky ambient probe which is then later used to render lightmaps (real-time or baked). Settings are split between global settings which are per project/platform and local settings that use the volume framework and can change depending on the scene or camera position.","title":"Setting up the Sky"},{"location":"HDRP/HDRenderPipeline/#global-sky-settings","text":"Global settings for the sky are in the HDRenderPipeline configuration asset: Sky Reflection Size This parameter drives the size of the cubemap generated from the sky and used for fallback reflection when no local reflection probes are present. It has no effect on the quality of the sky rendered in the background. Sky Lighting Override Mask In some cases, users may want to dissociate lighting environment from what is rendered in the background (a typical example is to have a very dark sky at night but have a brighter lighting so that the player can still see). In order to achieve this, users can define the sky lighting override mask which is a Layer mask. If any volumes are present in this layer then environment lighting will use these volumes instead of those from the main camera. If this mask is set to Nothing or if there are no volume in this mask then lighting will come from volumes setup in the main camera volume layer mask. In practice this means that user can define two sets of masks, one for the visual sky and the other for the lighting. Both sets of volume will then be interpolated independently from each other. Note that lighting override does not affect baked lighting.","title":"Global Sky Settings"},{"location":"HDRP/HDRenderPipeline/#local-sky-settings","text":"Once global parameters are set, users need to setup volumes with the correct components to setup local parameters for the sky. Currently HDRP provides two different kind of skies. Procedural Sky This sky is similar to the procedural sky provided with the built-in Unity Render Pipelines. Property Function Enable Sun Disk Display sun disk Sun Size Size of the sun disk Sun Size Convergence Atmospheric Thickness Sky Tint Color of the sky hemisphere Ground Color Color of the ground hemisphere Exposure Exposure applied to the sky Multiplier Multiplier applied to the sky Update Mode Rate at which the sky environment (reflection en ambient probe) should be updated On Changed Sky environment is updated when one of its parameter changes On Demand Sky Environment is explicitly updated by the script Realtime Sky environment is updated regularly Update Period Period (in seconds) at which the realtime sky is updated (0 means every frame) HDRI Sky Simple sky represented by a cubemap texture. Property Function Hdri sky Cubemap representing the sky Exposure Exposure applied to the sky Multiplier Multiplier applied to the sky Rotation Rotation applied to the cubemap in degrees Update Mode Rate at which the sky environment (reflection en ambient probe) should be updated On Changed Sky environment is updated when one of its parameter changes On Demand Sky Environment is explicitly updated by the script Realtime Sky environment is updated regularly Update Period Period (in seconds) at which the realtime sky is updated (0 means every frame)","title":"Local Sky Settings"},{"location":"HDRP/HDRenderPipeline/#baking-global-illumination-with-the-sky","text":"In HDRP the sky is completely controlled by the volume system. It means that in the editor, the current state of the sky will depend on the camera position. The consequence is that for users to get a consistent lighting baking, we can\u2019t rely on what is in the scene. Instead the sky used for baking is set explicitly by the user through the Baking Sky component. User should select a volume profile which contains the sky intended to be used for baking and then choose the right type (in case the profile contains different kinds of skies). If the component is added to a game object that already has a Volume, the profile property will be automatically populated with the corresponding profile asset. This sky setting will live outside of the volume framework and thus will never be interpolated based on the camera position. Any time the baking is required, this is the sky that will be used. Only one such component can be present in the editor at any given time. Any additional component of the same type will generate a warning and be ignored.","title":"Baking Global Illumination with the sky"},{"location":"HDRP/HDRenderPipeline/#setting-up-the-fog","text":"Fog is the effect of overlaying a color onto objects dependant on the distance from the camera. This is used to simulate fog or mist in outdoor environments and is also typically used to hide clipping of objects when a camera\u2019s far clip plane has been moved forward for performance. In HDRP, users can choose between two different kind of fogs, linear and exponential fog. All types of materials (lit or unlit) will react correctly to the fog. Depending on the type of fog, density will evolve differently with respect to distance from camera and world space height. Instead of using a constant color, both types of fog can choose to use the background sky as a source for color. In this case, the color will be sampled from different mip maps of the cubemap generated from the current sky settings. Chosen mip will vary linearly between the blurriest one to the highest resolution one depending on the distance from camera and the \"Mip Fog\" parameters. Users can also choose to limit the resolution of the higher mip used. For both types of fog, density is computed from camera distance and world space height independently and then multiplied together to obtain the final result. Linear Fog Density will increase linearly with view distance and world space height depending on the provided parameters. Property Function Density Global multiplier for the fog density Color Mode Source of the fog color Constant Color Fog is a constant color Color Color of the fog Sky Color Fog color is sampled from the sky Mip Fog Near Distance at which the blurriest sky mip is used Mip Fog Far Distance at which the higher sky mip (see \"Mip Fog Max Mip\" ) is used Mip Fog Max Mip Maximum mip map used to sample the color (1.0 being highest resolution and 0.0 lowest resolution). Fog Start Distance from camera at which fog density starts to increase from zero. Fog End Distance from camera at which fog density is maximum. Fog Height Start Height at which fog density starts to decrease Fog Height End Height at which fog density is zero Exponential Fog Density will increase exponentially with view distance and world space height depending on the provided parameters. Property Function Density Global multiplier for the fog density Color Mode Source of the fog color Constant Color Fog is a constant color Color Color of the fog Sky Color Fog color is sampled from the sky Mip Fog Near Distance at which the blurriest sky mip is used Mip Fog Far Distance at which the higher sky mip (see \"Mip Fog Max Mip\" ) is used Mip Fog Max Mip Maximum mip map used to sample the color (1.0 being highest resolution and 0.0 lowest resolution). Fog Distance Distance from camera at will reach maximum Fog Base Height World space height at which fog density starts to decrease from 1.0 Fog Height Attenuation Fall off of height fog attenuation (bigger values will make attenuation sharper)","title":"Setting up the Fog"},{"location":"HDRP/HDRenderPipeline/#visual-environment","text":"Once the proper components have been setup, users need to specify what kind of sky and fog should be used for rendering. This is done through the Visual Environment component. Property Function Sky Type Type of sky used for rendering. This list will be automatically updated with any custom sky written by users Fog Type Type of fog used for rendering To help setting things up more easily, users can use the contextual menu to directly create a game object named \"Scene Settings\" and go from there. This game object is already setup with a default procedural sky and exponential fog inside a global Volume (it also contains default shadow settings).","title":"Visual Environment"},{"location":"HDRP/HDRenderPipeline/#writing-custom-sky-renderers","text":"The sky system is setup in a way that allows users to develop their own kind of sky with their own parameters and shaders. Three things are needed in order to write your own sky. SkySettings Create a new class that inherits from SkySettings . This class will contain all parameters specific to the particular sky renderer user is writing. Please refer to the Volume system documentation to learn how to declare volume parameters. Three things are mandatory to write: SkyUniqueID attribute: This must be an integer unique to this particular sky. Must not clash with any other sky settings. The SkyType enum is available for users to see what values are already used by HDRP. GetHashCode: This is used by the sky system to determine when to re-render the sky reflection cubemap. CreateRenderer: This is used by the sky system to instantiate the proper renderer. Exemple: HDRI Sky [SkyUniqueID(87248]<br/> public class HDRISky : SkySettings { [Tooltip(\"Cubemap used to render the sky.\")] public CubemapParameter hdriSky = new CubemapParameter(null); public override SkyRenderer CreateRenderer() { return new HDRISkyRenderer(this); } public override int GetHashCode() { int hash = base.GetHashCode(); unchecked { hash = hdriSky.value != null ? hash * 23 + hdriSky.GetHashCode() : hash; } return hash; } } \u200b SkyRenderer This is the class that will actually render the sky, either into a cubemap for lighting or on the background. This is where users must implement all their specific rendering. It must implement this interface: public abstract class SkyRenderer { // Method used to initialize any resource for the sky rendering (shaders, \u2026) public abstract void Build(); // Method used to clean up any resource previously allocated public abstract void Cleanup(); // SkyRenderer is responsible for setting up render targets provided in builtinParams public abstract void SetRenderTargets(BuiltinSkyParameters builtinParams); // renderForCubemap: When rendering into a cube map, no depth buffer is available so user has to make sure not to use depth testing or the depth texture. public abstract void RenderSky(BuiltinSkyParameters builtinParams, bool renderForCubemap); // Returns true if provided sky setting parameters are valid. public abstract bool IsValid(); } Exemple: HDRISkyRenderer: public class HDRISkyRenderer : SkyRenderer<br/>{ Material m_SkyHDRIMaterial; // Renders a cubemap into a render texture (can be cube or 2D) MaterialPropertyBlock m_PropertyBlock; HDRISky m_HdriSkyParams; public HDRISkyRenderer(HDRISky hdriSkyParams) { m_HdriSkyParams = hdriSkyParams; m_PropertyBlock = new MaterialPropertyBlock(); } public override void Build() { var hdrp = GraphicsSettings.renderPipelineAsset as HDRenderPipelineAsset; m_SkyHDRIMaterial = CoreUtils.CreateEngineMaterial(hdrp.renderPipelineResources.hdriSky); } public override void Cleanup() { CoreUtils.Destroy(m_SkyHDRIMaterial); } public override void SetRenderTargets(BuiltinSkyParameters builtinParams) { if (builtinParams.depthBuffer == BuiltinSkyParameters.nullRT) { HDUtils.SetRenderTarget(builtinParams.commandBuffer, builtinParams.hdCamera, builtinParams.colorBuffer); } else { HDUtils.SetRenderTarget(builtinParams.commandBuffer, builtinParams.hdCamera, builtinParams.colorBuffer, builtinParams.depthBuffer); } } public override void RenderSky(BuiltinSkyParameters builtinParams, bool renderForCubemap) { m_PropertyBlock.SetTexture(HDShaderIDs._Cubemap, m_HdriSkyParams.hdriSky); m_PropertyBlock.SetVector(HDShaderIDs._SkyParam, new Vector4(m_HdriSkyParams.exposure, m_HdriSkyParams.multiplier, -m_HdriSkyParams.rotation, 0.0f)); // -rotation to match Legacy... // This matrix needs to be updated at the draw call frequency. m_PropertyBlock.SetMatrix(HDShaderIDs._PixelCoordToViewDirWS, builtinParams.pixelCoordToViewDirMatrix); CoreUtils.DrawFullScreen(builtinParams.commandBuffer, m_SkyHDRIMaterial, m_PropertyBlock, renderForCubemap ? 0 : 1); } public override bool IsValid() { return m_HdriSkyParams != null && m_SkyHDRIMaterial != null; } } Rendering Shader This is highly dependent on what the particular sky is supposed to look like. Here we\u2019ll just show the example of HDRISky. Note that we implemented two passes, one that uses Depth Test for rendering the sky in the background (so that it\u2019s occluded by geometry) and the other that does not for when the sky is rendered into the reflection cubemap. Shader \"Hidden/HDRenderPipeline/Sky/HDRISky\"<br/>{ HLSLINCLUDE #pragma vertex Vert #pragma fragment Frag #pragma target 4.5 #pragma only_renderers d3d11 ps4 xboxone vulkan metal #include \"CoreRP/ShaderLibrary/Common.hlsl\" #include \"CoreRP/ShaderLibrary/Color.hlsl\" #include \"CoreRP/ShaderLibrary/CommonLighting.hlsl\" TEXTURECUBE(_Cubemap); SAMPLER(sampler_Cubemap); float4 _SkyParam; // x exposure, y multiplier, z rotation float4x4 _PixelCoordToViewDirWS; // Actually just 3x3, but Unity can only set 4x4 struct Attributes { uint vertexID : SV_VertexID; }; struct Varyings { float4 positionCS : SV_POSITION; }; Varyings Vert(Attributes input) { Varyings output; output.positionCS = GetFullScreenTriangleVertexPosition(input.vertexID, UNITY_RAW_FAR_CLIP_VALUE); return output; } float4 Frag(Varyings input) : SV_Target { // Points towards the camera float3 viewDirWS = normalize(mul(float3(input.positionCS.xy, 1.0), (float3x3)_PixelCoordToViewDirWS)); // Reverse it to point into the scene float3 dir = -viewDirWS; // Rotate direction float phi = DegToRad(_SkyParam.z); float cosPhi, sinPhi; sincos(phi, sinPhi, cosPhi); float3 rotDirX = float3(cosPhi, 0, -sinPhi); float3 rotDirY = float3(sinPhi, 0, cosPhi); dir = float3(dot(rotDirX, dir), dir.y, dot(rotDirY, dir)); float3 skyColor = ClampToFloat16Max(SAMPLE_TEXTURECUBE_LOD(_Cubemap, sampler_Cubemap, dir, 0).rgb * exp2(_SkyParam.x) * _SkyParam.y); return float4(skyColor, 1.0); } ENDHLSL SubShader { Pass { ZWrite Off ZTest Always Blend Off Cull Off HLSLPROGRAM ENDHLSL } Pass { ZWrite Off ZTest LEqual Blend Off Cull Off HLSLPROGRAM ENDHLSL } } Fallback Off } After doing all this, the new Sky should automatically appear in the combo box in the Visual Environment component.","title":"Writing Custom Sky Renderers"},{"location":"LWRP/","text":"About the Lightweight Render Pipeline The Lightweight Render Pipeline (LWRP) is a prebuilt Scriptable Render Pipeline, made by Unity. The technology offers graphics that are scalable to mobile platforms, and you can also use it for higher-end consoles and PCs. You\u2019re able to achieve quick rendering at a high quality without needing compute shader technology. LWRP uses simplified, physically based Lighting and Materials. The LWRP uses single-pass forward rendering. Use this pipeline to get optimized real-time performance on several platforms. The LWRP is supported on the following platforms: Windows and UWP Mac and iOS Android XBox One PlayStation4 Nintendo Switch * All current VR platforms The Lightweight Render Pipeline is available via two templates: LWRP and LWRP-VR. The LWRP-VR comes with pre-enabled settings specifically for VR. The documentation for both render pipelines is the same. For any questions regarding LWRP-VR, see the LWRP documentation. Note: Built-in and custom Lit Shaders do not work with the Lightweight Render Pipeline. Instead, LWRP has a new set of standard shaders. If you upgrade a current Project to LWRP, you can upgrade built-in shaders to the new ones. Note: Projects made using LWRP are not compatible with the High Definition Render Pipeline or the built-in Unity rendering pipeline. Before you start development, you must decide which render pipeline to use in your Project.","title":"About the Lightweight Render Pipeline"},{"location":"LWRP/#about-the-lightweight-render-pipeline","text":"The Lightweight Render Pipeline (LWRP) is a prebuilt Scriptable Render Pipeline, made by Unity. The technology offers graphics that are scalable to mobile platforms, and you can also use it for higher-end consoles and PCs. You\u2019re able to achieve quick rendering at a high quality without needing compute shader technology. LWRP uses simplified, physically based Lighting and Materials. The LWRP uses single-pass forward rendering. Use this pipeline to get optimized real-time performance on several platforms. The LWRP is supported on the following platforms: Windows and UWP Mac and iOS Android XBox One PlayStation4 Nintendo Switch * All current VR platforms The Lightweight Render Pipeline is available via two templates: LWRP and LWRP-VR. The LWRP-VR comes with pre-enabled settings specifically for VR. The documentation for both render pipelines is the same. For any questions regarding LWRP-VR, see the LWRP documentation. Note: Built-in and custom Lit Shaders do not work with the Lightweight Render Pipeline. Instead, LWRP has a new set of standard shaders. If you upgrade a current Project to LWRP, you can upgrade built-in shaders to the new ones. Note: Projects made using LWRP are not compatible with the High Definition Render Pipeline or the built-in Unity rendering pipeline. Before you start development, you must decide which render pipeline to use in your Project.","title":"About the Lightweight Render Pipeline"},{"location":"LWRP/TableOfContents/","text":"About LWRP Getting started with LWRP Creating a new Project with LWRP Upgrading your existing Project to use LWRP Configuring LWRP for use Inside LWRP The LWRP Asset Shader stripping Built-in/LWRP comparison Shading Models in LWRP Shaders in LWRP Lit Simple Lit Upgrading shaders","title":"TableOfContents"},{"location":"LWRP/autodesk-interactive-masked-shader/","text":"Important: This page is still a work in progress. To read our most current documentation, open the TableOfContents.md file to see the linked pages.","title":"Autodesk interactive masked shader"},{"location":"LWRP/autodesk-interactive-shader/","text":"Important: This page is still a work in progress. To read our most current documentation, open the TableOfContents.md file to see the linked pages.","title":"Autodesk interactive shader"},{"location":"LWRP/autodesk-interactive-transparent-shader/","text":"Important: This page is still a work in progress. To read our most current documentation, open the TableOfContents.md file to see the linked pages.","title":"Autodesk interactive transparent shader"},{"location":"LWRP/baked-lit-shader/","text":"Important: This page is still a work in progress. To read our most current documentation, open the TableOfContents.md file to see the linked pages.","title":"Baked lit shader"},{"location":"LWRP/camera-inspector/","text":"Important: This page is still a work in progress. To read our most current documentation, open the TableOfContents.md file to see the linked pages.","title":"Camera inspector"},{"location":"LWRP/camera/","text":"Important: This page is still a work in progress. To read our most current documentation, open the TableOfContents.md file to see the linked pages.","title":"Camera"},{"location":"LWRP/configuring-lwrp-for-use/","text":"Note: This page is subject to change during the 2019.1 beta cycle. Configuring LWRP for use To configure and use LWRP, you must first create the Lightweight Render Pipeline Asset, and then add the Asset to the Graphics settings for your Project. To read more about each step, see below. Creating the Lightweight Render Pipeline Asset The Scriptable Render Pipeline Asset controls the global rendering and quality settings of your Project and creates the rendering pipeline instance. The rendering pipeline instance contains intermediate resources and the render pipeline implementation. To create a Lightweight Render Pipeline Asset: In the Editor, go to the Project window. Right-click in the Project window, and select Create > Rendering > Lightweight Render Pipeline Asset . Alternatively, navigate to the menu bar in top, and click Assets > Create > Rendering > Lightweight Render Pipeline Asset . Either leave the default name for the Asset, or type a new one. You've now created a LWRP Asset. Tip: You can create multiple LWRP Assets to store settings for different platforms or for different testing environments. Once you've started using LWRP, try swapping out LWRP Assets under Graphics settings and test the combinations, to see what fits your Project or platforms best. You cannot swap LWRP Assets for other types of render pipeline assets, though. Adding the Asset to your Graphics settings To use the Lightweight Render Pipeline, you have to add the newly created LWRP Asset to your Graphics settings in Unity. If you don't, Unity still tries to use the built-in render pipeline. Navigate to Edit > Project Settings > Graphics . In the Render Pipeline Settings field, add the LWRP Asset you created earlier. Note: When you add the LWRP Asset, the available settings in LWRP immediately changes. This is because you've effectively instructed Unity to use the LWRP specific settings instead of those for the built-in render pipeline.","title":"Configuring lwrp for use"},{"location":"LWRP/configuring-lwrp-for-use/#configuring-lwrp-for-use","text":"To configure and use LWRP, you must first create the Lightweight Render Pipeline Asset, and then add the Asset to the Graphics settings for your Project. To read more about each step, see below.","title":"Configuring LWRP for use"},{"location":"LWRP/configuring-lwrp-for-use/#creating-the-lightweight-render-pipeline-asset","text":"The Scriptable Render Pipeline Asset controls the global rendering and quality settings of your Project and creates the rendering pipeline instance. The rendering pipeline instance contains intermediate resources and the render pipeline implementation. To create a Lightweight Render Pipeline Asset: In the Editor, go to the Project window. Right-click in the Project window, and select Create > Rendering > Lightweight Render Pipeline Asset . Alternatively, navigate to the menu bar in top, and click Assets > Create > Rendering > Lightweight Render Pipeline Asset . Either leave the default name for the Asset, or type a new one. You've now created a LWRP Asset. Tip: You can create multiple LWRP Assets to store settings for different platforms or for different testing environments. Once you've started using LWRP, try swapping out LWRP Assets under Graphics settings and test the combinations, to see what fits your Project or platforms best. You cannot swap LWRP Assets for other types of render pipeline assets, though.","title":"Creating the Lightweight Render Pipeline Asset"},{"location":"LWRP/configuring-lwrp-for-use/#adding-the-asset-to-your-graphics-settings","text":"To use the Lightweight Render Pipeline, you have to add the newly created LWRP Asset to your Graphics settings in Unity. If you don't, Unity still tries to use the built-in render pipeline. Navigate to Edit > Project Settings > Graphics . In the Render Pipeline Settings field, add the LWRP Asset you created earlier. Note: When you add the LWRP Asset, the available settings in LWRP immediately changes. This is because you've effectively instructed Unity to use the LWRP specific settings instead of those for the built-in render pipeline.","title":"Adding the Asset to your Graphics settings"},{"location":"LWRP/creating-a-new-project-with-lwrp/","text":"Note: This page is subject to change during the 2019.1 beta cycle. Using LWRP in a new Project If you want to use the Lightweight Render Pipeline in a new Project, you can create a new Project using Templates. To create a Project using Templates: Open Unity. On the Home page, click New to start a new Project. Under Template , select the Lightweight Render Pipeline template. Click Create Project . Unity automatically creates a new Project for you, complete with all the LWRP functions. For more information on using Templates, see Project Templates in the Unity Manual. Note: Before you can start using LWRP, you must configure it by creating a Scriptable Render Pipeline Asset and changing your Graphics settings. To learn how, see Configuring LWRP for use .","title":"Creating a new project with lwrp"},{"location":"LWRP/creating-a-new-project-with-lwrp/#using-lwrp-in-a-new-project","text":"If you want to use the Lightweight Render Pipeline in a new Project, you can create a new Project using Templates. To create a Project using Templates: Open Unity. On the Home page, click New to start a new Project. Under Template , select the Lightweight Render Pipeline template. Click Create Project . Unity automatically creates a new Project for you, complete with all the LWRP functions. For more information on using Templates, see Project Templates in the Unity Manual. Note: Before you can start using LWRP, you must configure it by creating a Scriptable Render Pipeline Asset and changing your Graphics settings. To learn how, see Configuring LWRP for use .","title":"Using LWRP in a new Project"},{"location":"LWRP/faq/","text":"FAQ Can I no longer use information from the Unity Manual? Oh, please do! We reused as much as possible of the built-in Unity render pipeline. The Graphics section of the Unity Manual still has a lot of good stuff. In the documentation for LWRP, you'll find cross references to the Graphics manual, whenever something's already explained there. So what do I need this documentation for? Because this is where you'll read specifically about LWRP. Because LWRP is a package that requires for you to download, we're keeping the docs specific to that package separate from the general user Manual. Can I use LWRP and HDRP at the same time? No. They're both built on the Scriptable Render Pipelines, but their render paths and light models are different. Can I convert from one pipeline to the other? Yes! To do so, you'll have to re-write your assets and revisit your lighting strategy for your game or app. Important: This page is still a work in progress. To read our most current documentation, open the TableOfContents.md file to see the linked pages.","title":"FAQ"},{"location":"LWRP/faq/#faq","text":"","title":"FAQ"},{"location":"LWRP/faq/#can-i-no-longer-use-information-from-the-unity-manual","text":"Oh, please do! We reused as much as possible of the built-in Unity render pipeline. The Graphics section of the Unity Manual still has a lot of good stuff. In the documentation for LWRP, you'll find cross references to the Graphics manual, whenever something's already explained there.","title":"Can I no longer use information from the Unity Manual?"},{"location":"LWRP/faq/#so-what-do-i-need-this-documentation-for","text":"Because this is where you'll read specifically about LWRP. Because LWRP is a package that requires for you to download, we're keeping the docs specific to that package separate from the general user Manual.","title":"So what do I need this documentation for?"},{"location":"LWRP/faq/#can-i-use-lwrp-and-hdrp-at-the-same-time","text":"No. They're both built on the Scriptable Render Pipelines, but their render paths and light models are different.","title":"Can I use LWRP and HDRP at the same time?"},{"location":"LWRP/faq/#can-i-convert-from-one-pipeline-to-the-other","text":"Yes! To do so, you'll have to re-write your assets and revisit your lighting strategy for your game or app. Important: This page is still a work in progress. To read our most current documentation, open the TableOfContents.md file to see the linked pages.","title":"Can I convert from one pipeline to the other?"},{"location":"LWRP/forward-renderer/","text":"Important: This page is still a work in progress. To read our most current documentation, open the TableOfContents.md file to see the linked pages.","title":"Forward renderer"},{"location":"LWRP/getting-started-with-lwrp/","text":"Note: This page is subject to change during the 2019.1 beta cycle. Getting started with LWRP To use the Lightweight Render Pipeline, you can either start a new Project or upgrade an existing one. Once you have Project with LWRP, you must create a Scriptable Render Pipeline (SRP) Asset, and then configure the Graphics settings for your Project. The following sub-chapters detail how to: - Create a new Project with LWRP - Upgrade an existing Project to LWRP - Configure LWRP for use, including creating an SRP Asset and changing the Graphics settings. Note: Projects made using LWRP are not compatible with the High Definition Render Pipeline or the built-in Unity rendering pipeline. This is because the three render pipelines use different lighting models. Before you start development, you must decide which render pipeline to use in your Project. Note: Built-in and custom Lit Shaders do not work with the Lightweight Render Pipeline. Instead, LWRP has a new set of standard shaders. If you upgrade a current Project to LWRP, you can upgrade built-in shaders to the new ones.","title":"Getting started with lwrp"},{"location":"LWRP/getting-started-with-lwrp/#getting-started-with-lwrp","text":"To use the Lightweight Render Pipeline, you can either start a new Project or upgrade an existing one. Once you have Project with LWRP, you must create a Scriptable Render Pipeline (SRP) Asset, and then configure the Graphics settings for your Project. The following sub-chapters detail how to: - Create a new Project with LWRP - Upgrade an existing Project to LWRP - Configure LWRP for use, including creating an SRP Asset and changing the Graphics settings. Note: Projects made using LWRP are not compatible with the High Definition Render Pipeline or the built-in Unity rendering pipeline. This is because the three render pipelines use different lighting models. Before you start development, you must decide which render pipeline to use in your Project. Note: Built-in and custom Lit Shaders do not work with the Lightweight Render Pipeline. Instead, LWRP has a new set of standard shaders. If you upgrade a current Project to LWRP, you can upgrade built-in shaders to the new ones.","title":"Getting started with LWRP"},{"location":"LWRP/inside-lwrp/","text":"Note: This page is subject to change during the 2019.1 beta cycle. Inside LWRP In the following sections, you can read more about the technology inside LWRP: The LWRP Asset Shader stripping Shader stripping keywords Built-in/LWRP comparison Shading Models in LWRP","title":"Inside lwrp"},{"location":"LWRP/inside-lwrp/#inside-lwrp","text":"In the following sections, you can read more about the technology inside LWRP: The LWRP Asset Shader stripping Shader stripping keywords Built-in/LWRP comparison Shading Models in LWRP","title":"Inside LWRP"},{"location":"LWRP/installing-lwrp-into-an-existing-project/","text":"Note: While LWRP is in preview, this documentation might not reflect the end-result 100%, and is therefore subject to change. Installing LWRP into an existing Project You can download and install the latest version of LWRP to your existing Project via the Package Manager system . To install LWRP into an existing Project: In Unity, open your Project. In the top navigation bar, click Window > Package Manager to open the Package Manager window. Select the All tab. This tab displays the list of available packages for the version of Unity that you are currently running. Select Lightweight Render Pipeline from the list of packages. In the top right corner of the window, click Install . This installs LWRP directly into your Project. Note: Before you can start using LWRP, you must configure it by creating a Scriptable Render Pipeline Asset and changing your Graphics settings. To learn how, see Configuring LWRP for use . Note: Switching to LWRP in an existing Project consumes a lot of time and resources. LWRP uses custom lit shaders and is not compatible with the built-in Unity lit shaders. You will have to manually change or convert many elements. Instead, consider starting a new Project with LWRP .","title":"Installing lwrp into an existing project"},{"location":"LWRP/installing-lwrp-into-an-existing-project/#installing-lwrp-into-an-existing-project","text":"You can download and install the latest version of LWRP to your existing Project via the Package Manager system . To install LWRP into an existing Project: In Unity, open your Project. In the top navigation bar, click Window > Package Manager to open the Package Manager window. Select the All tab. This tab displays the list of available packages for the version of Unity that you are currently running. Select Lightweight Render Pipeline from the list of packages. In the top right corner of the window, click Install . This installs LWRP directly into your Project. Note: Before you can start using LWRP, you must configure it by creating a Scriptable Render Pipeline Asset and changing your Graphics settings. To learn how, see Configuring LWRP for use . Note: Switching to LWRP in an existing Project consumes a lot of time and resources. LWRP uses custom lit shaders and is not compatible with the built-in Unity lit shaders. You will have to manually change or convert many elements. Instead, consider starting a new Project with LWRP .","title":"Installing LWRP into an existing Project"},{"location":"LWRP/integration-with-post-processing/","text":"Important: This page is still a work in progress. To read our most current documentation, open the TableOfContents.md file to see the linked pages.","title":"Integration with post processing"},{"location":"LWRP/integration-with-terrain/","text":"Important: This page is still a work in progress. To read our most current documentation, open the TableOfContents.md file to see the linked pages.","title":"Integration with terrain"},{"location":"LWRP/integrations-with-shader-graph/","text":"Important: This page is still a work in progress. To read our most current documentation, open the TableOfContents.md file to see the linked pages.","title":"Integrations with shader graph"},{"location":"LWRP/light-inspector/","text":"Important: This page is still a work in progress. To read our most current documentation, open the TableOfContents.md file to see the linked pages.","title":"Light inspector"},{"location":"LWRP/lit-shader/","text":"Note: While LWRP is in preview, this documentation might not reflect the end-result 100%, and is therefore subject to change. Lit shader The Lit shader lets you render real-world surfaces like stone, wood, glass, plastic, and metals in photo-realistic quality. Your light levels and reflections look lifelike and react properly across various lighting conditions, for example bright sunlight, or a dark cave. Using the Lit shader in the Editor You can either create a new Material with the shader or select the shader from the Material Inspector. To create a new Material with the shader: 1. In your Project window, click Create > Material . Select the Lit shader. To select the shader in the Material inspector: 1. In your Project, select the Material Inspector. 2. Click Shader , and select Lightweight Render Pipeline > Lit . UI overview The Inspector window contains these elements: Surface Options Surface Inputs Advanced Surface Options The Surface Options control how Unity renders the Material on a screen. Property Description Workflow Mode In this drop-down menu, choose a workflow that fits your textures, either Metallic and Specular . When you have made your choice, the main Texture options in the rest of the Inspector now follow your chosen workflow. For information on metallic or specular workflows, see this Manual page for the Standard built-in shader in Unity . Surface Type In this drop-down menu, choose between an Opaque or Transparent surface type. If you select Transparent , a second drop-down menu appears (see Transparent property description below). Transparent surface type Alpha uses the alpha value to change how visible an object is. 1 is fully opaque, 0 is fully transparent. Premultiply applies a similar effect as Alpha , but only keeps reflections and highlights, even when your surface is transparent. This means that only the reflected light is visible. For example, imagine transparent glass. Additive adds an extra layer on top of another surface. This is good for holograms. Multiply multiplies the colors behind the surface, like colored glass. Two Sided Enable this to render on both sides of your geometry. When disabled, Unity culls the backface of your geometry and only renders the frontface. For example, Two Sided rendering is good for small, flat objects, like leaves, where you might want both sides visible. By default, this setting is disabled, so that Unity culls backfaces. Alpha Clip Enable this to make your Material act like a Cutout shader. With this, you can create a transparent effect with hard edges between the opaque and transparent areas. For example, to create straws of grass. Unity achieves this effect by not rendering Alpha values below the specified Clip Threshold , which appears when you enable Alpha Clip . Surface Inputs The Surface Properties describe the surface itself. For example, you can use these properties to make your surface look wet, dry, rough, or smooth. Note: If you are used to the Standard Shader in the built-in Unity render pipeline, these options are similar to the Main Maps settings in the Material Editor . Property Description Albedo The albedo specifies the color of the surface. It is also known as the diffuse map. To assign a texture to the Albedo setting, click the object picker next to it. This opens the Asset Browser, where you can select from the textures on your Project. Alternatively, you can use the color picker . The color next to the setting shows the tint on top of your assigned texture. To assign another tint, you can click this color swatch. If you select Transparent or Alpha Clip under Render Properties , your Material uses the texture\u2019s alpha channel or color. Metallic / Specular Shows a map input for your chosen Workflow Mode in the Render Properties . For a Metallic map, a slider appears, and for a Specular map , a color input appears. For both map types, Smoothness controls the spread of highlights and/or reflections on the surface. Under Source , you can control where to sample a smoothness map from. By default, Source uses the Alpha channel for either map. You can also set it to the Albedo Alpha channel. Normal Map Assign a tangent-space normal map , similar to the one in the Standard Shader in the built-in render pipeline. To read more about tangent-space normal maps, see this article on Polycount . The float value next to the setting is a multiplier for the effect of the Normal Map . Occlusion Select an occlusion map to simulate shadowing of ambient light. Emission Make the surface emit light. When enabled, the Texture map and HDR color settings appear. If you do not enable this, emission will be considered as black, and Unity skips calculating emission. Tiling A 2D multiplier value that scales the texture to fit across a mesh according to the U and V axes. This is good for surfaces like floors and walls. The default value is 1, which means no scaling. Set a higher value to make the texture repeat across your mesh. Set a lower value to stretch the texture. Try different values until you reach your desired effect. Offset The 2D offset that positions the texture on the mesh. To adjust the map position on your mesh, move the texture across the U or V axes. Specular Highlights Enable this to allow your Material to have specular highlights from direct lighting, for example Directional, Point, and Spot lights . This means that your Material reflects the shine from these light sources. Disable this to leave out these highlight calculations, so your shader renders faster. By default, this feature is enabled. Reflections Sample reflections using the nearest Reflection Probe , or, if you have set one in the Lighting window, the Lighting Probe . Disabling sampling saves on calculations, but also means that your surface has no reflections. Advanced The Rendering Options settings affect behind-the-scenes rendering. They do not have a visible effect on your surface, but on underlying calculations. Property Description GPU Instancing Make Unity render meshes with the same geometry and Material/shader in one batch, when possible. This makes rendering faster. Meshes cannot be rendered in one batch if they have different Materials or if the hardware does not support GPU instancing. Double Sided Global Illumination Make the surface act double-sided during lightmapping. When enabled, backfaces bounce light like frontfaces, but Unity still doesn\u2019t render them. Channel packing This shader uses channel packing , so you can use a single RGBA texture for the metallic, smoothness and occlusion properties. When you use texture packing, you only have to load one texture into memory instead of three separate ones. When you write your texture maps in a program like Substance or Photoshop, you can pack the maps like this: Channel Property Red Metallic Green Occlusion Blue None Alpha Smoothness","title":"Lit shader"},{"location":"LWRP/lit-shader/#lit-shader","text":"The Lit shader lets you render real-world surfaces like stone, wood, glass, plastic, and metals in photo-realistic quality. Your light levels and reflections look lifelike and react properly across various lighting conditions, for example bright sunlight, or a dark cave.","title":"Lit shader"},{"location":"LWRP/lit-shader/#using-the-lit-shader-in-the-editor","text":"You can either create a new Material with the shader or select the shader from the Material Inspector. To create a new Material with the shader: 1. In your Project window, click Create > Material . Select the Lit shader. To select the shader in the Material inspector: 1. In your Project, select the Material Inspector. 2. Click Shader , and select Lightweight Render Pipeline > Lit .","title":"Using the Lit shader in the Editor"},{"location":"LWRP/lit-shader/#ui-overview","text":"The Inspector window contains these elements: Surface Options Surface Inputs Advanced","title":"UI overview"},{"location":"LWRP/lit-shader/#surface-options","text":"The Surface Options control how Unity renders the Material on a screen. Property Description Workflow Mode In this drop-down menu, choose a workflow that fits your textures, either Metallic and Specular . When you have made your choice, the main Texture options in the rest of the Inspector now follow your chosen workflow. For information on metallic or specular workflows, see this Manual page for the Standard built-in shader in Unity . Surface Type In this drop-down menu, choose between an Opaque or Transparent surface type. If you select Transparent , a second drop-down menu appears (see Transparent property description below). Transparent surface type Alpha uses the alpha value to change how visible an object is. 1 is fully opaque, 0 is fully transparent. Premultiply applies a similar effect as Alpha , but only keeps reflections and highlights, even when your surface is transparent. This means that only the reflected light is visible. For example, imagine transparent glass. Additive adds an extra layer on top of another surface. This is good for holograms. Multiply multiplies the colors behind the surface, like colored glass. Two Sided Enable this to render on both sides of your geometry. When disabled, Unity culls the backface of your geometry and only renders the frontface. For example, Two Sided rendering is good for small, flat objects, like leaves, where you might want both sides visible. By default, this setting is disabled, so that Unity culls backfaces. Alpha Clip Enable this to make your Material act like a Cutout shader. With this, you can create a transparent effect with hard edges between the opaque and transparent areas. For example, to create straws of grass. Unity achieves this effect by not rendering Alpha values below the specified Clip Threshold , which appears when you enable Alpha Clip .","title":"Surface Options"},{"location":"LWRP/lit-shader/#surface-inputs","text":"The Surface Properties describe the surface itself. For example, you can use these properties to make your surface look wet, dry, rough, or smooth. Note: If you are used to the Standard Shader in the built-in Unity render pipeline, these options are similar to the Main Maps settings in the Material Editor . Property Description Albedo The albedo specifies the color of the surface. It is also known as the diffuse map. To assign a texture to the Albedo setting, click the object picker next to it. This opens the Asset Browser, where you can select from the textures on your Project. Alternatively, you can use the color picker . The color next to the setting shows the tint on top of your assigned texture. To assign another tint, you can click this color swatch. If you select Transparent or Alpha Clip under Render Properties , your Material uses the texture\u2019s alpha channel or color. Metallic / Specular Shows a map input for your chosen Workflow Mode in the Render Properties . For a Metallic map, a slider appears, and for a Specular map , a color input appears. For both map types, Smoothness controls the spread of highlights and/or reflections on the surface. Under Source , you can control where to sample a smoothness map from. By default, Source uses the Alpha channel for either map. You can also set it to the Albedo Alpha channel. Normal Map Assign a tangent-space normal map , similar to the one in the Standard Shader in the built-in render pipeline. To read more about tangent-space normal maps, see this article on Polycount . The float value next to the setting is a multiplier for the effect of the Normal Map . Occlusion Select an occlusion map to simulate shadowing of ambient light. Emission Make the surface emit light. When enabled, the Texture map and HDR color settings appear. If you do not enable this, emission will be considered as black, and Unity skips calculating emission. Tiling A 2D multiplier value that scales the texture to fit across a mesh according to the U and V axes. This is good for surfaces like floors and walls. The default value is 1, which means no scaling. Set a higher value to make the texture repeat across your mesh. Set a lower value to stretch the texture. Try different values until you reach your desired effect. Offset The 2D offset that positions the texture on the mesh. To adjust the map position on your mesh, move the texture across the U or V axes. Specular Highlights Enable this to allow your Material to have specular highlights from direct lighting, for example Directional, Point, and Spot lights . This means that your Material reflects the shine from these light sources. Disable this to leave out these highlight calculations, so your shader renders faster. By default, this feature is enabled. Reflections Sample reflections using the nearest Reflection Probe , or, if you have set one in the Lighting window, the Lighting Probe . Disabling sampling saves on calculations, but also means that your surface has no reflections.","title":"Surface Inputs"},{"location":"LWRP/lit-shader/#advanced","text":"The Rendering Options settings affect behind-the-scenes rendering. They do not have a visible effect on your surface, but on underlying calculations. Property Description GPU Instancing Make Unity render meshes with the same geometry and Material/shader in one batch, when possible. This makes rendering faster. Meshes cannot be rendered in one batch if they have different Materials or if the hardware does not support GPU instancing. Double Sided Global Illumination Make the surface act double-sided during lightmapping. When enabled, backfaces bounce light like frontfaces, but Unity still doesn\u2019t render them.","title":"Advanced"},{"location":"LWRP/lit-shader/#channel-packing","text":"This shader uses channel packing , so you can use a single RGBA texture for the metallic, smoothness and occlusion properties. When you use texture packing, you only have to load one texture into memory instead of three separate ones. When you write your texture maps in a program like Substance or Photoshop, you can pack the maps like this: Channel Property Red Metallic Green Occlusion Blue None Alpha Smoothness","title":"Channel packing"},{"location":"LWRP/lwrp-asset/","text":"Note: This page is subject to change during the 2019.1 beta cycle. Lightweight Render Pipeline Asset To use the Lightweight Render Pipeline (LWRP), you have to create a LWRP Asset and assign the asset in the Graphics settings . The LWRP Asset controls several graphical features and quality settings for the Lightweight Render Pipeline. It is a scriptable object that inherits from \u2018RenderPipelineAsset\u2019. When you assign the asset in the Graphics settings, Unity switches from the built-in render pipeline to the LWRP. You can then adjust the corresponding settings directly in the LWRP, instead of looking for them elsewhere. You can have multiple LWRP assets and switch between them. For example, you can have one with Shadows on and one with Shadows off. If you switch between the assets to see the effects, you don\u2019t have to manually toggle the corresponding settings for shadows every time. You cannot, however, switch between HDRP/SRP and LWRP assets, as the render pipelines are incompatible. UI overview In the LWRP, you can configure settings for: General Quality Lighting Shadows Advanced General The General settings control the core part of the pipeline rendered frame. Property Description Depth Texture Enable this to make the LWRP render a depth texture by default for all cameras in your Scene. If you want to use Post Processing, Soft Particles, or Shader effects that depend on Scene depth, you must enable this. When this is enabled, you can access the Depth Texture in your custom shaders and in shader code via the _CameraDepthTexture element. You can override this for individual cameras in the Camera Inspector. Opaque Texture Enable this to create a _CameraOpaqueTexture as default for all cameras in your Scene. This works like the GrabPass in the built-in render pipeline. The Opaque Texture provides a snapshot of the scene right before LWRP renders any transparent meshes. You can use this in transparent shaders to create effects like frosted glass, water refraction, or heat waves. You can override this for individual cameras in the Camera Inspector. Opaque Downsampling Set the sampling mode on the opaque texture to one of the following: None : Produces a copy of the opaque pass in the same resolution as the camera. 2x Bilinear : Produces a half-resolution image with bilinear filtering. 4x Box : Produces a quarter-resolution image with box filtering. This produces a softly blurred copy. 4x Bilinear : Produces a quarter-resolution image with bi-linear filtering. Quality These settings control the quality level of the LWRP. This is where you can make performance better on lower-end hardware or make graphics look better on higher-end hardware. Tip: If you want to have different settings for different hardware, you can configure these settings across multiple Lightweight Render Pipeline assets, and switch them out as needed. Property Description HDR Enable this to allow rendering in High Dynamic Range (HDR) by default for every camera in your Scene. With HDR, the brightest part of the image can be greater than 1. This gives you a wider range of light intensities, so your lighting looks more realistic. With it, you can still see details and experience less saturation even with bright light. This is useful if you want a wide range of lighting or to use bloom effects. If you\u2019re targeting lower-end hardware, you can disable this to skip HDR calculations and get better performance. You can override this for individual cameras in the Camera Inspector. MSAA Use Multi Sample Anti-aliasing by default for every Camera in your Scene while rendering. This softens edges of your geometry, so they\u2019re not jagged or flickering. In the drop-down menu, select how many samples to use per pixel: 2x , 4x , or 8x . The more samples you choose, the smoother your object edges are. If you want to skip MSAA calculations, or you don\u2019t need them in a 2D game, select Disabled . You can override this for individual cameras in the Camera Inspector. Render Scale This slider scales the render target resolution (not the resolution of your current device). Use this when you want to render at a smaller resolution for performance reasons or to upscale rendering to improve quality. This only scales the game rendering. UI rendering is left at the native resolution for the device. Lighting These settings affect the lights in your Scene. If you disable some of these settings, the relevant keywords are stripped from the shader variables . If there are certain settings that you know for certain you won\u2019t use in your game or app, you can disable them to improve performance and reduce build time. Property Description Main Light These settings affect the main Directional Light in your Scene. You can select this by assigning it as a Sun Source in the Lighting Inspector. If you don\u2019t assign a sun source, the LWRP treats the brightest directional light in the Scene as the main light. You can choose between Pixel Lighting and None . If you choose None, LWRP doesn\u2019t render a main light, even if you\u2019ve set a sun source. Cast Shadows Check this box to make the main light cast shadows in your Scene. Shadow Resolution This controls how large the shadow map texture for the main light is. High resolutions give sharper, more detailed shadows. If memory or rendering time is an issue, try a lower resolution. Additional Lights Here, you can choose to have additional lights to suppliment your main light. Choose between Vertex Lights , Pixel Lights , Both , or None . Per Object Limit This slider sets the limit for how many additional lights can affect each GameObject. Cast Shadows Check this box to make the additional lights cast shadows in your Scene. Shadow Resolution This controls the size of the textures that cast directional shadows for the additional lights. This is a sprite atlas that packs up to 16 shadow maps. High resolutions give sharper, more detailed shadows. If memory or rendering time is an issue, try a lower resolution. Shadows These settings affect how shadows look and behave. They also impact performance, so this is where you can make tweaks to get the best balance between visual quality and shadow rendering speed. Property Description Distance This controls how far ahead of the camera objects cast shadows, in Unity units. After this distance, LWRP doesn\u2019t render shadows. For example, the value 100 means that objects more than 100 meters away from the camera do not cast shadows. Use this in large, open worlds, where rendering shadows far away can consume lots of memory. Or use it in top-down games with limited view distance. Cascades Select the number of cascades for shadows. A high number of cascades gives you more detailed shadows nearer the camera.The options are: None , Two Cascades and Four Cascades . If you\u2019re experiencing performance issues, try lowering the amount of cascades. You can also configure the distance for shadows in the section below the setting. Further away from the camera, shadows become less detailed. Soft Shadows If you have enabled shadows for either Main Light or Additionanal Light , you can enable this to add a smoother filtering on the shadow maps. This gives you smooth edges on shadows. When enabled, the render pipeline performs a 5x5 Tent filter on desktop platforms and a 4 Tap filter on mobile devices. When disabled, the render pipeline samples the shadow once with default hardware filtering. If you disable this feature, you\u2019ll get faster rendering, but sharper, possibly pixelated, shadow edges. Advanced This section allows you to fine tune less commonly changed settings, which impact deeper rendering features and shader combinations. Property Description Dynamic Batching Enable Dynamic Batching , to make the render pipeline automatically batch small dynamic objects that share the same Material. This is useful for platforms and graphics APIs that do not support GPU instancing. If your targeted hardware does support GPU instancing, disable Dynamic Batching . You can change this at run time.","title":"Lwrp asset"},{"location":"LWRP/lwrp-asset/#lightweight-render-pipeline-asset","text":"To use the Lightweight Render Pipeline (LWRP), you have to create a LWRP Asset and assign the asset in the Graphics settings . The LWRP Asset controls several graphical features and quality settings for the Lightweight Render Pipeline. It is a scriptable object that inherits from \u2018RenderPipelineAsset\u2019. When you assign the asset in the Graphics settings, Unity switches from the built-in render pipeline to the LWRP. You can then adjust the corresponding settings directly in the LWRP, instead of looking for them elsewhere. You can have multiple LWRP assets and switch between them. For example, you can have one with Shadows on and one with Shadows off. If you switch between the assets to see the effects, you don\u2019t have to manually toggle the corresponding settings for shadows every time. You cannot, however, switch between HDRP/SRP and LWRP assets, as the render pipelines are incompatible.","title":"Lightweight Render Pipeline Asset"},{"location":"LWRP/lwrp-asset/#ui-overview","text":"In the LWRP, you can configure settings for: General Quality Lighting Shadows Advanced","title":"UI overview"},{"location":"LWRP/lwrp-asset/#general","text":"The General settings control the core part of the pipeline rendered frame. Property Description Depth Texture Enable this to make the LWRP render a depth texture by default for all cameras in your Scene. If you want to use Post Processing, Soft Particles, or Shader effects that depend on Scene depth, you must enable this. When this is enabled, you can access the Depth Texture in your custom shaders and in shader code via the _CameraDepthTexture element. You can override this for individual cameras in the Camera Inspector. Opaque Texture Enable this to create a _CameraOpaqueTexture as default for all cameras in your Scene. This works like the GrabPass in the built-in render pipeline. The Opaque Texture provides a snapshot of the scene right before LWRP renders any transparent meshes. You can use this in transparent shaders to create effects like frosted glass, water refraction, or heat waves. You can override this for individual cameras in the Camera Inspector. Opaque Downsampling Set the sampling mode on the opaque texture to one of the following: None : Produces a copy of the opaque pass in the same resolution as the camera. 2x Bilinear : Produces a half-resolution image with bilinear filtering. 4x Box : Produces a quarter-resolution image with box filtering. This produces a softly blurred copy. 4x Bilinear : Produces a quarter-resolution image with bi-linear filtering.","title":"General"},{"location":"LWRP/lwrp-asset/#quality","text":"These settings control the quality level of the LWRP. This is where you can make performance better on lower-end hardware or make graphics look better on higher-end hardware. Tip: If you want to have different settings for different hardware, you can configure these settings across multiple Lightweight Render Pipeline assets, and switch them out as needed. Property Description HDR Enable this to allow rendering in High Dynamic Range (HDR) by default for every camera in your Scene. With HDR, the brightest part of the image can be greater than 1. This gives you a wider range of light intensities, so your lighting looks more realistic. With it, you can still see details and experience less saturation even with bright light. This is useful if you want a wide range of lighting or to use bloom effects. If you\u2019re targeting lower-end hardware, you can disable this to skip HDR calculations and get better performance. You can override this for individual cameras in the Camera Inspector. MSAA Use Multi Sample Anti-aliasing by default for every Camera in your Scene while rendering. This softens edges of your geometry, so they\u2019re not jagged or flickering. In the drop-down menu, select how many samples to use per pixel: 2x , 4x , or 8x . The more samples you choose, the smoother your object edges are. If you want to skip MSAA calculations, or you don\u2019t need them in a 2D game, select Disabled . You can override this for individual cameras in the Camera Inspector. Render Scale This slider scales the render target resolution (not the resolution of your current device). Use this when you want to render at a smaller resolution for performance reasons or to upscale rendering to improve quality. This only scales the game rendering. UI rendering is left at the native resolution for the device.","title":"Quality"},{"location":"LWRP/lwrp-asset/#lighting","text":"These settings affect the lights in your Scene. If you disable some of these settings, the relevant keywords are stripped from the shader variables . If there are certain settings that you know for certain you won\u2019t use in your game or app, you can disable them to improve performance and reduce build time. Property Description Main Light These settings affect the main Directional Light in your Scene. You can select this by assigning it as a Sun Source in the Lighting Inspector. If you don\u2019t assign a sun source, the LWRP treats the brightest directional light in the Scene as the main light. You can choose between Pixel Lighting and None . If you choose None, LWRP doesn\u2019t render a main light, even if you\u2019ve set a sun source. Cast Shadows Check this box to make the main light cast shadows in your Scene. Shadow Resolution This controls how large the shadow map texture for the main light is. High resolutions give sharper, more detailed shadows. If memory or rendering time is an issue, try a lower resolution. Additional Lights Here, you can choose to have additional lights to suppliment your main light. Choose between Vertex Lights , Pixel Lights , Both , or None . Per Object Limit This slider sets the limit for how many additional lights can affect each GameObject. Cast Shadows Check this box to make the additional lights cast shadows in your Scene. Shadow Resolution This controls the size of the textures that cast directional shadows for the additional lights. This is a sprite atlas that packs up to 16 shadow maps. High resolutions give sharper, more detailed shadows. If memory or rendering time is an issue, try a lower resolution.","title":"Lighting"},{"location":"LWRP/lwrp-asset/#shadows","text":"These settings affect how shadows look and behave. They also impact performance, so this is where you can make tweaks to get the best balance between visual quality and shadow rendering speed. Property Description Distance This controls how far ahead of the camera objects cast shadows, in Unity units. After this distance, LWRP doesn\u2019t render shadows. For example, the value 100 means that objects more than 100 meters away from the camera do not cast shadows. Use this in large, open worlds, where rendering shadows far away can consume lots of memory. Or use it in top-down games with limited view distance. Cascades Select the number of cascades for shadows. A high number of cascades gives you more detailed shadows nearer the camera.The options are: None , Two Cascades and Four Cascades . If you\u2019re experiencing performance issues, try lowering the amount of cascades. You can also configure the distance for shadows in the section below the setting. Further away from the camera, shadows become less detailed. Soft Shadows If you have enabled shadows for either Main Light or Additionanal Light , you can enable this to add a smoother filtering on the shadow maps. This gives you smooth edges on shadows. When enabled, the render pipeline performs a 5x5 Tent filter on desktop platforms and a 4 Tap filter on mobile devices. When disabled, the render pipeline samples the shadow once with default hardware filtering. If you disable this feature, you\u2019ll get faster rendering, but sharper, possibly pixelated, shadow edges.","title":"Shadows"},{"location":"LWRP/lwrp-asset/#advanced","text":"This section allows you to fine tune less commonly changed settings, which impact deeper rendering features and shader combinations. Property Description Dynamic Batching Enable Dynamic Batching , to make the render pipeline automatically batch small dynamic objects that share the same Material. This is useful for platforms and graphics APIs that do not support GPU instancing. If your targeted hardware does support GPU instancing, disable Dynamic Batching . You can change this at run time.","title":"Advanced"},{"location":"LWRP/lwrp-builtin-feature-comparison/","text":"Note: This page is subject to change during the 2019.1 beta cycle. Feature comparison This is an overview of how features work in the Unity built-in Render Pipeline and in the Lightweight Render Pipeline. Unity Built-in render pipeline Lightweight Render Pipeline Platform Coverage All All Rendering Paths Multi-pass Forward Multi-pass Deferred Single-pass Forward Lighting Attenuation Separate precomputed attenuation textures for Point and Spot Vertex light attenuation does not reach 0 intensity at range boundary. Physically Based Light Attenuation. Light intensity decreases by the inverse-square law. Color Space Linear with sRGB light intensity sRGB Linear with linear light intensity sRGB. Realtime Lights Directional, Spot and Point Amount of pixel lights controlled by Quality Settings Forward path limited to 8 pixel lights. Supports up to 4 vertex point lights. Directional, Spot and Point Amount of pixel lights controlled by LWRP Asset 1 Main Directional light, always shaded per pixel Up to 8 additional lights that can be shaded per pixel or per vertex Light Modes Baked Mixed - Baked Indirect - Shadow Mask - Distance Shadowmask - Subtractive Realtime Baked Mixed (WIP / ETA Unity 19.1) - Baked Indirect - Shadow Mask - Subtractive Realtime Global Illumination Directional, Spot, Point and Rectangular Area Lights Baked Lightmap (Non-Directional and Directional) Light Probes Realtime Dynamic Lightmap Realtime Lightprobes Directional, Spot, Point and Rectangular Area Lights Baked Lightmap (Non-Directional and Directional) Light Probes Realtime GI Not Supported. Light Culling Per-Object. No Compute. Per-Object. No Compute. Shader Library Dozens of non physically based shaders specializations Unified Standard PBS Shaders Metallic workflow Specular workflow Roughness workflow Unified non-physically based shader (Simple Lit) Unified physically based shader (Lit) that covers Metallic and Specular workflows Physically Based Shading Disney Diffuse + Cook Torrance (GGX, Smith, Schlick) Specular Lambertian Diffuse + Simplified Cook Torrance (GGX, Simplified KSK and Schlick) Specular Lambertian Diffuse + Non-Microfaceted LUT Specular Lambertian Diffuse + Simplified Cook Torrance (GGX, Simplified KSK and Schlick) Specular Light Cookies Monochrome Single light cookie support for the main light. Light Probes Modes One interpolated probe LPPV One interpolated probe Reflection Probes Sorted per-object Blend between at most 2 probes Sorted per-object No blending Shadows Features PSSM Stable and Close Fit\u00b7 Filtering: PCF No depth clip. Pancaking done in vertex. PSSM Stable Fit Filtering: PCF No depth clip. Pancaking done in vertex. Shadow Modes Light Space Screen Space Light Space Screen Space Shadow Casting Lights Directional, Spot, Point Multiple shadow light casters, one per pass. Directional and Spot Single shadow light caster supported as main light. General Camera Sorts camera by depth value Stack Management Groups by common camera state Handles depth state between cameras Sorts camera by depth value No stack management RenderTarget scale supported Game renders at scaled resolution UI renders at native resolution Anti-Aliasing MSAA TAA MSAA Pipeline Additional Data Motion Vectors None Post-Processing Legacy Post-Processing stack New Post-Processing Stack Subset of the new Post-Processing Stack FX No support for: - TAA - Motion Blur - SSR Debug option Display GBuffer Display various bake lighting view mode Sky lighting Procedural Sky Cubemap/LatLong Sky Ambient Lighting Procedural Sky Cubemap Ambient Lighting","title":"Lwrp builtin feature comparison"},{"location":"LWRP/lwrp-builtin-feature-comparison/#feature-comparison","text":"This is an overview of how features work in the Unity built-in Render Pipeline and in the Lightweight Render Pipeline. Unity Built-in render pipeline Lightweight Render Pipeline Platform Coverage All All Rendering Paths Multi-pass Forward Multi-pass Deferred Single-pass Forward Lighting Attenuation Separate precomputed attenuation textures for Point and Spot Vertex light attenuation does not reach 0 intensity at range boundary. Physically Based Light Attenuation. Light intensity decreases by the inverse-square law. Color Space Linear with sRGB light intensity sRGB Linear with linear light intensity sRGB. Realtime Lights Directional, Spot and Point Amount of pixel lights controlled by Quality Settings Forward path limited to 8 pixel lights. Supports up to 4 vertex point lights. Directional, Spot and Point Amount of pixel lights controlled by LWRP Asset 1 Main Directional light, always shaded per pixel Up to 8 additional lights that can be shaded per pixel or per vertex Light Modes Baked Mixed - Baked Indirect - Shadow Mask - Distance Shadowmask - Subtractive Realtime Baked Mixed (WIP / ETA Unity 19.1) - Baked Indirect - Shadow Mask - Subtractive Realtime Global Illumination Directional, Spot, Point and Rectangular Area Lights Baked Lightmap (Non-Directional and Directional) Light Probes Realtime Dynamic Lightmap Realtime Lightprobes Directional, Spot, Point and Rectangular Area Lights Baked Lightmap (Non-Directional and Directional) Light Probes Realtime GI Not Supported. Light Culling Per-Object. No Compute. Per-Object. No Compute. Shader Library Dozens of non physically based shaders specializations Unified Standard PBS Shaders Metallic workflow Specular workflow Roughness workflow Unified non-physically based shader (Simple Lit) Unified physically based shader (Lit) that covers Metallic and Specular workflows Physically Based Shading Disney Diffuse + Cook Torrance (GGX, Smith, Schlick) Specular Lambertian Diffuse + Simplified Cook Torrance (GGX, Simplified KSK and Schlick) Specular Lambertian Diffuse + Non-Microfaceted LUT Specular Lambertian Diffuse + Simplified Cook Torrance (GGX, Simplified KSK and Schlick) Specular Light Cookies Monochrome Single light cookie support for the main light. Light Probes Modes One interpolated probe LPPV One interpolated probe Reflection Probes Sorted per-object Blend between at most 2 probes Sorted per-object No blending Shadows Features PSSM Stable and Close Fit\u00b7 Filtering: PCF No depth clip. Pancaking done in vertex. PSSM Stable Fit Filtering: PCF No depth clip. Pancaking done in vertex. Shadow Modes Light Space Screen Space Light Space Screen Space Shadow Casting Lights Directional, Spot, Point Multiple shadow light casters, one per pass. Directional and Spot Single shadow light caster supported as main light. General Camera Sorts camera by depth value Stack Management Groups by common camera state Handles depth state between cameras Sorts camera by depth value No stack management RenderTarget scale supported Game renders at scaled resolution UI renders at native resolution Anti-Aliasing MSAA TAA MSAA Pipeline Additional Data Motion Vectors None Post-Processing Legacy Post-Processing stack New Post-Processing Stack Subset of the new Post-Processing Stack FX No support for: - TAA - Motion Blur - SSR Debug option Display GBuffer Display various bake lighting view mode Sky lighting Procedural Sky Cubemap/LatLong Sky Ambient Lighting Procedural Sky Cubemap Ambient Lighting","title":"Feature comparison"},{"location":"LWRP/lwrp-internal-flowchart/","text":"Important: This page is still a work in progress. To read our most current documentation, open the TableOfContents.md file to see the linked pages.","title":"Lwrp internal flowchart"},{"location":"LWRP/particles-lit-shader/","text":"Important: This page is still a work in progress. To read our most current documentation, open the TableOfContents.md file to see the linked pages.","title":"Particles lit shader"},{"location":"LWRP/particles-simple-lit-shader/","text":"Important: This page is still a work in progress. To read our most current documentation, open the TableOfContents.md file to see the linked pages.","title":"Particles simple lit shader"},{"location":"LWRP/particles-unlit-shader/","text":"Important: This page is still a work in progress. To read our most current documentation, open the TableOfContents.md file to see the linked pages.","title":"Particles unlit shader"},{"location":"LWRP/realtime-lighting-in-lwrp/","text":"Important: This page is still a work in progress. To read our most current documentation, open the TableOfContents.md file to see the linked pages.","title":"Realtime lighting in lwrp"},{"location":"LWRP/rendering-in-lwrp/","text":"Important: This page is still a work in progress. To read our most current documentation, open the TableOfContents.md file to see the linked pages.","title":"Rendering in lwrp"},{"location":"LWRP/shader-stripping-keywords/","text":"Important: This page is still a work in progress. To read our most current documentation, open the TableOfContents.md file to see the linked pages.","title":"Shader stripping keywords"},{"location":"LWRP/shader-stripping/","text":"Note: This page is subject to change during the 2019.1 beta cycle. Shader Stripping Unity compiles many shader variants from a single shader source file. The number of shader variants depends on how many keywords you\u2019ve included in the shader. In the default shaders, the Lightweight Render Pipeline uses a set of keywords for lighting and shadows. LWRP can exclude some shader variants, depending on which features are active in the LWRP Asset . When you disable certain features in the LWRP Asset, the pipeline \u201cstrips\u201d the related shader variants from the build. Stripping your shaders gives you smaller build sizes and shorter build times. This is useful if your project is never going to use certain features or keywords. For example, you might have a project where you never use shadows for directional lights. Without shader stripping, shader variants with directional shadow support remain in the build. In that case, you can uncheck Cast Shadows in the LWRP Asset for either main or additional direction lights. LWRP then strips these variants from the build. For more information about stripping shader variants in Unity, see this blog post by Christophe Riccio .","title":"Shader stripping"},{"location":"LWRP/shader-stripping/#shader-stripping","text":"Unity compiles many shader variants from a single shader source file. The number of shader variants depends on how many keywords you\u2019ve included in the shader. In the default shaders, the Lightweight Render Pipeline uses a set of keywords for lighting and shadows. LWRP can exclude some shader variants, depending on which features are active in the LWRP Asset . When you disable certain features in the LWRP Asset, the pipeline \u201cstrips\u201d the related shader variants from the build. Stripping your shaders gives you smaller build sizes and shorter build times. This is useful if your project is never going to use certain features or keywords. For example, you might have a project where you never use shadows for directional lights. Without shader stripping, shader variants with directional shadow support remain in the build. In that case, you can uncheck Cast Shadows in the LWRP Asset for either main or additional direction lights. LWRP then strips these variants from the build. For more information about stripping shader variants in Unity, see this blog post by Christophe Riccio .","title":"Shader Stripping"},{"location":"LWRP/shaders-in-lwrp/","text":"Note: This page is subject to change during the 2019.1 beta cycle. Shaders in LWRP Note: While LWRP is in preview, this documentation might not reflect the end-result 100%, and is therefore subject to change. The Lightweight Render Pipeline uses a different shading approach than the Unity built-in Render Pipeline. As a result, built-in Lit and custom Lit shaders do not work with the LWRP. Instead, LWRP has a new set of standard shaders. LWRP provides the following shaders for the most common use case scenarios: Lit Simple Lit Baked Lit Unlit Particles Lit Particles Simple Lit Particles Unlit Autodesk Interactive Autodesk Interactive Transparent Autodesk Interactive Masked Upgrade advice: If you upgrade your current Project to LWRP, you can upgrade built-in shaders to the new ones. Unlit shaders from the built-in render pipeline still work with LWRP. Note: Unlit shaders from the Unity built-in render pipeline work in LWRP. Choosing a shader With the Lightweight Render Pipeline, you can have real-time lighting wither either Physically Based Shaders (PBS) and non-PBR rendering. For PBS, use the [[Lit shader | lit_shader#lit_shader]]. You can use it on all platforms. The shader quality scales, depending on the platform, but keeps physically based rendering on all platforms. This gives you realistic graphics across hardware. The Unity Standard Shader and the Standard (Specular setup) shaders both map to the Lit shader in LWRP. For a list of shader mappings, see shader mappings If you\u2019re targeting less powerful devices, or just would like simpler shading, use the [[Simple lit shader | simple_lit_shader#simple_lit_shader]], which is non-PBR. If you don\u2019t need real-time lighting, or would rather only use baked lighting and sample global illumination, choose a Baked Lit shader. If you don\u2019t need lighting in on a material at all, you can choose the an Unlit shader.","title":"Shaders in lwrp"},{"location":"LWRP/shaders-in-lwrp/#shaders-in-lwrp","text":"Note: While LWRP is in preview, this documentation might not reflect the end-result 100%, and is therefore subject to change. The Lightweight Render Pipeline uses a different shading approach than the Unity built-in Render Pipeline. As a result, built-in Lit and custom Lit shaders do not work with the LWRP. Instead, LWRP has a new set of standard shaders. LWRP provides the following shaders for the most common use case scenarios: Lit Simple Lit Baked Lit Unlit Particles Lit Particles Simple Lit Particles Unlit Autodesk Interactive Autodesk Interactive Transparent Autodesk Interactive Masked Upgrade advice: If you upgrade your current Project to LWRP, you can upgrade built-in shaders to the new ones. Unlit shaders from the built-in render pipeline still work with LWRP. Note: Unlit shaders from the Unity built-in render pipeline work in LWRP.","title":"Shaders in LWRP"},{"location":"LWRP/shaders-in-lwrp/#choosing-a-shader","text":"With the Lightweight Render Pipeline, you can have real-time lighting wither either Physically Based Shaders (PBS) and non-PBR rendering. For PBS, use the [[Lit shader | lit_shader#lit_shader]]. You can use it on all platforms. The shader quality scales, depending on the platform, but keeps physically based rendering on all platforms. This gives you realistic graphics across hardware. The Unity Standard Shader and the Standard (Specular setup) shaders both map to the Lit shader in LWRP. For a list of shader mappings, see shader mappings If you\u2019re targeting less powerful devices, or just would like simpler shading, use the [[Simple lit shader | simple_lit_shader#simple_lit_shader]], which is non-PBR. If you don\u2019t need real-time lighting, or would rather only use baked lighting and sample global illumination, choose a Baked Lit shader. If you don\u2019t need lighting in on a material at all, you can choose the an Unlit shader.","title":"Choosing a shader"},{"location":"LWRP/shading-model/","text":"Note: This page is subject to change during the 2019.1 beta cycle. Shading Models in LWRP A shading model defines how the object\u2019s color varies depending on factors such as surface orientation, viewer direction, and lighting. Your choice of a shading model depends on the artistic direction and performance budget of your application. The Lightweight Render Pipeline provides shaders with the following shading models: Physically Based Shading Simple Shading Baked Lit Shading Physically based shading Physically based shading (PBS) simulates how objects look in real life by computing the amount of light reflected from the surface based on principles of physics. This lets your create photo-realistic objects and surfaces. This PBS model follows two principles: energy conservation , and microgeometry . Energy conservation means that the surface never reflects more light than the total incoming light. The only exception to this is when an object emits light. For example, think of a neon sign. At a microscopic level, surfaces have microgeometry . Some objects have smooth microgeometry, which gives them a mirror-like appearance. Other objects have rough microgeometry, which makes them look more dull. In LWRP, you can can mimic the level of smoothness of an object\u2019s surface. [img showing comparison between roughness vs smoothness] When light hits an object surface, part of the light is reflected and part is refracted. The reflected light is called specular reflection . This varies depending on the viewer direction and the at which the light hits a surgace, also called the angle of incidence . In this shading model, the shape of specular highlight is approximated with a GGX function . For metal objects, the surface absorbs and changes the light. For non-metallic objects, also called dialetic objects, the surface reflects parts of the light. [img showing metal vs non-metal and their diffuse + specular reflection] These LWRP shaders use Physically Based Shading: Lit TerrainLit ParticlesLit Note: This shading model is not suitable for low-end mobile hardware. If you\u2019re targeting this hardware, use shaders with a Simple Shading model. To read more about Physically Based Rendering, see this walkthrough by Joe Wilson on Marmoset . Simple shading This shading model is suitable for stylized games or for games that run on less powerful platforms. With this shading model, objects do not appear truly photorealistic. The shaders are not energy-conserving. This shading model is based on Blinn-Phong model. In this model, objects reflect diffuse and specular light and there\u2019s no correlation between these two. The amount of diffuse and specular light reflected depends on properties selected in the material and the total reflected light can therefore exceed the total incoming light. Specular reflection varies only with viewer direction only. [img showing diffuse and specular reflection] These LWRP shaders use Simple Shading: Simple Lit Particles Simple Lit Baked Lit shading The Baked Lit shading model doesn\u2019t have real-time lighting. Objects can receive baked lighting from either Lightmaps or Light Probes . This adds some depth to your Scenes at a small performance cost. Games with this shading model can run on less powerful platforms. [img showing unlit objects] These LWRP shaders use Baked Lit shading: Baked Lit Particles Baked Lit","title":"Shading model"},{"location":"LWRP/shading-model/#shading-models-in-lwrp","text":"A shading model defines how the object\u2019s color varies depending on factors such as surface orientation, viewer direction, and lighting. Your choice of a shading model depends on the artistic direction and performance budget of your application. The Lightweight Render Pipeline provides shaders with the following shading models: Physically Based Shading Simple Shading Baked Lit Shading","title":"Shading Models in LWRP"},{"location":"LWRP/shading-model/#physically-based-shading","text":"Physically based shading (PBS) simulates how objects look in real life by computing the amount of light reflected from the surface based on principles of physics. This lets your create photo-realistic objects and surfaces. This PBS model follows two principles: energy conservation , and microgeometry . Energy conservation means that the surface never reflects more light than the total incoming light. The only exception to this is when an object emits light. For example, think of a neon sign. At a microscopic level, surfaces have microgeometry . Some objects have smooth microgeometry, which gives them a mirror-like appearance. Other objects have rough microgeometry, which makes them look more dull. In LWRP, you can can mimic the level of smoothness of an object\u2019s surface. [img showing comparison between roughness vs smoothness] When light hits an object surface, part of the light is reflected and part is refracted. The reflected light is called specular reflection . This varies depending on the viewer direction and the at which the light hits a surgace, also called the angle of incidence . In this shading model, the shape of specular highlight is approximated with a GGX function . For metal objects, the surface absorbs and changes the light. For non-metallic objects, also called dialetic objects, the surface reflects parts of the light. [img showing metal vs non-metal and their diffuse + specular reflection] These LWRP shaders use Physically Based Shading: Lit TerrainLit ParticlesLit Note: This shading model is not suitable for low-end mobile hardware. If you\u2019re targeting this hardware, use shaders with a Simple Shading model. To read more about Physically Based Rendering, see this walkthrough by Joe Wilson on Marmoset .","title":"Physically based shading"},{"location":"LWRP/shading-model/#simple-shading","text":"This shading model is suitable for stylized games or for games that run on less powerful platforms. With this shading model, objects do not appear truly photorealistic. The shaders are not energy-conserving. This shading model is based on Blinn-Phong model. In this model, objects reflect diffuse and specular light and there\u2019s no correlation between these two. The amount of diffuse and specular light reflected depends on properties selected in the material and the total reflected light can therefore exceed the total incoming light. Specular reflection varies only with viewer direction only. [img showing diffuse and specular reflection] These LWRP shaders use Simple Shading: Simple Lit Particles Simple Lit","title":"Simple shading"},{"location":"LWRP/shading-model/#baked-lit-shading","text":"The Baked Lit shading model doesn\u2019t have real-time lighting. Objects can receive baked lighting from either Lightmaps or Light Probes . This adds some depth to your Scenes at a small performance cost. Games with this shading model can run on less powerful platforms. [img showing unlit objects] These LWRP shaders use Baked Lit shading: Baked Lit Particles Baked Lit","title":"Baked Lit shading"},{"location":"LWRP/simple-lit-shader/","text":"Note: This page is subject to change during the 2019.1 beta cycle. Simple Lit shader The Simple Lit shader is perfect for when performance is more important than photorealism. This shader uses a simple approximation for lighting. Because this shader does not calculate for physical correctness and energy conservation , it renders quickly. Using the Simple Lit shader in the Editor You can either create a new Material with the shader or select the shader from the Material inspector. To create a new Material with the shader: 1. In your Project window, click Create > Material . Select the Simple Lit shader. To select the shader in the Material inspector: 1. In your Project, select the Material Inspector. 2. Click Shader , and select Lightweight Render Pipeline > Simple Lit . UI overview The Inspector window contains these elements: Surface Options Surface Inputs Advanced Surface Options The Surface Options control how the Material is rendered on a screen. Property Description Surface Type In this drop-down menu, choose between an Opaque or Transparent surface type. Opaque surface types are fully visible, without any considerations of what\u2019s behind them. Transparent surface types take their background into account, and they can vary according to which type of transparent surface type, you choose. If you select Transparent , a second dropdown appears (see Transparent property description below). Transparent surface type Alpha uses the alpha value to change how visible an object is. 1 is fully opaque, 0 is fully transparent. Premultiply applies a similar effect as Alpha , but only keeps reflections and highlights, even when your surface is transparent. This means that only the reflected light is visible. For example, imagine transparent glass. Additive adds an extra layer on top of another surface. This is good for holograms. Multiply multiplies the colors behind the surface, like colored glass. Two Sided Enable this to render on both sides of your geometry. When disabled, Unity culls the backface of your geometry and only renders the frontface. For example, Two Sided rendering is good for small, flat objects, like leaves, where you might want both sides visible. By default, this setting is disabled, so that Unity culls backfaces. Alpha Clip Enable this to make your Material act like a Cutout shader. With this, you can create a transparent effect with hard edges between the opaque and transparent areas. For example, to create straws of grass. Unity achieves this effect by not rendering Alpha values below the specified Clip Threshold , which appears when you enable Alpha Clip . Surface Inputs The Surface Inputs describe the surface itself. For example, you can use these properties to make your surface look wet, dry, rough, or smooth. Property Description Base This is the texture of the surface, also known as the diffuse map. To assign a texture to the Base setting, click the object picker next to it. This opens the Asset Browser, where you can select from the textures on your Project. Alternatively, you can use the color picker . The color next to the setting shows the tint on top of your assigned texture. To assign another tint, you can click this color swatch. If you select Transparent or Alpha Clip under Render Properties , your Material uses the texture\u2019s alpha channel or color. Specular Enable this to allow your Material to have specular highlights from direct lighting, for example Directional, Point, and Spot lights . This means that your Material reflects the shine from these light sources. Disable this to leave out these highlight calculations, so your shader renders faster. By default, this feature is enabled. When Specular is enabled, you can configure the following properties: Specular Map , Glossiness Source , and Shininess . Specular Map controls the color of your specular highlights. In__Glossiness Source__, you can select a texture in your Project. The Alpha channel for this texture controls the glossiness. The Shininess slider controls the spread of highlights on the surface . 0 gives a wide, rough highlight. 1 gives a small, sharp highlight like glass. Values in between produce semi-glossy looks. For example, 0.5 produces a plastic-like glossiness. Normal Map Assign a tangent-space normal map , similar to the one in the Standard Shader in the built-in render pipeline. To read more about tangent-space normal maps, see this article on Polycount . The float value next to the setting is a multiplier for the effect of the Normal Map . Emission Make the surface look like it emit lights. When enabled, the Color and HDR settings appear. To assign a texture to your Color , click the object picture next to it. This opens the Asset Browser, where you can select from the textures in your Project. For HDR , you can choose the color picker](https://docs.unity3d.com/Manual/EditingValueProperties.html) to assign a HDR tint on top of the color. This can be more than 100% white, which is useful for effects like lava, that shines brighter than white while still being another color. If you have not assigned a Color texture, the Emission setting uses the tint you\u2019ve assigned in HDR. If you do not enable Emission , Unity sets the emission to black and does not calculate emission. Tiling A 2D multiplier value that scales the texture to fit across a mesh according to the U and V axes. This is good for surfaces like floors and walls. The default value is 1, which means no scaling. Set a higher value to make the texture repeat across your mesh. Set a lower value to stretch the texture. Try different values until you reach your desired effect. Offset The 2D offset that positions the texture on the mesh. To adjust the map position on your mesh, move the texture across the U or V axes. Advanced The Advanced settings affect behind-the-Scenes rendering. They do not have a visible effect on your surface, but on underlying calculations. Property Description GPU Instancing Make Unity render meshes with the same geometry and Material/shader in one batch, when possible. This makes rendering faster. Meshes cannot be rendered in one batch if they have different Materials or if the hardware does not support GPU instancing. Double-sided Global Illumination Make the surface act double-sided du ring lightmapping. When enabled, backfaces bounce light like frontfaces, but Unity still doesn\u2019t render them.","title":"Simple lit shader"},{"location":"LWRP/simple-lit-shader/#simple-lit-shader","text":"The Simple Lit shader is perfect for when performance is more important than photorealism. This shader uses a simple approximation for lighting. Because this shader does not calculate for physical correctness and energy conservation , it renders quickly.","title":"Simple Lit shader"},{"location":"LWRP/simple-lit-shader/#using-the-simple-lit-shader-in-the-editor","text":"You can either create a new Material with the shader or select the shader from the Material inspector. To create a new Material with the shader: 1. In your Project window, click Create > Material . Select the Simple Lit shader. To select the shader in the Material inspector: 1. In your Project, select the Material Inspector. 2. Click Shader , and select Lightweight Render Pipeline > Simple Lit .","title":"Using the Simple Lit shader in the Editor"},{"location":"LWRP/simple-lit-shader/#ui-overview","text":"The Inspector window contains these elements: Surface Options Surface Inputs Advanced","title":"UI overview"},{"location":"LWRP/simple-lit-shader/#surface-options","text":"The Surface Options control how the Material is rendered on a screen. Property Description Surface Type In this drop-down menu, choose between an Opaque or Transparent surface type. Opaque surface types are fully visible, without any considerations of what\u2019s behind them. Transparent surface types take their background into account, and they can vary according to which type of transparent surface type, you choose. If you select Transparent , a second dropdown appears (see Transparent property description below). Transparent surface type Alpha uses the alpha value to change how visible an object is. 1 is fully opaque, 0 is fully transparent. Premultiply applies a similar effect as Alpha , but only keeps reflections and highlights, even when your surface is transparent. This means that only the reflected light is visible. For example, imagine transparent glass. Additive adds an extra layer on top of another surface. This is good for holograms. Multiply multiplies the colors behind the surface, like colored glass. Two Sided Enable this to render on both sides of your geometry. When disabled, Unity culls the backface of your geometry and only renders the frontface. For example, Two Sided rendering is good for small, flat objects, like leaves, where you might want both sides visible. By default, this setting is disabled, so that Unity culls backfaces. Alpha Clip Enable this to make your Material act like a Cutout shader. With this, you can create a transparent effect with hard edges between the opaque and transparent areas. For example, to create straws of grass. Unity achieves this effect by not rendering Alpha values below the specified Clip Threshold , which appears when you enable Alpha Clip .","title":"Surface Options"},{"location":"LWRP/simple-lit-shader/#surface-inputs","text":"The Surface Inputs describe the surface itself. For example, you can use these properties to make your surface look wet, dry, rough, or smooth. Property Description Base This is the texture of the surface, also known as the diffuse map. To assign a texture to the Base setting, click the object picker next to it. This opens the Asset Browser, where you can select from the textures on your Project. Alternatively, you can use the color picker . The color next to the setting shows the tint on top of your assigned texture. To assign another tint, you can click this color swatch. If you select Transparent or Alpha Clip under Render Properties , your Material uses the texture\u2019s alpha channel or color. Specular Enable this to allow your Material to have specular highlights from direct lighting, for example Directional, Point, and Spot lights . This means that your Material reflects the shine from these light sources. Disable this to leave out these highlight calculations, so your shader renders faster. By default, this feature is enabled. When Specular is enabled, you can configure the following properties: Specular Map , Glossiness Source , and Shininess . Specular Map controls the color of your specular highlights. In__Glossiness Source__, you can select a texture in your Project. The Alpha channel for this texture controls the glossiness. The Shininess slider controls the spread of highlights on the surface . 0 gives a wide, rough highlight. 1 gives a small, sharp highlight like glass. Values in between produce semi-glossy looks. For example, 0.5 produces a plastic-like glossiness. Normal Map Assign a tangent-space normal map , similar to the one in the Standard Shader in the built-in render pipeline. To read more about tangent-space normal maps, see this article on Polycount . The float value next to the setting is a multiplier for the effect of the Normal Map . Emission Make the surface look like it emit lights. When enabled, the Color and HDR settings appear. To assign a texture to your Color , click the object picture next to it. This opens the Asset Browser, where you can select from the textures in your Project. For HDR , you can choose the color picker](https://docs.unity3d.com/Manual/EditingValueProperties.html) to assign a HDR tint on top of the color. This can be more than 100% white, which is useful for effects like lava, that shines brighter than white while still being another color. If you have not assigned a Color texture, the Emission setting uses the tint you\u2019ve assigned in HDR. If you do not enable Emission , Unity sets the emission to black and does not calculate emission. Tiling A 2D multiplier value that scales the texture to fit across a mesh according to the U and V axes. This is good for surfaces like floors and walls. The default value is 1, which means no scaling. Set a higher value to make the texture repeat across your mesh. Set a lower value to stretch the texture. Try different values until you reach your desired effect. Offset The 2D offset that positions the texture on the mesh. To adjust the map position on your mesh, move the texture across the U or V axes.","title":"Surface Inputs"},{"location":"LWRP/simple-lit-shader/#advanced","text":"The Advanced settings affect behind-the-Scenes rendering. They do not have a visible effect on your surface, but on underlying calculations. Property Description GPU Instancing Make Unity render meshes with the same geometry and Material/shader in one batch, when possible. This makes rendering faster. Meshes cannot be rendered in one batch if they have different Materials or if the hardware does not support GPU instancing. Double-sided Global Illumination Make the surface act double-sided du ring lightmapping. When enabled, backfaces bounce light like frontfaces, but Unity still doesn\u2019t render them.","title":"Advanced"},{"location":"LWRP/unlit-shader/","text":"Note: This page is subject to change during the 2019.1 beta cycle. Unlit shader Use this shader for stylised games or apps that do not require direct lighting. Because of the lack of light calculations, you can expect high performance from these games. Using the Unlit shader in the Editor To create a new Material with the shader: 1. In your Project window, click Create > Material . Select the Unlit shader. To select and use this shader: 1. In your Project, create or find the Material you want to use the shader on. Select the Material . A Material Inspector window opens. 2. Click Shader , and select Lightweight Render Pipeline > Unlit . UI overview The Inspector window contains these elements: Surface Options Surface Inputs Advanced You can read more about each section in the following overviews. Surface Options The Surface Options control how the Material is rendered on a screen. Property Description Surface Type In this drop-down menu, choose between an Opaque or Transparent surface type. Opaque surface types are fully visible, without any considerations of what\u2019s behind them. Transparent surface types take their background into account, and they can vary according to which type of transparent surface type, you choose. If you select Transparent , a second dropdown appears (see Transparent property description below). Transparent surface type Alpha uses the alpha value to change how visible an object is. 1 is fully opaque, 0 is fully transparent. Premultiply applies a similar effect as Alpha , but only keeps reflections and highlights, even when your surface is transparent. This means that only the reflected light is visible. For example, imagine transparent glass. Additive adds an extra layer on top of another surface. This is good for holograms. Multiply multiplies the colors behind the surface, like colored glass. Two Sided Enable this to render on both sides of your geometry. When disabled, Unity culls the backface of your geometry and only renders the frontface. For example, Two Sided rendering is good for small, flat objects, like leaves, where you might want both sides visible. By default, this setting is disabled, so that Unity culls backfaces. Alpha Clip Enable this to make your Material act like a Cutout shader. With this, you can create a transparent effect with hard edges between the opaque and transparent areas. For example, to create straws of grass. Unity achieves this effect by not rendering Alpha values below the specified Clip Threshold , which appears when you enable Alpha Clip . Surface Inputs The Surface Inputs describe the surface itself. For example, you can use these properties to make your surface look wet, dry, rough, or smooth. Property Description MainTex This is the color of the surface, also known as the diffuse map. To assign a texture to the MainTex setting, click the object picker next to it. This opens the Asset Browser, where you can select from the textures on your Project. Alternatively, you can use the color picker . The color next to the setting shows the tint on top of your assigned texture. To assign another tint, you can click this color swatch. If you select Transparent or Alpha Clip under Render Properties , your Material uses the texture\u2019s alpha channel or color. Sample GI With this enabled, you can create a surface that uses Light Probe data to add ambient lighting. When enabled, the Normal map setting appears. Here, you can assign a tangent-space normal map , similar to the one in the Standard Shader in the built-in render pipeline. To read more about tangent-spaced normal maps, see this article on Polycount . If you do not enable Sample GI , the render pipeline considers ambient as white and skips sampling the Light Probe data. Tiling A 2D multiplier value that scales the texture to fit across a mesh according to the U and V axes. This is good for surfaces like floors and walls. The default value is 1, which means no scaling. Set a higher value to make the texture repeat across your mesh. Set a lower value to stretch the texture. Try different values until you reach your desired effect. Offset The 2D offset that positions the texture on the mesh. To adjust the map position on your mesh, move the texture across the U or V axes. Advanced The Advanced settings affect the underlying calculations of your rendering. They do not have a visible effect on your surface. Property Description GPU Instancing Make Unity render meshes with the same geometry and Material/shader in one batch, when possible. This makes rendering faster. Meshes cannot be rendered in one batch if they have different Materials or if the hardware does not support GPU instancing. Double Sided Global Illumination Make the surface act double-sided during lightmapping. When enabled, backfaces bounce light like frontfaces, but Unity still doesn\u2019t render them.","title":"Unlit shader"},{"location":"LWRP/unlit-shader/#unlit-shader","text":"Use this shader for stylised games or apps that do not require direct lighting. Because of the lack of light calculations, you can expect high performance from these games.","title":"Unlit shader"},{"location":"LWRP/unlit-shader/#using-the-unlit-shader-in-the-editor","text":"To create a new Material with the shader: 1. In your Project window, click Create > Material . Select the Unlit shader. To select and use this shader: 1. In your Project, create or find the Material you want to use the shader on. Select the Material . A Material Inspector window opens. 2. Click Shader , and select Lightweight Render Pipeline > Unlit .","title":"Using the Unlit shader in the Editor"},{"location":"LWRP/unlit-shader/#ui-overview","text":"The Inspector window contains these elements: Surface Options Surface Inputs Advanced You can read more about each section in the following overviews.","title":"UI overview"},{"location":"LWRP/unlit-shader/#surface-options","text":"The Surface Options control how the Material is rendered on a screen. Property Description Surface Type In this drop-down menu, choose between an Opaque or Transparent surface type. Opaque surface types are fully visible, without any considerations of what\u2019s behind them. Transparent surface types take their background into account, and they can vary according to which type of transparent surface type, you choose. If you select Transparent , a second dropdown appears (see Transparent property description below). Transparent surface type Alpha uses the alpha value to change how visible an object is. 1 is fully opaque, 0 is fully transparent. Premultiply applies a similar effect as Alpha , but only keeps reflections and highlights, even when your surface is transparent. This means that only the reflected light is visible. For example, imagine transparent glass. Additive adds an extra layer on top of another surface. This is good for holograms. Multiply multiplies the colors behind the surface, like colored glass. Two Sided Enable this to render on both sides of your geometry. When disabled, Unity culls the backface of your geometry and only renders the frontface. For example, Two Sided rendering is good for small, flat objects, like leaves, where you might want both sides visible. By default, this setting is disabled, so that Unity culls backfaces. Alpha Clip Enable this to make your Material act like a Cutout shader. With this, you can create a transparent effect with hard edges between the opaque and transparent areas. For example, to create straws of grass. Unity achieves this effect by not rendering Alpha values below the specified Clip Threshold , which appears when you enable Alpha Clip .","title":"Surface Options"},{"location":"LWRP/unlit-shader/#surface-inputs","text":"The Surface Inputs describe the surface itself. For example, you can use these properties to make your surface look wet, dry, rough, or smooth. Property Description MainTex This is the color of the surface, also known as the diffuse map. To assign a texture to the MainTex setting, click the object picker next to it. This opens the Asset Browser, where you can select from the textures on your Project. Alternatively, you can use the color picker . The color next to the setting shows the tint on top of your assigned texture. To assign another tint, you can click this color swatch. If you select Transparent or Alpha Clip under Render Properties , your Material uses the texture\u2019s alpha channel or color. Sample GI With this enabled, you can create a surface that uses Light Probe data to add ambient lighting. When enabled, the Normal map setting appears. Here, you can assign a tangent-space normal map , similar to the one in the Standard Shader in the built-in render pipeline. To read more about tangent-spaced normal maps, see this article on Polycount . If you do not enable Sample GI , the render pipeline considers ambient as white and skips sampling the Light Probe data. Tiling A 2D multiplier value that scales the texture to fit across a mesh according to the U and V axes. This is good for surfaces like floors and walls. The default value is 1, which means no scaling. Set a higher value to make the texture repeat across your mesh. Set a lower value to stretch the texture. Try different values until you reach your desired effect. Offset The 2D offset that positions the texture on the mesh. To adjust the map position on your mesh, move the texture across the U or V axes.","title":"Surface Inputs"},{"location":"LWRP/unlit-shader/#advanced","text":"The Advanced settings affect the underlying calculations of your rendering. They do not have a visible effect on your surface. Property Description GPU Instancing Make Unity render meshes with the same geometry and Material/shader in one batch, when possible. This makes rendering faster. Meshes cannot be rendered in one batch if they have different Materials or if the hardware does not support GPU instancing. Double Sided Global Illumination Make the surface act double-sided during lightmapping. When enabled, backfaces bounce light like frontfaces, but Unity still doesn\u2019t render them.","title":"Advanced"},{"location":"LWRP/upgrading-your-shaders/","text":"Note: This page is subject to change during the 2019.1 beta cycle. Upgrading your shaders If your Project uses shaders from the built-in render pipeline, and you want to switch your Project to use the Lightweight Render Pipeline instead, you must convert those shader to the LWRP shaders. This is because built-in Lit shaders are not compatible with LWRP shaders. For an overview of the mapping between built-in shaders and LWRP shaders, see Shader mappings . To upgrade built-in shaders: Open your Project in Unity, and go to Edit > Render Pipeline . According to your needs, select either Upgrade Project Materials to Lightweight RP Materials or Upgrade Scene Materials to Lightweight RP Materials . Note: These changes cannot be undone. Backup your Project before you upgrade it. Shader mappings The table below shows which LWRP shaders the Unity built-in shaders convert to when you run the shader upgrader. Unity built-in shader Lightweight Render Pipeline shader Standard Lightweight Render Pipeline/Lit Standard (Specular Setup) Lightweight Render Pipeline/Lit Standard Terrain Lightweight Render Pipeline/Terrain/Lit Particles/Standard Surface Lightweight Render Pipeline/Particles/Lit Particles/Standard Unlit Lightweight Render Pipeline/Particles/Unlit Mobile/Diffuse Lightweight Render Pipeline/Simple Lit Mobile/Bumped Specular Lightweight Render Pipeline/Simple Lit Mobile/Bumped Specular(1 Directional Light) Lightweight Render Pipeline/Simple Lit Mobile/Unlit (Supports Lightmap) Lightweight Render Pipeline/Simple Lit Mobile/VertexLit Lightweight Render Pipeline/Simple Lit Legacy Shaders/Diffuse Lightweight Render Pipeline/Simple Lit Legacy Shaders/Specular Lightweight Render Pipeline/Simple Lit Legacy Shaders/Bumped Diffuse Lightweight Render Pipeline/Simple Lit Legacy Shaders/Bumped Specular Lightweight Render Pipeline/Simple Lit Legacy Shaders/Self-Illumin/Diffuse Lightweight Render Pipeline/Simple Lit Legacy Shaders/Self-Illumin/Bumped Diffuse Lightweight Render Pipeline/Simple Lit Legacy Shaders/Self-Illumin/Specular Lightweight Render Pipeline/Simple Lit Legacy Shaders/Self-Illumin/Bumped Specular Lightweight Render Pipeline/Simple Lit Legacy Shaders/Transparent/Diffuse Lightweight Render Pipeline/Simple Lit Legacy Shaders/Transparent/Specular Lightweight Render Pipeline/Simple Lit Legacy Shaders/Transparent/Bumped Diffuse Lightweight Render Pipeline/Simple Lit Legacy Shaders/Transparent/Bumped Specular Lightweight Render Pipeline/Simple Lit Legacy Shaders/Transparent/Cutout/Diffuse Lightweight Render Pipeline/Simple Lit Legacy Shaders/Transparent/Cutout/Specular Lightweight Render Pipeline/Simple Lit Legacy Shaders/Transparent/Cutout/Bumped Diffuse Lightweight Render Pipeline/Simple Lit Legacy Shaders/Transparent/Cutout/Bumped Specular Lightweight Render Pipeline/Simple Lit","title":"Upgrading your shaders"},{"location":"LWRP/upgrading-your-shaders/#upgrading-your-shaders","text":"If your Project uses shaders from the built-in render pipeline, and you want to switch your Project to use the Lightweight Render Pipeline instead, you must convert those shader to the LWRP shaders. This is because built-in Lit shaders are not compatible with LWRP shaders. For an overview of the mapping between built-in shaders and LWRP shaders, see Shader mappings . To upgrade built-in shaders: Open your Project in Unity, and go to Edit > Render Pipeline . According to your needs, select either Upgrade Project Materials to Lightweight RP Materials or Upgrade Scene Materials to Lightweight RP Materials . Note: These changes cannot be undone. Backup your Project before you upgrade it.","title":"Upgrading your shaders"},{"location":"LWRP/upgrading-your-shaders/#shader-mappings","text":"The table below shows which LWRP shaders the Unity built-in shaders convert to when you run the shader upgrader. Unity built-in shader Lightweight Render Pipeline shader Standard Lightweight Render Pipeline/Lit Standard (Specular Setup) Lightweight Render Pipeline/Lit Standard Terrain Lightweight Render Pipeline/Terrain/Lit Particles/Standard Surface Lightweight Render Pipeline/Particles/Lit Particles/Standard Unlit Lightweight Render Pipeline/Particles/Unlit Mobile/Diffuse Lightweight Render Pipeline/Simple Lit Mobile/Bumped Specular Lightweight Render Pipeline/Simple Lit Mobile/Bumped Specular(1 Directional Light) Lightweight Render Pipeline/Simple Lit Mobile/Unlit (Supports Lightmap) Lightweight Render Pipeline/Simple Lit Mobile/VertexLit Lightweight Render Pipeline/Simple Lit Legacy Shaders/Diffuse Lightweight Render Pipeline/Simple Lit Legacy Shaders/Specular Lightweight Render Pipeline/Simple Lit Legacy Shaders/Bumped Diffuse Lightweight Render Pipeline/Simple Lit Legacy Shaders/Bumped Specular Lightweight Render Pipeline/Simple Lit Legacy Shaders/Self-Illumin/Diffuse Lightweight Render Pipeline/Simple Lit Legacy Shaders/Self-Illumin/Bumped Diffuse Lightweight Render Pipeline/Simple Lit Legacy Shaders/Self-Illumin/Specular Lightweight Render Pipeline/Simple Lit Legacy Shaders/Self-Illumin/Bumped Specular Lightweight Render Pipeline/Simple Lit Legacy Shaders/Transparent/Diffuse Lightweight Render Pipeline/Simple Lit Legacy Shaders/Transparent/Specular Lightweight Render Pipeline/Simple Lit Legacy Shaders/Transparent/Bumped Diffuse Lightweight Render Pipeline/Simple Lit Legacy Shaders/Transparent/Bumped Specular Lightweight Render Pipeline/Simple Lit Legacy Shaders/Transparent/Cutout/Diffuse Lightweight Render Pipeline/Simple Lit Legacy Shaders/Transparent/Cutout/Specular Lightweight Render Pipeline/Simple Lit Legacy Shaders/Transparent/Cutout/Bumped Diffuse Lightweight Render Pipeline/Simple Lit Legacy Shaders/Transparent/Cutout/Bumped Specular Lightweight Render Pipeline/Simple Lit","title":"Shader mappings"},{"location":"ShaderGraph/","text":"Description A Shader Graph enables you to build shaders visually. Instead of hand writing code you create and connect nodes in a graph network. The graph framework gives instant feedback on the changes, and it\u2019s simple enough that new users can become involved in shader creation. For an introduction to Shader Graph see Getting Started . Disclaimer This repository and its documentation is under active development. Everything is subject to change. Contents Getting Started Custom Nodes with CodeFunctionNode Shader Graph Shader Graph Window Blackboard Master Preview Create Node Menu Shader Graph Asset Sub-graph Sub-graph Asset Node Port Edge Master Node Data Property Types Data Types Port Bindings Node Library Scripting API CodeFunctionNode Port Types SlotAttribute Binding GetFunctionToConvert","title":"Index"},{"location":"ShaderGraph/#description","text":"A Shader Graph enables you to build shaders visually. Instead of hand writing code you create and connect nodes in a graph network. The graph framework gives instant feedback on the changes, and it\u2019s simple enough that new users can become involved in shader creation. For an introduction to Shader Graph see Getting Started .","title":"Description"},{"location":"ShaderGraph/#disclaimer","text":"This repository and its documentation is under active development. Everything is subject to change.","title":"Disclaimer"},{"location":"ShaderGraph/#contents","text":"Getting Started Custom Nodes with CodeFunctionNode Shader Graph Shader Graph Window Blackboard Master Preview Create Node Menu Shader Graph Asset Sub-graph Sub-graph Asset Node Port Edge Master Node Data Property Types Data Types Port Bindings Node Library Scripting API CodeFunctionNode Port Types SlotAttribute Binding GetFunctionToConvert","title":"Contents"},{"location":"ShaderGraph/Absolute-Node/","text":"Absolute Node Description Returns the absolute value of the input In . Components of the input Dynamic Vector that are positive will remain positive and components that are negative will be inverted and become positive. Ports Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Absolute_float4(float4 In, out float4 Out) { Out = abs(In); }","title":"Absolute Node"},{"location":"ShaderGraph/Absolute-Node/#absolute-node","text":"","title":"Absolute Node"},{"location":"ShaderGraph/Absolute-Node/#description","text":"Returns the absolute value of the input In . Components of the input Dynamic Vector that are positive will remain positive and components that are negative will be inverted and become positive.","title":"Description"},{"location":"ShaderGraph/Absolute-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Absolute-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Absolute_float4(float4 In, out float4 Out) { Out = abs(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Add-Node/","text":"Add Node Description Returns the sum of the two input values A and B . Ports Name Direction Type Description A Input Dynamic Vector First input value B Input Dynamic Vector Second input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Add_float4(float4 A, float4 B, out float4 Out) { Out = A + B; }","title":"Add Node"},{"location":"ShaderGraph/Add-Node/#add-node","text":"","title":"Add Node"},{"location":"ShaderGraph/Add-Node/#description","text":"Returns the sum of the two input values A and B .","title":"Description"},{"location":"ShaderGraph/Add-Node/#ports","text":"Name Direction Type Description A Input Dynamic Vector First input value B Input Dynamic Vector Second input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Add-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Add_float4(float4 A, float4 B, out float4 Out) { Out = A + B; }","title":"Generated Code Example"},{"location":"ShaderGraph/All-Node/","text":"All Node Description Returns true if all components of the input In are non-zero. This is useful for Branching . Ports Name Direction Type Binding Description In Input Dynamic Vector None Input value Out Output Boolean None Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_All_float4(float4 In, out float Out) { Out = all(In); }","title":"All Node"},{"location":"ShaderGraph/All-Node/#all-node","text":"","title":"All Node"},{"location":"ShaderGraph/All-Node/#description","text":"Returns true if all components of the input In are non-zero. This is useful for Branching .","title":"Description"},{"location":"ShaderGraph/All-Node/#ports","text":"Name Direction Type Binding Description In Input Dynamic Vector None Input value Out Output Boolean None Output value","title":"Ports"},{"location":"ShaderGraph/All-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_All_float4(float4 In, out float Out) { Out = all(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Ambient-Node/","text":"Ambient Node Description Provides access to the Scene's Ambient color values. When Environment Lighting Source is set to Gradient Port Color/Sky returns the value Sky Color . When Environment Lighting Source is set to Color Port Color/Sky returns the value Ambient Color . Ports Equator and Ground always return the values Equator Color and Ground Color regardless of the current Environment Lighting Source. Note: Values of this Node are only updated when entering Play mode or saving the current Scene/Project. Note: The behavior of this Node is undefined globally. Shader Graph does not define the function of the node. Instead, each Render Pipeline defines what HLSL code to execute for this Node . Different Render Pipelines may produce different results. If you're building a shader in one Render Pipeline that you want to use in both, try checking it in both pipelines before production. A Node might be defined in one Render Pipeline and undefined in the other. If this Node is undefined, it returns 0 (black). Unity Pipelines Supported Lightweight Render Pipeline Ports Name Direction Type Binding Description Color/Sky Output Vector 3 None Color (Color) or Sky (Gradient) color value Equator Output Vector 3 None Equator (Gradient) color value Ground Output Vector 3 None Ground (Gradient) color value Generated Code Example The following example code represents one possible outcome of this node. float3 _Ambient_ColorSky = SHADERGRAPH_AMBIENT_SKY; float3 _Ambient_Equator = SHADERGRAPH_AMBIENT_EQUATOR; float3 _Ambient_Ground = SHADERGRAPH_AMBIENT_GROUND;","title":"Ambient Node"},{"location":"ShaderGraph/Ambient-Node/#ambient-node","text":"","title":"Ambient Node"},{"location":"ShaderGraph/Ambient-Node/#description","text":"Provides access to the Scene's Ambient color values. When Environment Lighting Source is set to Gradient Port Color/Sky returns the value Sky Color . When Environment Lighting Source is set to Color Port Color/Sky returns the value Ambient Color . Ports Equator and Ground always return the values Equator Color and Ground Color regardless of the current Environment Lighting Source. Note: Values of this Node are only updated when entering Play mode or saving the current Scene/Project. Note: The behavior of this Node is undefined globally. Shader Graph does not define the function of the node. Instead, each Render Pipeline defines what HLSL code to execute for this Node . Different Render Pipelines may produce different results. If you're building a shader in one Render Pipeline that you want to use in both, try checking it in both pipelines before production. A Node might be defined in one Render Pipeline and undefined in the other. If this Node is undefined, it returns 0 (black).","title":"Description"},{"location":"ShaderGraph/Ambient-Node/#unity-pipelines-supported","text":"Lightweight Render Pipeline","title":"Unity Pipelines Supported"},{"location":"ShaderGraph/Ambient-Node/#ports","text":"Name Direction Type Binding Description Color/Sky Output Vector 3 None Color (Color) or Sky (Gradient) color value Equator Output Vector 3 None Equator (Gradient) color value Ground Output Vector 3 None Ground (Gradient) color value","title":"Ports"},{"location":"ShaderGraph/Ambient-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. float3 _Ambient_ColorSky = SHADERGRAPH_AMBIENT_SKY; float3 _Ambient_Equator = SHADERGRAPH_AMBIENT_EQUATOR; float3 _Ambient_Ground = SHADERGRAPH_AMBIENT_GROUND;","title":"Generated Code Example"},{"location":"ShaderGraph/And-Node/","text":"And Node Description Returns true if both the inputs A and B are true. This is useful for Branching . Ports Name Direction Type Binding Description A Input Boolean None First input value B Input Boolean None Second input value Out Output Boolean None Output value Generated Code Example void Unity_And(float A, float B, out float Out) { Out = A && B; }","title":"And Node"},{"location":"ShaderGraph/And-Node/#and-node","text":"","title":"And Node"},{"location":"ShaderGraph/And-Node/#description","text":"Returns true if both the inputs A and B are true. This is useful for Branching .","title":"Description"},{"location":"ShaderGraph/And-Node/#ports","text":"Name Direction Type Binding Description A Input Boolean None First input value B Input Boolean None Second input value Out Output Boolean None Output value","title":"Ports"},{"location":"ShaderGraph/And-Node/#generated-code-example","text":"void Unity_And(float A, float B, out float Out) { Out = A && B; }","title":"Generated Code Example"},{"location":"ShaderGraph/Any-Node/","text":"Any Node Description Returns true if any of the components of the input In are non-zero. This is useful for Branching . Ports Name Direction Type Binding Description In Input Dynamic Vector None Input value Out Output Boolean None Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Any_float4(float4 In, out float Out) { Out = any(In); }","title":"Any Node"},{"location":"ShaderGraph/Any-Node/#any-node","text":"","title":"Any Node"},{"location":"ShaderGraph/Any-Node/#description","text":"Returns true if any of the components of the input In are non-zero. This is useful for Branching .","title":"Description"},{"location":"ShaderGraph/Any-Node/#ports","text":"Name Direction Type Binding Description In Input Dynamic Vector None Input value Out Output Boolean None Output value","title":"Ports"},{"location":"ShaderGraph/Any-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Any_float4(float4 In, out float Out) { Out = any(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Arccosine-Node/","text":"Arccosine Node Description Returns the arccosine of each component of the input In as a vector of the same dimension and equal length. Each component should be within the range of -1 to 1. Ports Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Arccosine_float4(float4 In, out float4 Out) { Out = acos(In); }","title":"Arccosine Node"},{"location":"ShaderGraph/Arccosine-Node/#arccosine-node","text":"","title":"Arccosine Node"},{"location":"ShaderGraph/Arccosine-Node/#description","text":"Returns the arccosine of each component of the input In as a vector of the same dimension and equal length. Each component should be within the range of -1 to 1.","title":"Description"},{"location":"ShaderGraph/Arccosine-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Arccosine-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Arccosine_float4(float4 In, out float4 Out) { Out = acos(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Arcsine-Node/","text":"Arcsine Node Description Returns the arcsine of each component of the input In as a vector of the same dimension and equal length. Each component should be within the range of -Pi/2 to Pi/2. Ports Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Arcsine_float4(float4 In, out float4 Out) { Out = asin(In); }","title":"Arcsine Node"},{"location":"ShaderGraph/Arcsine-Node/#arcsine-node","text":"","title":"Arcsine Node"},{"location":"ShaderGraph/Arcsine-Node/#description","text":"Returns the arcsine of each component of the input In as a vector of the same dimension and equal length. Each component should be within the range of -Pi/2 to Pi/2.","title":"Description"},{"location":"ShaderGraph/Arcsine-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Arcsine-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Arcsine_float4(float4 In, out float4 Out) { Out = asin(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Arctangent-Node/","text":"Arctangent Node Description Returns the arctangent of the value of input In . Each component should be within the range of -Pi/2 to Pi/2. Ports Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Arctangent_float4(float4 In, out float4 Out) { Out = atan(In); }","title":"Arctangent Node"},{"location":"ShaderGraph/Arctangent-Node/#arctangent-node","text":"","title":"Arctangent Node"},{"location":"ShaderGraph/Arctangent-Node/#description","text":"Returns the arctangent of the value of input In . Each component should be within the range of -Pi/2 to Pi/2.","title":"Description"},{"location":"ShaderGraph/Arctangent-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Arctangent-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Arctangent_float4(float4 In, out float4 Out) { Out = atan(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Arctangent2-Node/","text":"Arctangent2 Node Description Returns the arctangent of the values of both input A and input B . The signs (whether they are positive or negative values) of the input values are used to determine whether the output components, or channels, are positive or negative within a range of -Pi to Pi. Ports Name Direction Type Description A Input Dynamic Vector First input value B Input Dynamic Vector Second input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Arctangent2_float4(float4 A, float4 B, out float4 Out) { Out = atan2(A, B); }","title":"Arctangent2 Node"},{"location":"ShaderGraph/Arctangent2-Node/#arctangent2-node","text":"","title":"Arctangent2 Node"},{"location":"ShaderGraph/Arctangent2-Node/#description","text":"Returns the arctangent of the values of both input A and input B . The signs (whether they are positive or negative values) of the input values are used to determine whether the output components, or channels, are positive or negative within a range of -Pi to Pi.","title":"Description"},{"location":"ShaderGraph/Arctangent2-Node/#ports","text":"Name Direction Type Description A Input Dynamic Vector First input value B Input Dynamic Vector Second input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Arctangent2-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Arctangent2_float4(float4 A, float4 B, out float4 Out) { Out = atan2(A, B); }","title":"Generated Code Example"},{"location":"ShaderGraph/Artistic-Nodes/","text":"Artistic Nodes Adjustment Channel Mixer Contrast Controls the amount each of the channels of input In contribute to each of the output channels. Adjusts the contrast of input In by the amount of input Contrast. Hue Invert Colors Offsets the hue of input In by the amount of input Offset. Inverts the colors of input In on a per channel basis. Replace Color Saturation Replaces values in input In equal to input From to the value of input To. Adjusts the saturation of input In by the amount of input Saturation. White Balance Adjusts the temperature and tint of input In by the amount of inputs Temperature and Tint respectively. Blend Blend Blends the value of input Blend onto input Base using the blending mode defined by parameter Mode. Filter Dither Dither is an intentional form of noise used to randomize quantization error. It is used to prevent large-scale patterns such as color banding in images.. Mask Channel Mask Color Mask Masks values of input In on channels selected in dropdown Channels. Creates a mask from values in input In equal to input Mask Color. Normal Normal Blend Normal From Height Blends two normal maps defined by inputs A and B together. Creates a normal map from a height map defined by input Texture. Normal Strength Normal Unpack Adjusts the strength of the normal map defined by input In by the amount of input Strength. Unpacks a normal map defined by input In. Utility Colorspace Conversion Returns the result of converting the value of input In from one colorspace space to another.","title":"Artistic Nodes"},{"location":"ShaderGraph/Artistic-Nodes/#artistic-nodes","text":"","title":"Artistic Nodes"},{"location":"ShaderGraph/Artistic-Nodes/#adjustment","text":"Channel Mixer Contrast Controls the amount each of the channels of input In contribute to each of the output channels. Adjusts the contrast of input In by the amount of input Contrast. Hue Invert Colors Offsets the hue of input In by the amount of input Offset. Inverts the colors of input In on a per channel basis. Replace Color Saturation Replaces values in input In equal to input From to the value of input To. Adjusts the saturation of input In by the amount of input Saturation. White Balance Adjusts the temperature and tint of input In by the amount of inputs Temperature and Tint respectively.","title":"Adjustment"},{"location":"ShaderGraph/Artistic-Nodes/#blend","text":"Blend Blends the value of input Blend onto input Base using the blending mode defined by parameter Mode.","title":"Blend"},{"location":"ShaderGraph/Artistic-Nodes/#filter","text":"Dither Dither is an intentional form of noise used to randomize quantization error. It is used to prevent large-scale patterns such as color banding in images..","title":"Filter"},{"location":"ShaderGraph/Artistic-Nodes/#mask","text":"Channel Mask Color Mask Masks values of input In on channels selected in dropdown Channels. Creates a mask from values in input In equal to input Mask Color.","title":"Mask"},{"location":"ShaderGraph/Artistic-Nodes/#normal","text":"Normal Blend Normal From Height Blends two normal maps defined by inputs A and B together. Creates a normal map from a height map defined by input Texture. Normal Strength Normal Unpack Adjusts the strength of the normal map defined by input In by the amount of input Strength. Unpacks a normal map defined by input In.","title":"Normal"},{"location":"ShaderGraph/Artistic-Nodes/#utility","text":"Colorspace Conversion Returns the result of converting the value of input In from one colorspace space to another.","title":"Utility"},{"location":"ShaderGraph/Baked-GI-Node/","text":"Baked GI Node Description Provides access to the Baked GI values at the vertex or fragment's position. Requires Position and Normal input for light probe sampling, and lightmap coordinates Static UV and Dynamic UV for all potential lightmap sampling cases. Note: The behavior of this Node is undefined globally. Shader Graph does not define the function of the node. Instead, each Render Pipeline defines what HLSL code to execute for this Node . Different Render Pipelines may produce different results. If you're building a shader in one Render Pipeline that you want to use in both, try checking it in both pipelines before production. A Node might be defined in one Render Pipeline and undefined in the other. If this Node is undefined, it returns 0 (black). Unity Pipelines Supported HD Render Pipeline Lightweight Render Pipeline Ports Name Direction Type Binding Description Position Input Vector 3 Position (world space) Mesh vertex/fragment's Position Normal Input Vector 3 Normal (world space) Mesh vertex/fragment's Normal Static UV Input Vector 2 UV1 Lightmap coordinates for the static lightmap Dynamic UV Input Vector 2 UV2 Lightmap coordinates for the dynamic lightmap Out Output Vector 3 None Output color value Controls Name Type Options Description Apply Lightmap Scaling Toggle True, False If enabled lightmaps are automatically scaled and offset. Generated Code Example The following example code represents one possible outcome of this node. void Unity_BakedGI_float(float3 Position, float3 Normal, float2 StaticUV, float2 DynamicUV, out float Out) { Out = SHADERGRAPH_BAKED_GI(Position, Normal, StaticUV, DynamicUV, false); }","title":"Baked GI Node"},{"location":"ShaderGraph/Baked-GI-Node/#baked-gi-node","text":"","title":"Baked GI Node"},{"location":"ShaderGraph/Baked-GI-Node/#description","text":"Provides access to the Baked GI values at the vertex or fragment's position. Requires Position and Normal input for light probe sampling, and lightmap coordinates Static UV and Dynamic UV for all potential lightmap sampling cases. Note: The behavior of this Node is undefined globally. Shader Graph does not define the function of the node. Instead, each Render Pipeline defines what HLSL code to execute for this Node . Different Render Pipelines may produce different results. If you're building a shader in one Render Pipeline that you want to use in both, try checking it in both pipelines before production. A Node might be defined in one Render Pipeline and undefined in the other. If this Node is undefined, it returns 0 (black).","title":"Description"},{"location":"ShaderGraph/Baked-GI-Node/#unity-pipelines-supported","text":"HD Render Pipeline Lightweight Render Pipeline","title":"Unity Pipelines Supported"},{"location":"ShaderGraph/Baked-GI-Node/#ports","text":"Name Direction Type Binding Description Position Input Vector 3 Position (world space) Mesh vertex/fragment's Position Normal Input Vector 3 Normal (world space) Mesh vertex/fragment's Normal Static UV Input Vector 2 UV1 Lightmap coordinates for the static lightmap Dynamic UV Input Vector 2 UV2 Lightmap coordinates for the dynamic lightmap Out Output Vector 3 None Output color value","title":"Ports"},{"location":"ShaderGraph/Baked-GI-Node/#controls","text":"Name Type Options Description Apply Lightmap Scaling Toggle True, False If enabled lightmaps are automatically scaled and offset.","title":"Controls"},{"location":"ShaderGraph/Baked-GI-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_BakedGI_float(float3 Position, float3 Normal, float2 StaticUV, float2 DynamicUV, out float Out) { Out = SHADERGRAPH_BAKED_GI(Position, Normal, StaticUV, DynamicUV, false); }","title":"Generated Code Example"},{"location":"ShaderGraph/Bitangent-Vector-Node/","text":"Bitangent Node Description Provides access to the mesh vertex or fragment's Bitangent Vector , depending on the effective Shader Stage of the graph section the Node is part of. The coordinate space of the output value can be selected with the Space dropdown parameter. Ports Name Direction Type Binding Description Out Output Vector 3 None Bitangent Vector for the Mesh Vertex/Fragment. Controls Name Type Options Description Space Dropdown Object, View, World, Tangent Selects coordinate space of Bitangent Vector to output.","title":"Bitangent Node"},{"location":"ShaderGraph/Bitangent-Vector-Node/#bitangent-node","text":"","title":"Bitangent Node"},{"location":"ShaderGraph/Bitangent-Vector-Node/#description","text":"Provides access to the mesh vertex or fragment's Bitangent Vector , depending on the effective Shader Stage of the graph section the Node is part of. The coordinate space of the output value can be selected with the Space dropdown parameter.","title":"Description"},{"location":"ShaderGraph/Bitangent-Vector-Node/#ports","text":"Name Direction Type Binding Description Out Output Vector 3 None Bitangent Vector for the Mesh Vertex/Fragment.","title":"Ports"},{"location":"ShaderGraph/Bitangent-Vector-Node/#controls","text":"Name Type Options Description Space Dropdown Object, View, World, Tangent Selects coordinate space of Bitangent Vector to output.","title":"Controls"},{"location":"ShaderGraph/Blackboard/","text":"Description The Blackboard defines the Properties that will be exposed to materials using the shader. Here you can define a range of Property types as well as their various names, attributes and default values. You can also rename the Shader Graph Asset and change its path in the shader dropdown list by selecting their fields in the Blackboard 's title bar. When editing a Sub-graph the path field will set the Sub-graph's path in the Create Node Menu . The Blackboard can be moved to anywhere in the Shader Graph Window and will automatically move with the nearest corner of that window. To create a new Property , click the Add button on the Blackboard title bar and select the Property type. Properties on the Blackboard can be reordered by dragging them in the list. They can be deleted with Delete (Windows) or Command + Backpace (OSX). You can rename a Property by double clicking on its entry. Instances of a Property can be created in the shader by dragging them on to the Graph . For a full list of Property types see Property Types .","title":"Blackboard"},{"location":"ShaderGraph/Blackboard/#description","text":"The Blackboard defines the Properties that will be exposed to materials using the shader. Here you can define a range of Property types as well as their various names, attributes and default values. You can also rename the Shader Graph Asset and change its path in the shader dropdown list by selecting their fields in the Blackboard 's title bar. When editing a Sub-graph the path field will set the Sub-graph's path in the Create Node Menu . The Blackboard can be moved to anywhere in the Shader Graph Window and will automatically move with the nearest corner of that window. To create a new Property , click the Add button on the Blackboard title bar and select the Property type. Properties on the Blackboard can be reordered by dragging them in the list. They can be deleted with Delete (Windows) or Command + Backpace (OSX). You can rename a Property by double clicking on its entry. Instances of a Property can be created in the shader by dragging them on to the Graph . For a full list of Property types see Property Types .","title":"Description"},{"location":"ShaderGraph/Blend-Node/","text":"Blend Node Description Blends the value of input Blend onto input Base using the blending mode defined by the Mode parameter. The strength of the blend is defined by input Opacity . An Opacity value of 0 will return the input Base , unaltered. Ports Name Direction Type Binding Description Base Input Dynamic Vector None Base layer value Blend Input Dynamic Vector None Blend layer value Opacity Input Vector 1 None Strength of blend Out Output Dynamic Vector None Output value Controls Name Type Options Description Mode Dropdown Burn, Darken, Difference, Dodge, Divide, Exclusion, HardLight, HardMix, Lighten, LinearBurn, LinearDodge, LinearLight, LinearLightAddSub, Multiply, Negation, Overlay, PinLight, Screen, SoftLight, Subtract, VividLight, Overwrite Blend mode to apply Generated Code Example The following example code represents one possible outcome of this node per blend mode. Burn void Unity_Blend_Burn_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { Out = 1.0 - (1.0 - Blend)/Base; Out = lerp(Base, Out, Opacity); } Darken void Unity_Blend_Darken_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { Out = min(Blend, Base); Out = lerp(Base, Out, Opacity); } Difference void Unity_Blend_Difference_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { Out = abs(Blend - Base); Out = lerp(Base, Out, Opacity); } Dodge void Unity_Blend_Dodge_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { Out = Base / (1.0 - Blend); Out = lerp(Base, Out, Opacity); } Divide void Unity_Blend_Divide_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { Out = Base / (Blend + 0.000000000001); Out = lerp(Base, Out, Opacity); } Exclusion void Unity_Blend_Exclusion_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { Out = Blend + Base - (2.0 * Blend * Base); Out = lerp(Base, Out, Opacity); } HardLight void Unity_Blend_HardLight_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { float4 result1 = 1.0 - 2.0 * (1.0 - Base) * (1.0 - Blend); float4 result2 = 2.0 * Base * Blend; float4 zeroOrOne = step(Blend, 0.5); Out = result2 * zeroOrOne + (1 - zeroOrOne) * result1; Out = lerp(Base, Out, Opacity); } HardMix void Unity_Blend_HardMix_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { Out = step(1 - Base, Blend); Out = lerp(Base, Out, Opacity); } Lighten void Unity_Blend_Lighten_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { Out = max(Blend, Base); Out = lerp(Base, Out, Opacity); } LinearBurn void Unity_Blend_LinearBurn_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { Out = Base + Blend - 1.0; Out = lerp(Base, Out, Opacity); } LinearDodge void Unity_Blend_LinearDodge_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { Out = Base + Blend; Out = lerp(Base, Out, Opacity); } LinearLight void Unity_Blend_LinearLight_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { Out = Blend < 0.5 ? max(Base + (2 * Blend) - 1, 0) : min(Base + 2 * (Blend - 0.5), 1); Out = lerp(Base, Out, Opacity); } LinearLightAddSub void Unity_Blend_LinearLightAddSub_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { Out = Blend + 2.0 * Base - 1.0; Out = lerp(Base, Out, Opacity); } Multiply void Unity_Blend_Multiply_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { Out = Base * Blend; Out = lerp(Base, Out, Opacity); } Negation void Unity_Blend_Negation_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { Out = 1.0 - abs(1.0 - Blend - Base); Out = lerp(Base, Out, Opacity); } Overlay void Unity_Blend_Overlay_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { float4 result1 = 1.0 - 2.0 * (1.0 - Base) * (1.0 - Blend); float4 result2 = 2.0 * Base * Blend; float4 zeroOrOne = step(Base, 0.5); Out = result2 * zeroOrOne + (1 - zeroOrOne) * result1; Out = lerp(Base, Out, Opacity); } PinLight void Unity_Blend_PinLight_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { float4 check = step (0.5, Blend); float4 result1 = check * max(2.0 * (Base - 0.5), Blend); Out = result1 + (1.0 - check) * min(2.0 * Base, Blend); Out = lerp(Base, Out, Opacity); } Screen void Unity_Blend_Screen_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { Out = 1.0 - (1.0 - Blend) * (1.0 - Base); Out = lerp(Base, Out, Opacity); } SoftLight void Unity_Blend_SoftLight_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { float4 result1 = 2.0 * Base * Blend + Base * Base * (1.0 - 2.0 * Blend); float4 result2 = sqrt(Base) * (2.0 * Blend - 1.0) + 2.0 * Base * (1.0 - Blend); float4 zeroOrOne = step(0.5, Blend); Out = result2 * zeroOrOne + (1 - zeroOrOne) * result1; Out = lerp(Base, Out, Opacity); } Subtract void Unity_Blend_Subtract_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { Out = Base - Blend; Out = lerp(Base, Out, Opacity); } VividLight void Unity_Blend_VividLight_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { float4 result1 = 1.0 - (1.0 - Blend) / (2.0 * Base); float4 result2 = Blend / (2.0 * (1.0 - Base)); float4 zeroOrOne = step(0.5, Base); Out = result2 * zeroOrOne + (1 - zeroOrOne) * result1; Out = lerp(Base, Out, Opacity); } Overwrite void Unity_Blend_Overwrite_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { Out = lerp(Base, Blend, Opacity); }","title":"Blend Node"},{"location":"ShaderGraph/Blend-Node/#blend-node","text":"","title":"Blend Node"},{"location":"ShaderGraph/Blend-Node/#description","text":"Blends the value of input Blend onto input Base using the blending mode defined by the Mode parameter. The strength of the blend is defined by input Opacity . An Opacity value of 0 will return the input Base , unaltered.","title":"Description"},{"location":"ShaderGraph/Blend-Node/#ports","text":"Name Direction Type Binding Description Base Input Dynamic Vector None Base layer value Blend Input Dynamic Vector None Blend layer value Opacity Input Vector 1 None Strength of blend Out Output Dynamic Vector None Output value","title":"Ports"},{"location":"ShaderGraph/Blend-Node/#controls","text":"Name Type Options Description Mode Dropdown Burn, Darken, Difference, Dodge, Divide, Exclusion, HardLight, HardMix, Lighten, LinearBurn, LinearDodge, LinearLight, LinearLightAddSub, Multiply, Negation, Overlay, PinLight, Screen, SoftLight, Subtract, VividLight, Overwrite Blend mode to apply","title":"Controls"},{"location":"ShaderGraph/Blend-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node per blend mode. Burn void Unity_Blend_Burn_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { Out = 1.0 - (1.0 - Blend)/Base; Out = lerp(Base, Out, Opacity); } Darken void Unity_Blend_Darken_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { Out = min(Blend, Base); Out = lerp(Base, Out, Opacity); } Difference void Unity_Blend_Difference_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { Out = abs(Blend - Base); Out = lerp(Base, Out, Opacity); } Dodge void Unity_Blend_Dodge_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { Out = Base / (1.0 - Blend); Out = lerp(Base, Out, Opacity); } Divide void Unity_Blend_Divide_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { Out = Base / (Blend + 0.000000000001); Out = lerp(Base, Out, Opacity); } Exclusion void Unity_Blend_Exclusion_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { Out = Blend + Base - (2.0 * Blend * Base); Out = lerp(Base, Out, Opacity); } HardLight void Unity_Blend_HardLight_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { float4 result1 = 1.0 - 2.0 * (1.0 - Base) * (1.0 - Blend); float4 result2 = 2.0 * Base * Blend; float4 zeroOrOne = step(Blend, 0.5); Out = result2 * zeroOrOne + (1 - zeroOrOne) * result1; Out = lerp(Base, Out, Opacity); } HardMix void Unity_Blend_HardMix_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { Out = step(1 - Base, Blend); Out = lerp(Base, Out, Opacity); } Lighten void Unity_Blend_Lighten_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { Out = max(Blend, Base); Out = lerp(Base, Out, Opacity); } LinearBurn void Unity_Blend_LinearBurn_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { Out = Base + Blend - 1.0; Out = lerp(Base, Out, Opacity); } LinearDodge void Unity_Blend_LinearDodge_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { Out = Base + Blend; Out = lerp(Base, Out, Opacity); } LinearLight void Unity_Blend_LinearLight_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { Out = Blend < 0.5 ? max(Base + (2 * Blend) - 1, 0) : min(Base + 2 * (Blend - 0.5), 1); Out = lerp(Base, Out, Opacity); } LinearLightAddSub void Unity_Blend_LinearLightAddSub_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { Out = Blend + 2.0 * Base - 1.0; Out = lerp(Base, Out, Opacity); } Multiply void Unity_Blend_Multiply_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { Out = Base * Blend; Out = lerp(Base, Out, Opacity); } Negation void Unity_Blend_Negation_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { Out = 1.0 - abs(1.0 - Blend - Base); Out = lerp(Base, Out, Opacity); } Overlay void Unity_Blend_Overlay_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { float4 result1 = 1.0 - 2.0 * (1.0 - Base) * (1.0 - Blend); float4 result2 = 2.0 * Base * Blend; float4 zeroOrOne = step(Base, 0.5); Out = result2 * zeroOrOne + (1 - zeroOrOne) * result1; Out = lerp(Base, Out, Opacity); } PinLight void Unity_Blend_PinLight_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { float4 check = step (0.5, Blend); float4 result1 = check * max(2.0 * (Base - 0.5), Blend); Out = result1 + (1.0 - check) * min(2.0 * Base, Blend); Out = lerp(Base, Out, Opacity); } Screen void Unity_Blend_Screen_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { Out = 1.0 - (1.0 - Blend) * (1.0 - Base); Out = lerp(Base, Out, Opacity); } SoftLight void Unity_Blend_SoftLight_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { float4 result1 = 2.0 * Base * Blend + Base * Base * (1.0 - 2.0 * Blend); float4 result2 = sqrt(Base) * (2.0 * Blend - 1.0) + 2.0 * Base * (1.0 - Blend); float4 zeroOrOne = step(0.5, Blend); Out = result2 * zeroOrOne + (1 - zeroOrOne) * result1; Out = lerp(Base, Out, Opacity); } Subtract void Unity_Blend_Subtract_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { Out = Base - Blend; Out = lerp(Base, Out, Opacity); } VividLight void Unity_Blend_VividLight_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { float4 result1 = 1.0 - (1.0 - Blend) / (2.0 * Base); float4 result2 = Blend / (2.0 * (1.0 - Base)); float4 zeroOrOne = step(0.5, Base); Out = result2 * zeroOrOne + (1 - zeroOrOne) * result1; Out = lerp(Base, Out, Opacity); } Overwrite void Unity_Blend_Overwrite_float4(float4 Base, float4 Blend, float Opacity, out float4 Out) { Out = lerp(Base, Blend, Opacity); }","title":"Generated Code Example"},{"location":"ShaderGraph/Boolean-Node/","text":"Boolean Node Description Defines a constant Boolean value in the Shader Graph , although internally to the shader this is treated as a constant float value that is ether 0 or 1, similar to Shaderlab's Toggle property. Can be converted to a Boolean type Property via the Node's context menu. Ports Name Direction Type Binding Description Out Output Boolean None Output value Controls Name Type Options Description Toggle Defines the output value. Generated Code Example The following example code represents one possible outcome of this node. float _Boolean = 1;","title":"Boolean Node"},{"location":"ShaderGraph/Boolean-Node/#boolean-node","text":"","title":"Boolean Node"},{"location":"ShaderGraph/Boolean-Node/#description","text":"Defines a constant Boolean value in the Shader Graph , although internally to the shader this is treated as a constant float value that is ether 0 or 1, similar to Shaderlab's Toggle property. Can be converted to a Boolean type Property via the Node's context menu.","title":"Description"},{"location":"ShaderGraph/Boolean-Node/#ports","text":"Name Direction Type Binding Description Out Output Boolean None Output value","title":"Ports"},{"location":"ShaderGraph/Boolean-Node/#controls","text":"Name Type Options Description Toggle Defines the output value.","title":"Controls"},{"location":"ShaderGraph/Boolean-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. float _Boolean = 1;","title":"Generated Code Example"},{"location":"ShaderGraph/Branch-Node/","text":"Branch Node Description Provides a dynamic branch to the shader. If input Predicate is true the return output will be equal to input True , otherwise it will be equal to input False . This is determined per vertex or per pixel depending on shader stage. Both sides of the branch will be calculated in the shader, even if one is never output. Ports Name Direction Type Binding Description Predicate Input Boolean None Determines which input to returned True Input Dynamic Vector None Returned if Predicate is true False Input Dynamic Vector None Returned if Predicate is false Out Output Boolean None Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Branch_float4(float Predicate, float4 True, float4 False, out float4 Out) { Out = lerp(False, True, Predicate); }","title":"Branch Node"},{"location":"ShaderGraph/Branch-Node/#branch-node","text":"","title":"Branch Node"},{"location":"ShaderGraph/Branch-Node/#description","text":"Provides a dynamic branch to the shader. If input Predicate is true the return output will be equal to input True , otherwise it will be equal to input False . This is determined per vertex or per pixel depending on shader stage. Both sides of the branch will be calculated in the shader, even if one is never output.","title":"Description"},{"location":"ShaderGraph/Branch-Node/#ports","text":"Name Direction Type Binding Description Predicate Input Boolean None Determines which input to returned True Input Dynamic Vector None Returned if Predicate is true False Input Dynamic Vector None Returned if Predicate is false Out Output Boolean None Output value","title":"Ports"},{"location":"ShaderGraph/Branch-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Branch_float4(float Predicate, float4 True, float4 False, out float4 Out) { Out = lerp(False, True, Predicate); }","title":"Generated Code Example"},{"location":"ShaderGraph/Camera-Node/","text":"Camera Node Description Provides access to various parameters of the Camera currently being used for rendering. This is comprised of values the Camera 's GameObject, such as Position and Direction, as well as various projection parameters. Ports Name Direction Type Binding Description Position Output Vector 3 None Position of the Camera's GameObject in world space Direction Output Vector 3 None The Camera's forward vector direction Orthographic Output Vector 1 None Returns 1 if the Camera is orthographic, otherwise 0 Near Plane Output Vector 1 None The Camera's near plane distance Far Plane Output Vector 1 None The Camera's far plane distance Z Buffer Sign Output Vector 1 None Returns -1 when using a reversed Z Buffer, otherwise 1 Width Output Vector 1 None The Camera's width if orthographic Height Output Vector 1 None The Camera's height if orthographic Generated Code Example The following example code represents one possible outcome of this node. float3 _Camera_Position = _WorldSpaceCameraPos; float3 _Camera_Direction = -1 * mul(UNITY_MATRIX_M, transpose(mul(UNITY_MATRIX_I_M, UNITY_MATRIX_I_V)) [2].xyz); float _Camera_Orthographic = unity_OrthoParams.w; float _Camera_NearPlane = _ProjectionParams.y; float _Camera_FarPlane = _ProjectionParams.z; float _Camera_ZBufferSign = _ProjectionParams.x; float _Camera_Width = unity_OrthoParams.x; float _Camera_Height = unity_OrthoParams.y;","title":"Camera Node"},{"location":"ShaderGraph/Camera-Node/#camera-node","text":"","title":"Camera Node"},{"location":"ShaderGraph/Camera-Node/#description","text":"Provides access to various parameters of the Camera currently being used for rendering. This is comprised of values the Camera 's GameObject, such as Position and Direction, as well as various projection parameters.","title":"Description"},{"location":"ShaderGraph/Camera-Node/#ports","text":"Name Direction Type Binding Description Position Output Vector 3 None Position of the Camera's GameObject in world space Direction Output Vector 3 None The Camera's forward vector direction Orthographic Output Vector 1 None Returns 1 if the Camera is orthographic, otherwise 0 Near Plane Output Vector 1 None The Camera's near plane distance Far Plane Output Vector 1 None The Camera's far plane distance Z Buffer Sign Output Vector 1 None Returns -1 when using a reversed Z Buffer, otherwise 1 Width Output Vector 1 None The Camera's width if orthographic Height Output Vector 1 None The Camera's height if orthographic","title":"Ports"},{"location":"ShaderGraph/Camera-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. float3 _Camera_Position = _WorldSpaceCameraPos; float3 _Camera_Direction = -1 * mul(UNITY_MATRIX_M, transpose(mul(UNITY_MATRIX_I_M, UNITY_MATRIX_I_V)) [2].xyz); float _Camera_Orthographic = unity_OrthoParams.w; float _Camera_NearPlane = _ProjectionParams.y; float _Camera_FarPlane = _ProjectionParams.z; float _Camera_ZBufferSign = _ProjectionParams.x; float _Camera_Width = unity_OrthoParams.x; float _Camera_Height = unity_OrthoParams.y;","title":"Generated Code Example"},{"location":"ShaderGraph/Ceiling-Node/","text":"Ceiling Node Description Returns the smallest integer value, or whole number, that is greater than or equal to the value of input In . Ports Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Ceiling_float4(float4 In, out float4 Out) { Out = ceil(In); }","title":"Ceiling Node"},{"location":"ShaderGraph/Ceiling-Node/#ceiling-node","text":"","title":"Ceiling Node"},{"location":"ShaderGraph/Ceiling-Node/#description","text":"Returns the smallest integer value, or whole number, that is greater than or equal to the value of input In .","title":"Description"},{"location":"ShaderGraph/Ceiling-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Ceiling-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Ceiling_float4(float4 In, out float4 Out) { Out = ceil(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Channel-Mask-Node/","text":"Channel Mask Node Description Masks values of input In on channels selected in dropdown Channels . Outputs a vector of the same length as the input vector but with the selected channels set to 0. Channels available in the dropdown Channels will represent the amount of channels present in input In . Ports Name Direction Type Binding Description In Input Dynamic Vector None Input value Out Output Dynamic Vector None Output value Controls Name Type Options Description Channels Mask Dropdown Dynamic Selects any number of channels to mask Generated Code Example The following example code represents one possible outcome of this node. void Unity_ChannelMask_RedGreen_float4(float4 In, out float4 Out) { Out = float4(0, 0, In.b, In.a); }","title":"Channel Mask Node"},{"location":"ShaderGraph/Channel-Mask-Node/#channel-mask-node","text":"","title":"Channel Mask Node"},{"location":"ShaderGraph/Channel-Mask-Node/#description","text":"Masks values of input In on channels selected in dropdown Channels . Outputs a vector of the same length as the input vector but with the selected channels set to 0. Channels available in the dropdown Channels will represent the amount of channels present in input In .","title":"Description"},{"location":"ShaderGraph/Channel-Mask-Node/#ports","text":"Name Direction Type Binding Description In Input Dynamic Vector None Input value Out Output Dynamic Vector None Output value","title":"Ports"},{"location":"ShaderGraph/Channel-Mask-Node/#controls","text":"Name Type Options Description Channels Mask Dropdown Dynamic Selects any number of channels to mask","title":"Controls"},{"location":"ShaderGraph/Channel-Mask-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_ChannelMask_RedGreen_float4(float4 In, out float4 Out) { Out = float4(0, 0, In.b, In.a); }","title":"Generated Code Example"},{"location":"ShaderGraph/Channel-Mixer-Node/","text":"Channel Mixer Node Description Controls the amount each of the channels of input In contribute to each of the channels of output Out . The slider parameters on the node control the contribution of each of the input channels. The toggle button parameters control which of the output channels is currently being edited. Slider controls for editing the contribution of each input channnel range between -2 and 2. Ports Name Direction Type Binding Description In Input Vector 3 None Input value Out Output Vector 3 None Output value Controls Name Type Options Description Toggle Button Array R, G, B Selects the output channel to edit. R Slider Controls contribution of input red channel to selected output channel. G Slider Controls contribution of input green channel to selected output channel. B Slider Controls contribution of input blue channel to selected output channel. Shader Function Generated Code Example The following example code represents one possible outcome of this node. _ChannelMixer_Red = float3 (OutRedInRed, OutRedInGreen, OutRedInBlue); _ChannelMixer_Green = float3 (OutGreenInRed, OutGreenInGreen, OutGreenInBlue); _ChannelMixer_Blue = float3 (OutBlueInRed, OutBlueInGreen, OutBlueInBlue); void Unity_ChannelMixer_float(float3 In, float3 _ChannelMixer_Red, float3 _ChannelMixer_Green, float3 _ChannelMixer_Blue, out float3 Out) { Out = float3(dot(In, _ChannelMixer_Red), dot(In, _ChannelMixer_Green), dot(In, _ChannelMixer_Blue)); }","title":"Channel Mixer Node"},{"location":"ShaderGraph/Channel-Mixer-Node/#channel-mixer-node","text":"","title":"Channel Mixer Node"},{"location":"ShaderGraph/Channel-Mixer-Node/#description","text":"Controls the amount each of the channels of input In contribute to each of the channels of output Out . The slider parameters on the node control the contribution of each of the input channels. The toggle button parameters control which of the output channels is currently being edited. Slider controls for editing the contribution of each input channnel range between -2 and 2.","title":"Description"},{"location":"ShaderGraph/Channel-Mixer-Node/#ports","text":"Name Direction Type Binding Description In Input Vector 3 None Input value Out Output Vector 3 None Output value","title":"Ports"},{"location":"ShaderGraph/Channel-Mixer-Node/#controls","text":"Name Type Options Description Toggle Button Array R, G, B Selects the output channel to edit. R Slider Controls contribution of input red channel to selected output channel. G Slider Controls contribution of input green channel to selected output channel. B Slider Controls contribution of input blue channel to selected output channel.","title":"Controls"},{"location":"ShaderGraph/Channel-Mixer-Node/#shader-function","text":"","title":"Shader Function"},{"location":"ShaderGraph/Channel-Mixer-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. _ChannelMixer_Red = float3 (OutRedInRed, OutRedInGreen, OutRedInBlue); _ChannelMixer_Green = float3 (OutGreenInRed, OutGreenInGreen, OutGreenInBlue); _ChannelMixer_Blue = float3 (OutBlueInRed, OutBlueInGreen, OutBlueInBlue); void Unity_ChannelMixer_float(float3 In, float3 _ChannelMixer_Red, float3 _ChannelMixer_Green, float3 _ChannelMixer_Blue, out float3 Out) { Out = float3(dot(In, _ChannelMixer_Red), dot(In, _ChannelMixer_Green), dot(In, _ChannelMixer_Blue)); }","title":"Generated Code Example"},{"location":"ShaderGraph/Channel-Nodes/","text":"Channel Nodes Combine Flip Controls the amount each of the channels of input In contribute to each of the output channels. Adjusts the contrast of input In by the amount of input Contrast. Split Swizzle Offsets the hue of input In by the amount of input Offset. Inverts the colors of input In on a per channel basis.","title":"Channel Nodes"},{"location":"ShaderGraph/Channel-Nodes/#channel-nodes","text":"Combine Flip Controls the amount each of the channels of input In contribute to each of the output channels. Adjusts the contrast of input In by the amount of input Contrast. Split Swizzle Offsets the hue of input In by the amount of input Offset. Inverts the colors of input In on a per channel basis.","title":"Channel Nodes"},{"location":"ShaderGraph/Checkerboard-Node/","text":"Checkerboard Node Description Generates a checkerboard of alternating colors between inputs Color A and Color B based on input UV . The checkerboard scale is defined by input Frequency . Ports Name Direction Type Binding Description UV Input Vector 2 UV Input UV value Color A Input Color RGB None First checker color Color B Input Color RGB None Second checker color Frequency Input Vector 2 None Scale of checkerboard per axis Out Output Vector 2 None Output UV value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Checkerboard_float(float2 UV, float3 ColorA, float3 ColorB, float2 Frequency, out float3 Out) { UV = (UV.xy + 0.5) * Frequency; float4 derivatives = float4(ddx(UV), ddy(UV)); float2 duv_length = sqrt(float2(dot(derivatives.xz, derivatives.xz), dot(derivatives.yw, derivatives.yw))); float width = 1.0; float2 distance3 = 4.0 * abs(frac(UV + 0.25) - 0.5) - width; float2 scale = 0.35 / duv_length.xy; float freqLimiter = sqrt(clamp(1.1f - max(duv_length.x, duv_length.y), 0.0, 1.0)); float2 vector_alpha = clamp(distance3 * scale.xy, -1.0, 1.0); float alpha = saturate(0.5f + 0.5f * vector_alpha.x * vector_alpha.y * freqLimiter); Out = lerp(ColorA, ColorB, alpha.xxx); }","title":"Checkerboard Node"},{"location":"ShaderGraph/Checkerboard-Node/#checkerboard-node","text":"","title":"Checkerboard Node"},{"location":"ShaderGraph/Checkerboard-Node/#description","text":"Generates a checkerboard of alternating colors between inputs Color A and Color B based on input UV . The checkerboard scale is defined by input Frequency .","title":"Description"},{"location":"ShaderGraph/Checkerboard-Node/#ports","text":"Name Direction Type Binding Description UV Input Vector 2 UV Input UV value Color A Input Color RGB None First checker color Color B Input Color RGB None Second checker color Frequency Input Vector 2 None Scale of checkerboard per axis Out Output Vector 2 None Output UV value","title":"Ports"},{"location":"ShaderGraph/Checkerboard-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Checkerboard_float(float2 UV, float3 ColorA, float3 ColorB, float2 Frequency, out float3 Out) { UV = (UV.xy + 0.5) * Frequency; float4 derivatives = float4(ddx(UV), ddy(UV)); float2 duv_length = sqrt(float2(dot(derivatives.xz, derivatives.xz), dot(derivatives.yw, derivatives.yw))); float width = 1.0; float2 distance3 = 4.0 * abs(frac(UV + 0.25) - 0.5) - width; float2 scale = 0.35 / duv_length.xy; float freqLimiter = sqrt(clamp(1.1f - max(duv_length.x, duv_length.y), 0.0, 1.0)); float2 vector_alpha = clamp(distance3 * scale.xy, -1.0, 1.0); float alpha = saturate(0.5f + 0.5f * vector_alpha.x * vector_alpha.y * freqLimiter); Out = lerp(ColorA, ColorB, alpha.xxx); }","title":"Generated Code Example"},{"location":"ShaderGraph/Clamp-Node/","text":"Clamp Node Description Returns the input In clamped between the minimum and maximum values defined by inputs Min and Max respectively. Ports Name Direction Type Description In Input Dynamic Vector Unclamped input value Min Input Dynamic Vector Minimum value Max Input Dynamic Vector Maximum value Out Output Dynamic Vector Clamped output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Clamp_float4(float4 In, float4 Min, float4 Max, out float4 Out) { Out = clamp(In, Min, Max); }","title":"Clamp Node"},{"location":"ShaderGraph/Clamp-Node/#clamp-node","text":"","title":"Clamp Node"},{"location":"ShaderGraph/Clamp-Node/#description","text":"Returns the input In clamped between the minimum and maximum values defined by inputs Min and Max respectively.","title":"Description"},{"location":"ShaderGraph/Clamp-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Unclamped input value Min Input Dynamic Vector Minimum value Max Input Dynamic Vector Maximum value Out Output Dynamic Vector Clamped output value","title":"Ports"},{"location":"ShaderGraph/Clamp-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Clamp_float4(float4 In, float4 Min, float4 Max, out float4 Out) { Out = clamp(In, Min, Max); }","title":"Generated Code Example"},{"location":"ShaderGraph/CodeFunctionNode-Port-Types/","text":"Description When using CodeFunctionNode you are able to define Ports of any type available in Shader Graph . For a full list of available types see Data Types . Defining Ports using CodeFunctionNode requires using specific types when defining a port via a method argument. For more information on how to create Nodes using CodeFunctionNode see Custom Nodes with CodeFunctionNode . Below is a full list including the Data Type they map to. Port Types Argument Type Data Type Boolean Boolean Vector1 Vector1 Vector2 Vector2 Vector3 Vector3 Vector4 Vector4 Color Vector4 (with a ColorRGBA Port Binding ) ColorRGBA Vector4 (with a ColorRGBA Port Binding ) ColorRGB Vector3 (with a ColorRGB Port Binding ) Texture2D Texture2D Texture2DArray Texture2DArray Texture3D Texture3D Cubemap Cubemap SamplerState SamplerState DynamicDimensionVector DynamicVector Matrix4x4 Matrix4 Matrix3x3 Matrix3 Matrix2x2 Matrix2 DynamicDimensionMatrix DynamicMatrix","title":"CodeFunctionNode Port Types"},{"location":"ShaderGraph/CodeFunctionNode-Port-Types/#description","text":"When using CodeFunctionNode you are able to define Ports of any type available in Shader Graph . For a full list of available types see Data Types . Defining Ports using CodeFunctionNode requires using specific types when defining a port via a method argument. For more information on how to create Nodes using CodeFunctionNode see Custom Nodes with CodeFunctionNode . Below is a full list including the Data Type they map to.","title":"Description"},{"location":"ShaderGraph/CodeFunctionNode-Port-Types/#port-types","text":"Argument Type Data Type Boolean Boolean Vector1 Vector1 Vector2 Vector2 Vector3 Vector3 Vector4 Vector4 Color Vector4 (with a ColorRGBA Port Binding ) ColorRGBA Vector4 (with a ColorRGBA Port Binding ) ColorRGB Vector3 (with a ColorRGB Port Binding ) Texture2D Texture2D Texture2DArray Texture2DArray Texture3D Texture3D Cubemap Cubemap SamplerState SamplerState DynamicDimensionVector DynamicVector Matrix4x4 Matrix4 Matrix3x3 Matrix3 Matrix2x2 Matrix2 DynamicDimensionMatrix DynamicMatrix","title":"Port Types"},{"location":"ShaderGraph/CodeFunctionNode.Binding/","text":"Enumeration Description When using CodeFunctionNode you are able to define Ports with any Bindings that available in Shader Graph . For a full list of available Bindings see Port Bindings . When using CodeFunctionNode Bindings are defined using SlotAttribute . For more information on how to create Nodes using CodeFunctionNode see Custom Nodes with CodeFunctionNode . Below is a full list including the Port Bindings they map to. Properties SlotAttribute Binding Port Binding ObjectSpaceNormal Normal (in object space) ObjectSpaceTangent Tangent (in object space) ObjectSpaceBitangent Bitangent (in object space) ObjectSpacePosition Position (in object space) ViewSpaceNormal Normal (in view space) ViewSpaceTangent Tangent (in view space) ViewSpaceBitangent Bitangent (in view space) ViewSpacePosition Position (in view space) WorldSpaceNormal Normal (in world space) WorldSpaceTangent Tangent (in world space) WorldSpaceBitangent Bitangent (in world space) WorldSpacePosition Position (in world space) TangentSpaceNormal Normal (in tangent space) TangentSpaceTangent Tangent (in tangent space) TangentSpaceBitangent Bitangent (in tangent space) TangentSpacePosition Position (in tangent space) MeshUV0 UV (channel 0) MeshUV1 UV (channel 1) MeshUV2 UV (channel 2) MeshUV3 UV (channel 3) ScreenPosition Screen Position (Default mode) ObjectSpaceViewDirection View Direction (in object space) ViewSpaceViewDirection View Direction (in view space) WorldSpaceViewDirection View Direction (in world space) TangentSpaceViewDirection View Direction (in tangent space) VertexColor Vertex Color","title":"CodeFunctionNode.Binding"},{"location":"ShaderGraph/CodeFunctionNode.Binding/#enumeration","text":"","title":"Enumeration"},{"location":"ShaderGraph/CodeFunctionNode.Binding/#description","text":"When using CodeFunctionNode you are able to define Ports with any Bindings that available in Shader Graph . For a full list of available Bindings see Port Bindings . When using CodeFunctionNode Bindings are defined using SlotAttribute . For more information on how to create Nodes using CodeFunctionNode see Custom Nodes with CodeFunctionNode . Below is a full list including the Port Bindings they map to.","title":"Description"},{"location":"ShaderGraph/CodeFunctionNode.Binding/#properties","text":"SlotAttribute Binding Port Binding ObjectSpaceNormal Normal (in object space) ObjectSpaceTangent Tangent (in object space) ObjectSpaceBitangent Bitangent (in object space) ObjectSpacePosition Position (in object space) ViewSpaceNormal Normal (in view space) ViewSpaceTangent Tangent (in view space) ViewSpaceBitangent Bitangent (in view space) ViewSpacePosition Position (in view space) WorldSpaceNormal Normal (in world space) WorldSpaceTangent Tangent (in world space) WorldSpaceBitangent Bitangent (in world space) WorldSpacePosition Position (in world space) TangentSpaceNormal Normal (in tangent space) TangentSpaceTangent Tangent (in tangent space) TangentSpaceBitangent Bitangent (in tangent space) TangentSpacePosition Position (in tangent space) MeshUV0 UV (channel 0) MeshUV1 UV (channel 1) MeshUV2 UV (channel 2) MeshUV3 UV (channel 3) ScreenPosition Screen Position (Default mode) ObjectSpaceViewDirection View Direction (in object space) ViewSpaceViewDirection View Direction (in view space) WorldSpaceViewDirection View Direction (in world space) TangentSpaceViewDirection View Direction (in tangent space) VertexColor Vertex Color","title":"Properties"},{"location":"ShaderGraph/CodeFunctionNode.GetFunctionToConvert/","text":"protected abstract MethodInfo GetFunctionToConvert() Returns A MethodInfo of a class to convert to a shader function. Description Defines which method within the class should be converted to a shader function. Use Type.GetMethodInfo to convert a method of return type string to a MethodInfo to return. The referenced class should define Ports via SlotAttribute . For more information on how to create Nodes using CodeFunctionNode see Custom Nodes with CodeFunctionNode .","title":"CodeFunctionNode.GetFunctionToConvert"},{"location":"ShaderGraph/CodeFunctionNode.GetFunctionToConvert/#protected-abstract-methodinfo-getfunctiontoconvert","text":"","title":"protected abstract MethodInfo GetFunctionToConvert()"},{"location":"ShaderGraph/CodeFunctionNode.GetFunctionToConvert/#returns","text":"A MethodInfo of a class to convert to a shader function.","title":"Returns"},{"location":"ShaderGraph/CodeFunctionNode.GetFunctionToConvert/#description","text":"Defines which method within the class should be converted to a shader function. Use Type.GetMethodInfo to convert a method of return type string to a MethodInfo to return. The referenced class should define Ports via SlotAttribute . For more information on how to create Nodes using CodeFunctionNode see Custom Nodes with CodeFunctionNode .","title":"Description"},{"location":"ShaderGraph/CodeFunctionNode.SlotAttribute/","text":"Attribute in CodeFunctionNode Description Defines an argument to a method as a Port for a Node . The type of the Port is defined by the argument type. The SlotAttribute can also be used to apply a Port Binding to the Port or define its default value. Properties Property Type Description slotId int Index for the Port . Must be unique. binding Binding Defines the Port Binding . Set to None for no binding. hidden bool If true the Port will be hidden. defaultValue Vector4 Default value for the Port .","title":"CodeFunctionNode.SlotAttribute"},{"location":"ShaderGraph/CodeFunctionNode.SlotAttribute/#attribute-in-codefunctionnode","text":"","title":"Attribute in CodeFunctionNode"},{"location":"ShaderGraph/CodeFunctionNode.SlotAttribute/#description","text":"Defines an argument to a method as a Port for a Node . The type of the Port is defined by the argument type. The SlotAttribute can also be used to apply a Port Binding to the Port or define its default value.","title":"Description"},{"location":"ShaderGraph/CodeFunctionNode.SlotAttribute/#properties","text":"Property Type Description slotId int Index for the Port . Must be unique. binding Binding Defines the Port Binding . Set to None for no binding. hidden bool If true the Port will be hidden. defaultValue Vector4 Default value for the Port .","title":"Properties"},{"location":"ShaderGraph/CodeFunctionNode/","text":"Description CodeFunctionNode is an abstract Node class developed for simple creation of custom Nodes that generate shader functions in Shader Graph . For more information on how to create Nodes using CodeFunctionNode see Custom Nodes with CodeFunctionNode . Contents Port Types SlotAttribute Binding GetFunctionToConvert","title":"CodeFunctionNode"},{"location":"ShaderGraph/CodeFunctionNode/#description","text":"CodeFunctionNode is an abstract Node class developed for simple creation of custom Nodes that generate shader functions in Shader Graph . For more information on how to create Nodes using CodeFunctionNode see Custom Nodes with CodeFunctionNode .","title":"Description"},{"location":"ShaderGraph/CodeFunctionNode/#contents","text":"Port Types SlotAttribute Binding GetFunctionToConvert","title":"Contents"},{"location":"ShaderGraph/Color-Mask-Node/","text":"Color Mask Node Description Creates a mask from values in input In equal to input Mask Color . Input Range can be used to define a wider range of values around input Mask Color to create the mask. Colors within this range will return 1, otherwise the node will return 0. Input Fuzziness can be used to soften the edges around the selection similar to anti-aliasing. Ports Name Direction Type Binding Description In Input Vector 3 None Input value. Mask Color Input Vector 3 Color Color to use for mask. Range Input Vector 1 None Select colors within this range from input Mask Color . Fuzziness Input Vector 1 None Feather edges around selection. Higher values result in a softer selection mask. Out Output Vector 1 None Output mask value. Generated Code Example The following example code represents one possible outcome of this node. void Unity_ColorMask_float(float3 In, float3 MaskColor, float Range, float Fuzziness, out float4 Out) { float Distance = distance(MaskColor, In); Out = saturate(1 - (Distance - Range) / max(Fuzziness, 1e-5)); }","title":"Color Mask Node"},{"location":"ShaderGraph/Color-Mask-Node/#color-mask-node","text":"","title":"Color Mask Node"},{"location":"ShaderGraph/Color-Mask-Node/#description","text":"Creates a mask from values in input In equal to input Mask Color . Input Range can be used to define a wider range of values around input Mask Color to create the mask. Colors within this range will return 1, otherwise the node will return 0. Input Fuzziness can be used to soften the edges around the selection similar to anti-aliasing.","title":"Description"},{"location":"ShaderGraph/Color-Mask-Node/#ports","text":"Name Direction Type Binding Description In Input Vector 3 None Input value. Mask Color Input Vector 3 Color Color to use for mask. Range Input Vector 1 None Select colors within this range from input Mask Color . Fuzziness Input Vector 1 None Feather edges around selection. Higher values result in a softer selection mask. Out Output Vector 1 None Output mask value.","title":"Ports"},{"location":"ShaderGraph/Color-Mask-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_ColorMask_float(float3 In, float3 MaskColor, float Range, float Fuzziness, out float4 Out) { float Distance = distance(MaskColor, In); Out = saturate(1 - (Distance - Range) / max(Fuzziness, 1e-5)); }","title":"Generated Code Example"},{"location":"ShaderGraph/Color-Node/","text":"Color Node Description Defines a constant Vector 4 value in the shader using a Color field. Can be converted to a Color type Property via the Node's context menu. The value of the Mode parameter will also respected when generating the Property . Ports Name Direction Type Binding Description Out Output Vector 4 None Output value Controls Name Type Options Description Color Defines the output value. Mode Dropdown Default, HDR Sets properties of the Color field Generated Code Example The following example code represents one possible outcome of this node. float4 _Color = IsGammaSpace() ? float4(1, 2, 3, 4) : float4(SRGBToLinear(float3(1, 2, 3)), 4);","title":"Color Node"},{"location":"ShaderGraph/Color-Node/#color-node","text":"","title":"Color Node"},{"location":"ShaderGraph/Color-Node/#description","text":"Defines a constant Vector 4 value in the shader using a Color field. Can be converted to a Color type Property via the Node's context menu. The value of the Mode parameter will also respected when generating the Property .","title":"Description"},{"location":"ShaderGraph/Color-Node/#ports","text":"Name Direction Type Binding Description Out Output Vector 4 None Output value","title":"Ports"},{"location":"ShaderGraph/Color-Node/#controls","text":"Name Type Options Description Color Defines the output value. Mode Dropdown Default, HDR Sets properties of the Color field","title":"Controls"},{"location":"ShaderGraph/Color-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. float4 _Color = IsGammaSpace() ? float4(1, 2, 3, 4) : float4(SRGBToLinear(float3(1, 2, 3)), 4);","title":"Generated Code Example"},{"location":"ShaderGraph/Colorspace-Conversion-Node/","text":"Colorspace Conversion Node Description Returns the result of converting the value of input In from one colorspace space to another. The spaces to transform from and to are defined by the values of the dropdowns on the node. Ports Name Direction Type Description In Input Vector 3 Input value Out Output Vector 3 Output value Controls Name Type Options Description From Dropdown RGB, Linear, HSV Selects the colorspace to convert from To Dropdown RGB, Linear, HSV Selects the colorspace to convert to Generated Code Example The following example code represents one possible outcome of this node per from/to permutation. RGB > RGB void Unity_ColorspaceConversion_RGB_RGB_float(float3 In, out float3 Out) { Out = In; } RGB > Linear void Unity_ColorspaceConversion_RGB_RGB_float(float3 In, out float3 Out) { float3 linearRGBLo = In / 12.92;; float3 linearRGBHi = pow(max(abs((In + 0.055) / 1.055), 1.192092896e-07), float3(2.4, 2.4, 2.4)); Out = float3(In <= 0.04045) ? linearRGBLo : linearRGBHi; } RGB > HSV void Unity_ColorspaceConversion_RGB_RGB_float(float3 In, out float3 Out) { float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); float4 P = lerp(float4(In.bg, K.wz), float4(In.gb, K.xy), step(In.b, In.g)); float4 Q = lerp(float4(P.xyw, In.r), float4(In.r, P.yzx), step(P.x, In.r)); float D = Q.x - min(Q.w, Q.y); float E = 1e-10; Out = float3(abs(Q.z + (Q.w - Q.y)/(6.0 * D + E)), D / (Q.x + E), Q.x); } Linear > RGB void Unity_ColorspaceConversion_RGB_RGB_float(float3 In, out float3 Out) { float3 sRGBLo = In * 12.92; float3 sRGBHi = (pow(max(abs(In), 1.192092896e-07), float3(1.0 / 2.4, 1.0 / 2.4, 1.0 / 2.4)) * 1.055) - 0.055; Out = float3(In <= 0.0031308) ? sRGBLo : sRGBHi; } Linear > Linear void Unity_ColorspaceConversion_RGB_RGB_float(float3 In, out float3 Out) { Out = In; } Linear > HSV void Unity_ColorspaceConversion_RGB_RGB_float(float3 In, out float3 Out) { float3 sRGBLo = In * 12.92; float3 sRGBHi = (pow(max(abs(In), 1.192092896e-07), float3(1.0 / 2.4, 1.0 / 2.4, 1.0 / 2.4)) * 1.055) - 0.055; float3 Linear = float3(In <= 0.0031308) ? sRGBLo : sRGBHi; float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); float4 P = lerp(float4(Linear.bg, K.wz), float4(Linear.gb, K.xy), step(Linear.b, Linear.g)); float4 Q = lerp(float4(P.xyw, Linear.r), float4(Linear.r, P.yzx), step(P.x, Linear.r)); float D = Q.x - min(Q.w, Q.y); float E = 1e-10; Out = float3(abs(Q.z + (Q.w - Q.y)/(6.0 * D + E)), D / (Q.x + E), Q.x); } HSV > RGB void Unity_ColorspaceConversion_RGB_RGB_float(float3 In, out float3 Out) { float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); float3 P = abs(frac(In.xxx + K.xyz) * 6.0 - K.www); Out = In.z * lerp(K.xxx, saturate(P - K.xxx), In.y); } HSV > Linear void Unity_ColorspaceConversion_RGB_RGB_float(float3 In, out float3 Out) { float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); float3 P = abs(frac(In.xxx + K.xyz) * 6.0 - K.www); float3 RGB = In.z * lerp(K.xxx, saturate(P - K.xxx), In.y); float3 linearRGBLo = RGB / 12.92; float3 linearRGBHi = pow(max(abs((RGB + 0.055) / 1.055), 1.192092896e-07), float3(2.4, 2.4, 2.4)); Out = float3(RGB <= 0.04045) ? linearRGBLo : linearRGBHi; } HSV > HSV void Unity_ColorspaceConversion_RGB_RGB_float(float3 In, out float3 Out) { Out = In; }","title":"Colorspace Conversion Node"},{"location":"ShaderGraph/Colorspace-Conversion-Node/#colorspace-conversion-node","text":"","title":"Colorspace Conversion Node"},{"location":"ShaderGraph/Colorspace-Conversion-Node/#description","text":"Returns the result of converting the value of input In from one colorspace space to another. The spaces to transform from and to are defined by the values of the dropdowns on the node.","title":"Description"},{"location":"ShaderGraph/Colorspace-Conversion-Node/#ports","text":"Name Direction Type Description In Input Vector 3 Input value Out Output Vector 3 Output value","title":"Ports"},{"location":"ShaderGraph/Colorspace-Conversion-Node/#controls","text":"Name Type Options Description From Dropdown RGB, Linear, HSV Selects the colorspace to convert from To Dropdown RGB, Linear, HSV Selects the colorspace to convert to","title":"Controls"},{"location":"ShaderGraph/Colorspace-Conversion-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node per from/to permutation. RGB > RGB void Unity_ColorspaceConversion_RGB_RGB_float(float3 In, out float3 Out) { Out = In; } RGB > Linear void Unity_ColorspaceConversion_RGB_RGB_float(float3 In, out float3 Out) { float3 linearRGBLo = In / 12.92;; float3 linearRGBHi = pow(max(abs((In + 0.055) / 1.055), 1.192092896e-07), float3(2.4, 2.4, 2.4)); Out = float3(In <= 0.04045) ? linearRGBLo : linearRGBHi; } RGB > HSV void Unity_ColorspaceConversion_RGB_RGB_float(float3 In, out float3 Out) { float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); float4 P = lerp(float4(In.bg, K.wz), float4(In.gb, K.xy), step(In.b, In.g)); float4 Q = lerp(float4(P.xyw, In.r), float4(In.r, P.yzx), step(P.x, In.r)); float D = Q.x - min(Q.w, Q.y); float E = 1e-10; Out = float3(abs(Q.z + (Q.w - Q.y)/(6.0 * D + E)), D / (Q.x + E), Q.x); } Linear > RGB void Unity_ColorspaceConversion_RGB_RGB_float(float3 In, out float3 Out) { float3 sRGBLo = In * 12.92; float3 sRGBHi = (pow(max(abs(In), 1.192092896e-07), float3(1.0 / 2.4, 1.0 / 2.4, 1.0 / 2.4)) * 1.055) - 0.055; Out = float3(In <= 0.0031308) ? sRGBLo : sRGBHi; } Linear > Linear void Unity_ColorspaceConversion_RGB_RGB_float(float3 In, out float3 Out) { Out = In; } Linear > HSV void Unity_ColorspaceConversion_RGB_RGB_float(float3 In, out float3 Out) { float3 sRGBLo = In * 12.92; float3 sRGBHi = (pow(max(abs(In), 1.192092896e-07), float3(1.0 / 2.4, 1.0 / 2.4, 1.0 / 2.4)) * 1.055) - 0.055; float3 Linear = float3(In <= 0.0031308) ? sRGBLo : sRGBHi; float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); float4 P = lerp(float4(Linear.bg, K.wz), float4(Linear.gb, K.xy), step(Linear.b, Linear.g)); float4 Q = lerp(float4(P.xyw, Linear.r), float4(Linear.r, P.yzx), step(P.x, Linear.r)); float D = Q.x - min(Q.w, Q.y); float E = 1e-10; Out = float3(abs(Q.z + (Q.w - Q.y)/(6.0 * D + E)), D / (Q.x + E), Q.x); } HSV > RGB void Unity_ColorspaceConversion_RGB_RGB_float(float3 In, out float3 Out) { float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); float3 P = abs(frac(In.xxx + K.xyz) * 6.0 - K.www); Out = In.z * lerp(K.xxx, saturate(P - K.xxx), In.y); } HSV > Linear void Unity_ColorspaceConversion_RGB_RGB_float(float3 In, out float3 Out) { float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); float3 P = abs(frac(In.xxx + K.xyz) * 6.0 - K.www); float3 RGB = In.z * lerp(K.xxx, saturate(P - K.xxx), In.y); float3 linearRGBLo = RGB / 12.92; float3 linearRGBHi = pow(max(abs((RGB + 0.055) / 1.055), 1.192092896e-07), float3(2.4, 2.4, 2.4)); Out = float3(RGB <= 0.04045) ? linearRGBLo : linearRGBHi; } HSV > HSV void Unity_ColorspaceConversion_RGB_RGB_float(float3 In, out float3 Out) { Out = In; }","title":"Generated Code Example"},{"location":"ShaderGraph/Combine-Node/","text":"Combine Node Description Creates new vectors from the four inputs R , G , B and A . Output RGBA is a Vector 4 composed of inputs R , G , B and A . Output RGB is a Vector 3 composed of inputs R , G and B . Output RG is a Vector 2 composed of inputs R and G . Ports Name Direction Type Binding Description R Input Vector 1 None Defines red channel of output G Input Vector 1 None Defines green channel of output B Input Vector 1 None Defines blue channel of output A Input Vector 1 None Defines alpha channel of output RGBA Output Vector 4 None Output value as Vector 4 RGB Output Vector 3 None Output value as Vector 3 RG Output Vector 2 None Output value as Vector 2 Generated Code Example The following example code represents one possible outcome of this node. void Unity_Combine_float(float R, float G, float B, float A, out float4 RGBA, out float3 RGB, out float2 RG) { RGBA = float4(R, G, B, A); RGB = float3(R, G, B); RG = float2(R, G); }","title":"Combine Node"},{"location":"ShaderGraph/Combine-Node/#combine-node","text":"","title":"Combine Node"},{"location":"ShaderGraph/Combine-Node/#description","text":"Creates new vectors from the four inputs R , G , B and A . Output RGBA is a Vector 4 composed of inputs R , G , B and A . Output RGB is a Vector 3 composed of inputs R , G and B . Output RG is a Vector 2 composed of inputs R and G .","title":"Description"},{"location":"ShaderGraph/Combine-Node/#ports","text":"Name Direction Type Binding Description R Input Vector 1 None Defines red channel of output G Input Vector 1 None Defines green channel of output B Input Vector 1 None Defines blue channel of output A Input Vector 1 None Defines alpha channel of output RGBA Output Vector 4 None Output value as Vector 4 RGB Output Vector 3 None Output value as Vector 3 RG Output Vector 2 None Output value as Vector 2","title":"Ports"},{"location":"ShaderGraph/Combine-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Combine_float(float R, float G, float B, float A, out float4 RGBA, out float3 RGB, out float2 RG) { RGBA = float4(R, G, B, A); RGB = float3(R, G, B); RG = float2(R, G); }","title":"Generated Code Example"},{"location":"ShaderGraph/Comparison-Node/","text":"Comparison Node Description Compares the two input values A and B based on the condition selected on the dropdown. This is often used as an input to the Branch Node . Ports Name Direction Type Binding Description A Input Vector 1 None First input value B Input Vector 1 None Second input value Out Output Boolean None Output value Controls Name Type Options Description Dropdown Equal, NotEqual, Less, LessOrEqual, Greater, GreaterOrEqual Condition for comparison Generated Code Example The following example code represents one possible outcome of this node per comparison type. Equal void Unity_Comparison_Equal_float(float A, float B, out float Out) { Out = A == B ? 1 : 0; } NotEqual void Unity_Comparison_NotEqual_float(float A, float B, out float Out) { Out = A != B ? 1 : 0; } Less void Unity_Comparison_Less_float(float A, float B, out float Out) { Out = A < B ? 1 : 0; } LessOrEqual void Unity_Comparison_LessOrEqual_float(float A, float B, out float Out) { Out = A <= B ? 1 : 0; } Greater void Unity_Comparison_Greater_float(float A, float B, out float Out) { Out = A > B ? 1 : 0; } GreaterOrEqual void Unity_Comparison_GreaterOrEqual_float(float A, float B, out float Out) { Out = A >= B ? 1 : 0; }","title":"Comparison Node"},{"location":"ShaderGraph/Comparison-Node/#comparison-node","text":"","title":"Comparison Node"},{"location":"ShaderGraph/Comparison-Node/#description","text":"Compares the two input values A and B based on the condition selected on the dropdown. This is often used as an input to the Branch Node .","title":"Description"},{"location":"ShaderGraph/Comparison-Node/#ports","text":"Name Direction Type Binding Description A Input Vector 1 None First input value B Input Vector 1 None Second input value Out Output Boolean None Output value","title":"Ports"},{"location":"ShaderGraph/Comparison-Node/#controls","text":"Name Type Options Description Dropdown Equal, NotEqual, Less, LessOrEqual, Greater, GreaterOrEqual Condition for comparison","title":"Controls"},{"location":"ShaderGraph/Comparison-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node per comparison type. Equal void Unity_Comparison_Equal_float(float A, float B, out float Out) { Out = A == B ? 1 : 0; } NotEqual void Unity_Comparison_NotEqual_float(float A, float B, out float Out) { Out = A != B ? 1 : 0; } Less void Unity_Comparison_Less_float(float A, float B, out float Out) { Out = A < B ? 1 : 0; } LessOrEqual void Unity_Comparison_LessOrEqual_float(float A, float B, out float Out) { Out = A <= B ? 1 : 0; } Greater void Unity_Comparison_Greater_float(float A, float B, out float Out) { Out = A > B ? 1 : 0; } GreaterOrEqual void Unity_Comparison_GreaterOrEqual_float(float A, float B, out float Out) { Out = A >= B ? 1 : 0; }","title":"Generated Code Example"},{"location":"ShaderGraph/Constant-Node/","text":"Constant Node Description Defines a Vector 1 of a mathematical constant value in the shader. Ports Name Direction Type Binding Description Out Output Vector 1 None Output value Controls Name Type Options Description Mode Dropdown PI, TAU, PHI, E, SQRT2 Sets output constant value Generated Code Example The following example code represents one possible outcome of this node per constant type. PI float _Constant_PI = 3.1415926; TAU float _Constant_TAU = 6.28318530; PHI float _Constant_PHI = 1.618034; E float _Constant_E = 2.718282; SQRT2 float _Constant_SQRT2 = 1.414214;","title":"Constant Node"},{"location":"ShaderGraph/Constant-Node/#constant-node","text":"","title":"Constant Node"},{"location":"ShaderGraph/Constant-Node/#description","text":"Defines a Vector 1 of a mathematical constant value in the shader.","title":"Description"},{"location":"ShaderGraph/Constant-Node/#ports","text":"Name Direction Type Binding Description Out Output Vector 1 None Output value","title":"Ports"},{"location":"ShaderGraph/Constant-Node/#controls","text":"Name Type Options Description Mode Dropdown PI, TAU, PHI, E, SQRT2 Sets output constant value","title":"Controls"},{"location":"ShaderGraph/Constant-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node per constant type. PI float _Constant_PI = 3.1415926; TAU float _Constant_TAU = 6.28318530; PHI float _Constant_PHI = 1.618034; E float _Constant_E = 2.718282; SQRT2 float _Constant_SQRT2 = 1.414214;","title":"Generated Code Example"},{"location":"ShaderGraph/Contrast-Node/","text":"Contrast Node Description Adjusts the contrast of input In by the amount of input Contrast . A Contrast value of 1 will return the input unaltered. A Contrast value of 0 will return the midpoint of the input. Ports Name Direction Type Binding Description In Input Vector 3 None Input value Contrast Input Vector 1 None Contrast value Out Output Vector 3 None Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Contrast_float(float3 In, float Contrast, out float3 Out) { float midpoint = pow(0.5, 2.2); Out = (In - midpoint) * Contrast + midpoint; }","title":"Contrast Node"},{"location":"ShaderGraph/Contrast-Node/#contrast-node","text":"","title":"Contrast Node"},{"location":"ShaderGraph/Contrast-Node/#description","text":"Adjusts the contrast of input In by the amount of input Contrast . A Contrast value of 1 will return the input unaltered. A Contrast value of 0 will return the midpoint of the input.","title":"Description"},{"location":"ShaderGraph/Contrast-Node/#ports","text":"Name Direction Type Binding Description In Input Vector 3 None Input value Contrast Input Vector 1 None Contrast value Out Output Vector 3 None Output value","title":"Ports"},{"location":"ShaderGraph/Contrast-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Contrast_float(float3 In, float Contrast, out float3 Out) { float midpoint = pow(0.5, 2.2); Out = (In - midpoint) * Contrast + midpoint; }","title":"Generated Code Example"},{"location":"ShaderGraph/Cosine-Node/","text":"Cosine Node Description Returns the cosine of the value of input In . Ports Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Cosine_float4(float4 In, out float4 Out) { Out = cos(In); }","title":"Cosine Node"},{"location":"ShaderGraph/Cosine-Node/#cosine-node","text":"","title":"Cosine Node"},{"location":"ShaderGraph/Cosine-Node/#description","text":"Returns the cosine of the value of input In .","title":"Description"},{"location":"ShaderGraph/Cosine-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Cosine-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Cosine_float4(float4 In, out float4 Out) { Out = cos(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Create-Node-Menu/","text":"Description The Create Node Menu is how to create Nodes in Shader Graph . To open the Create Node Menu either right click on the workspace in the Shader Graph Window and select Create Node or press spacebar. At the top of the Create Node Menu is a search bar. You can search for a node by typing any part of its name in the search field. All Nodes that are available in Shader Graph are listed in the Create Node Menu categorised by their function. Any user created Sub-graphs are also available in the Create Node Menu under Sub-graph Assets . Selecting a Node in the Create Node Menu will add it to the workspace. Contextual Create Node Menu A contextual Create Node Menu filters the Nodes available to show only those that use the Data Type of a selected edge. It will list every available Port on these Nodes that matches that Data Type . You can open a contextual Create Node Menu by dragging an Edge from a Port with left mouse button and releasing it in an empty area of the workspace.","title":"Create Node Menu"},{"location":"ShaderGraph/Create-Node-Menu/#description","text":"The Create Node Menu is how to create Nodes in Shader Graph . To open the Create Node Menu either right click on the workspace in the Shader Graph Window and select Create Node or press spacebar. At the top of the Create Node Menu is a search bar. You can search for a node by typing any part of its name in the search field. All Nodes that are available in Shader Graph are listed in the Create Node Menu categorised by their function. Any user created Sub-graphs are also available in the Create Node Menu under Sub-graph Assets . Selecting a Node in the Create Node Menu will add it to the workspace.","title":"Description"},{"location":"ShaderGraph/Create-Node-Menu/#contextual-create-node-menu","text":"A contextual Create Node Menu filters the Nodes available to show only those that use the Data Type of a selected edge. It will list every available Port on these Nodes that matches that Data Type . You can open a contextual Create Node Menu by dragging an Edge from a Port with left mouse button and releasing it in an empty area of the workspace.","title":"Contextual Create Node Menu"},{"location":"ShaderGraph/Cross-Product-Node/","text":"Cross Product Node Description Returns the cross product of the values of the inputs A and B . The cross product of two vectors results in a third vector which is perpendicular to the two input vectors. The result's magnitude is equal to the magnitudes of the two inputs multiplied together and then multiplied by the sine of the angle between the inputs. You can determine the direction of the result vector using the \"left hand rule\". Ports Name Direction Type Description A Input Vector 3 First input value B Input Vector 3 Second input value Out Output Vector 3 Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_CrossProduct_float(float3 A, float3 B, out float3 Out) { Out = cross(A, B); }","title":"Cross Product Node"},{"location":"ShaderGraph/Cross-Product-Node/#cross-product-node","text":"","title":"Cross Product Node"},{"location":"ShaderGraph/Cross-Product-Node/#description","text":"Returns the cross product of the values of the inputs A and B . The cross product of two vectors results in a third vector which is perpendicular to the two input vectors. The result's magnitude is equal to the magnitudes of the two inputs multiplied together and then multiplied by the sine of the angle between the inputs. You can determine the direction of the result vector using the \"left hand rule\".","title":"Description"},{"location":"ShaderGraph/Cross-Product-Node/#ports","text":"Name Direction Type Description A Input Vector 3 First input value B Input Vector 3 Second input value Out Output Vector 3 Output value","title":"Ports"},{"location":"ShaderGraph/Cross-Product-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_CrossProduct_float(float3 A, float3 B, out float3 Out) { Out = cross(A, B); }","title":"Generated Code Example"},{"location":"ShaderGraph/Cubemap-Asset-Node/","text":"Cubemap Asset Node Description Defines a constant Cubemap Asset for use in the shader. To sample the Cubemap Asset it should be used in conjunction with a Sample Cubemap Node . When using a separate Cubemap Asset Node you can sample a Cubemap twice, with different parameters, without defining the Cubemap itself twice. Ports Name Direction Type Binding Description Out Output Cubemap None Output value Controls Name Type Options Description Object Field (Cubemap) Defines the cubemap asset from the project.","title":"Cubemap Asset Node"},{"location":"ShaderGraph/Cubemap-Asset-Node/#cubemap-asset-node","text":"","title":"Cubemap Asset Node"},{"location":"ShaderGraph/Cubemap-Asset-Node/#description","text":"Defines a constant Cubemap Asset for use in the shader. To sample the Cubemap Asset it should be used in conjunction with a Sample Cubemap Node . When using a separate Cubemap Asset Node you can sample a Cubemap twice, with different parameters, without defining the Cubemap itself twice.","title":"Description"},{"location":"ShaderGraph/Cubemap-Asset-Node/#ports","text":"Name Direction Type Binding Description Out Output Cubemap None Output value","title":"Ports"},{"location":"ShaderGraph/Cubemap-Asset-Node/#controls","text":"Name Type Options Description Object Field (Cubemap) Defines the cubemap asset from the project.","title":"Controls"},{"location":"ShaderGraph/Custom-Nodes-With-CodeFunctionNode/","text":"Custom Nodes With the recent release of Shader Graph it is now easier than ever to create custom shaders in Unity. However, regardless of how many different Nodes we offer by default, we can\u2019t possibly cater for everything you might want to make. For this reason we have developed a Custom Node API for you to use to make new Nodes in C#. This allows you to extend Shader Graph to suit your needs. In this article we will take a look at one of the ways you can accomplish this. It is the simplest way to create custom Nodes that create shader functions. We call it the Code Function Node . Let\u2019s take a look at how to create a new Node using this method. Lets start by creating a new C# script. For this example I have named the script MyCustomNode . To use the Code Function Node API you need to include (or add the class to.md) the namespace UnityEditor.ShaderGraph and inherit from the base class CodeFunctionNode . The first thing you will notice is that MyCustomNode is highlighted with an error. If we hover over the message we see that we need to implement an inherited member called GetFunctionToConvert . The base class CodeFunctionNode handles most of the work that needs to be done to tell the Shader Graph how to process this Node but we still need to tell it what the resulting function should be, this is how we will do this. The method GetFunctionToConvert uses Reflection to convert another method into an instance of MethodInfo that CodeFunctionNode can convert for use in Shader Graph . This simply allows us to write the shader function we want in a more intuitive way. For more information on Reflection see: Reflection (C#.md) Add the namespace System.Reflection and the override function GetFunctionToConvert as shown in the image below. Note the string that reads MyCustomFunction , this will be the name of the function that is written into the final shader. This can be named whatever you wish to suit the function you are writing and can be anything that doesn\u2019t begin with a numeric character, but for the rest of this article we will assume its name is MyCustomFunction . Now our script errors are resolved we can start working on the functionality of our new Node ! Before we continue we should name it. To do this add a public constructor for the class with no arguments. In it, set the variable name to a string that contains the title of your Node . This will be displayed in the title bar of the Node when it appears in a graph. For this example we will call the Node My Custom Node . Next we will define the Node\u2019s function itself. If you are familiar with Reflection you will notice that the method GetFunctionToConvert is attempting to access a method in this class called MyCustomFunction . This is the method that will define the shader function itself. Lets create a new static method of return type string with the same name as the string in the method GetFunctionToConvert . In the case of this tutorial that will be MyCustomFunction . In the arguments of this method we can define what Ports we want the Node to have, these will map directly to the arguments in the final shader function. We do this by adding an argument of a type supported in Shader Graph with a Slot Attribute . For now lets add two argument of type DynamicDimensionVector called A and B and another out argument of type DynamicDimensionVector called Out . Then we will add a default Slot Attribute to each of these arguments. Each Slot Attribute needs a unique index and a Binding , which we will set to None . For a full list of Types and Bindings that are supported see the CodeFunctionNode API documentation. In this method we will define the contents of the shader function in the return string. This needs to contain the braces of the shader function and the HLSL code we wish to include. For this example lets define Out = A + B; . The method we just created should look like this: This is exactly the same C# code that is used in the Add Node that comes with Shader Graph . There is one last thing we need to do before we have a working Node . That is tell it where to appear in the Create Node Menu . We do this by adding the Title Attribute above the class. In this we define an string array that describes where it should appear in the hierarchy in the menu. The last string in this array defines what the Node should be called in the Create Node Menu . For this example we will call the Node My Custom Node and place it in the folder Custom . Now we have a working Node ! If we return to Unity, let the script compile then open Shader Graph we will see the new Node in the Create Node Menu . Create an instance of the Node in the Shader Graph . You will see it has the Ports we defined with the same names and Types as the arguments to the MyCustomFunction class. Now we can create all kinds of different Nodes by using different Port types and Bindings . The return string of the method can contain any valid HLSL in a regular Unity shader. Here is a Node that returns the smallest of the three input values: And here is a Node that inverts normals based on a Boolean input. Note in this example how the Port Normal has a Binding for WorldSpaceNormal . When there is no Edge connected to this Port it will use the mesh\u2019s world space normal vector by default. For more information see the Port Binding documentation. Also note how when using a concrete output type like Vector 3 we have to define it before we return the shader function. Now you are ready to try making Nodes in Shader Graph using Code Function Node ! But this is, of course, just the beginning. There is much more you can do in Shader Graph to customize the system. For more information see the rest of this documentation and the Scripting API .","title":"Custom Nodes"},{"location":"ShaderGraph/Custom-Nodes-With-CodeFunctionNode/#custom-nodes","text":"With the recent release of Shader Graph it is now easier than ever to create custom shaders in Unity. However, regardless of how many different Nodes we offer by default, we can\u2019t possibly cater for everything you might want to make. For this reason we have developed a Custom Node API for you to use to make new Nodes in C#. This allows you to extend Shader Graph to suit your needs. In this article we will take a look at one of the ways you can accomplish this. It is the simplest way to create custom Nodes that create shader functions. We call it the Code Function Node . Let\u2019s take a look at how to create a new Node using this method. Lets start by creating a new C# script. For this example I have named the script MyCustomNode . To use the Code Function Node API you need to include (or add the class to.md) the namespace UnityEditor.ShaderGraph and inherit from the base class CodeFunctionNode . The first thing you will notice is that MyCustomNode is highlighted with an error. If we hover over the message we see that we need to implement an inherited member called GetFunctionToConvert . The base class CodeFunctionNode handles most of the work that needs to be done to tell the Shader Graph how to process this Node but we still need to tell it what the resulting function should be, this is how we will do this. The method GetFunctionToConvert uses Reflection to convert another method into an instance of MethodInfo that CodeFunctionNode can convert for use in Shader Graph . This simply allows us to write the shader function we want in a more intuitive way. For more information on Reflection see: Reflection (C#.md) Add the namespace System.Reflection and the override function GetFunctionToConvert as shown in the image below. Note the string that reads MyCustomFunction , this will be the name of the function that is written into the final shader. This can be named whatever you wish to suit the function you are writing and can be anything that doesn\u2019t begin with a numeric character, but for the rest of this article we will assume its name is MyCustomFunction . Now our script errors are resolved we can start working on the functionality of our new Node ! Before we continue we should name it. To do this add a public constructor for the class with no arguments. In it, set the variable name to a string that contains the title of your Node . This will be displayed in the title bar of the Node when it appears in a graph. For this example we will call the Node My Custom Node . Next we will define the Node\u2019s function itself. If you are familiar with Reflection you will notice that the method GetFunctionToConvert is attempting to access a method in this class called MyCustomFunction . This is the method that will define the shader function itself. Lets create a new static method of return type string with the same name as the string in the method GetFunctionToConvert . In the case of this tutorial that will be MyCustomFunction . In the arguments of this method we can define what Ports we want the Node to have, these will map directly to the arguments in the final shader function. We do this by adding an argument of a type supported in Shader Graph with a Slot Attribute . For now lets add two argument of type DynamicDimensionVector called A and B and another out argument of type DynamicDimensionVector called Out . Then we will add a default Slot Attribute to each of these arguments. Each Slot Attribute needs a unique index and a Binding , which we will set to None . For a full list of Types and Bindings that are supported see the CodeFunctionNode API documentation. In this method we will define the contents of the shader function in the return string. This needs to contain the braces of the shader function and the HLSL code we wish to include. For this example lets define Out = A + B; . The method we just created should look like this: This is exactly the same C# code that is used in the Add Node that comes with Shader Graph . There is one last thing we need to do before we have a working Node . That is tell it where to appear in the Create Node Menu . We do this by adding the Title Attribute above the class. In this we define an string array that describes where it should appear in the hierarchy in the menu. The last string in this array defines what the Node should be called in the Create Node Menu . For this example we will call the Node My Custom Node and place it in the folder Custom . Now we have a working Node ! If we return to Unity, let the script compile then open Shader Graph we will see the new Node in the Create Node Menu . Create an instance of the Node in the Shader Graph . You will see it has the Ports we defined with the same names and Types as the arguments to the MyCustomFunction class. Now we can create all kinds of different Nodes by using different Port types and Bindings . The return string of the method can contain any valid HLSL in a regular Unity shader. Here is a Node that returns the smallest of the three input values: And here is a Node that inverts normals based on a Boolean input. Note in this example how the Port Normal has a Binding for WorldSpaceNormal . When there is no Edge connected to this Port it will use the mesh\u2019s world space normal vector by default. For more information see the Port Binding documentation. Also note how when using a concrete output type like Vector 3 we have to define it before we return the shader function. Now you are ready to try making Nodes in Shader Graph using Code Function Node ! But this is, of course, just the beginning. There is much more you can do in Shader Graph to customize the system. For more information see the rest of this documentation and the Scripting API .","title":"Custom Nodes"},{"location":"ShaderGraph/DDX-Node/","text":"DDX Node Description Returns the partial derivative of the input In with respect to the screen-space x-coordinate. This node can only be used in the pixel shader stage. Ports Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output partial derivative value Generated Code Example The following example code represents one possible outcome of this node. void Unity_DDX_float4(float4 In, out float4 Out) { Out = ddx(In); }","title":"DDX Node"},{"location":"ShaderGraph/DDX-Node/#ddx-node","text":"","title":"DDX Node"},{"location":"ShaderGraph/DDX-Node/#description","text":"Returns the partial derivative of the input In with respect to the screen-space x-coordinate. This node can only be used in the pixel shader stage.","title":"Description"},{"location":"ShaderGraph/DDX-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output partial derivative value","title":"Ports"},{"location":"ShaderGraph/DDX-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_DDX_float4(float4 In, out float4 Out) { Out = ddx(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/DDXY-Node/","text":"DDXY Node Description Returns the sum of both partial derivatives of input In , with respect to the screen-space x-coordinate and screen-space y-coordinate respectively. This node can only be used in the pixel shader stage. Ports Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output partial derivative value Generated Code Example The following example code represents one possible outcome of this node. void Unity_DDXY_float4(float4 In, out float4 Out) { Out = ddxy(In); }","title":"DDXY Node"},{"location":"ShaderGraph/DDXY-Node/#ddxy-node","text":"","title":"DDXY Node"},{"location":"ShaderGraph/DDXY-Node/#description","text":"Returns the sum of both partial derivatives of input In , with respect to the screen-space x-coordinate and screen-space y-coordinate respectively. This node can only be used in the pixel shader stage.","title":"Description"},{"location":"ShaderGraph/DDXY-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output partial derivative value","title":"Ports"},{"location":"ShaderGraph/DDXY-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_DDXY_float4(float4 In, out float4 Out) { Out = ddxy(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/DDY-Node/","text":"DDY Node Description Returns the partial derivative of the input In with respect to the screen-space y-coordinate. This node can only be used in the pixel shader stage. Ports Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output partial derivative value Generated Code Example The following example code represents one possible outcome of this node. void Unity_DDY_float4(float4 In, out float4 Out) { Out = ddy(In); }","title":"DDY Node"},{"location":"ShaderGraph/DDY-Node/#ddy-node","text":"","title":"DDY Node"},{"location":"ShaderGraph/DDY-Node/#description","text":"Returns the partial derivative of the input In with respect to the screen-space y-coordinate. This node can only be used in the pixel shader stage.","title":"Description"},{"location":"ShaderGraph/DDY-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output partial derivative value","title":"Ports"},{"location":"ShaderGraph/DDY-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_DDY_float4(float4 In, out float4 Out) { Out = ddy(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Data-Types/","text":"Data Types Description There are a number of Data Types in Shader Graph . Each Port on a Node has an associated Data Type that defines what edges can be connected to it. The Data Types have colors for usability, these colors are applied to ports and edges of that Data Type . Some Data Types have associated Property Types for exposing these values to the Inspector for Materials that use the shader. Data Types Name Color Description Vector 1 Light Blue A Vector 1 or scalar value Vector 2 Green A Vector 2 value Vector 3 Yellow A Vector 3 value Vector 4 Pink A Vector 4 value Dynamic Vector Light Blue See Dynamic Data Types below Matrix 2 Blue A Matrix 2x2 value Matrix 3 Blue A Matrix 3x3 value Matrix 4 Blue A Matrix 4x4 value Dynamic Matrix Blue See Dynamic Data Types below Dynamic Blue See Dynamic Data Types below Boolean Purple A Boolean value. Defined as a float in the generated shader Texture 2D Red A Texture 2D asset Texture 2D Array Red A Texture 2D Array asset Texture 3D Red A Texture 3D asset Cubemap Red A Cubemap asset Gradient Grey A Gradient value. Defined as a struct in the generated shader SamplerState Grey A state used for sampling a texture Promoting/Truncating All Vector types can be promoted or truncated to match any Vector type Port . This behaviour occurs only when the Port in question is not of type Dynamic Vector . When truncating, excess channels are simply removed. When promoting, the extra required channels are filled by default values. These values values are (0, 0, 0, 1). Dynamic Data Types Some Data Types are dynamic. This means a port using these Data Types can change their underlying Concrete Data Type based on what Data Type is connected to it. By default, Nodes using dynamic Data Types can only have one Concrete Data Type , meaning that once a connected edge has applied its Data Type to that port, all other Dynamic Data Type slots of that Node will apply the same Data Type . One notable exception to this is the Multiply Node which allows both Dynamic Matrix and Vector types. Dynamic Vector The Dynamic Vector type allows connected edges of any Vector type. All connected edges are automatically truncated to the type with the lowest dimension, unless the lowest dimension is 1, in which case the Vector 1 is promoted. Dynamic Matrix The Dynamic Matrix type allows connected edges of any Matrix type. All connected edges are automatically truncated to the type with the lowest dimension. Dynamic The Dynamic type is a special case. Nodes that support it must define how it is validated. In the case of the Multiply Node , it allows connections of any Vector or Matrix type, ensuring the correct multiplication is applied depending on the mix of Data Types .","title":"Data Types"},{"location":"ShaderGraph/Data-Types/#data-types","text":"","title":"Data Types"},{"location":"ShaderGraph/Data-Types/#description","text":"There are a number of Data Types in Shader Graph . Each Port on a Node has an associated Data Type that defines what edges can be connected to it. The Data Types have colors for usability, these colors are applied to ports and edges of that Data Type . Some Data Types have associated Property Types for exposing these values to the Inspector for Materials that use the shader.","title":"Description"},{"location":"ShaderGraph/Data-Types/#data-types_1","text":"Name Color Description Vector 1 Light Blue A Vector 1 or scalar value Vector 2 Green A Vector 2 value Vector 3 Yellow A Vector 3 value Vector 4 Pink A Vector 4 value Dynamic Vector Light Blue See Dynamic Data Types below Matrix 2 Blue A Matrix 2x2 value Matrix 3 Blue A Matrix 3x3 value Matrix 4 Blue A Matrix 4x4 value Dynamic Matrix Blue See Dynamic Data Types below Dynamic Blue See Dynamic Data Types below Boolean Purple A Boolean value. Defined as a float in the generated shader Texture 2D Red A Texture 2D asset Texture 2D Array Red A Texture 2D Array asset Texture 3D Red A Texture 3D asset Cubemap Red A Cubemap asset Gradient Grey A Gradient value. Defined as a struct in the generated shader SamplerState Grey A state used for sampling a texture","title":"Data Types"},{"location":"ShaderGraph/Data-Types/#promotingtruncating","text":"All Vector types can be promoted or truncated to match any Vector type Port . This behaviour occurs only when the Port in question is not of type Dynamic Vector . When truncating, excess channels are simply removed. When promoting, the extra required channels are filled by default values. These values values are (0, 0, 0, 1).","title":"Promoting/Truncating"},{"location":"ShaderGraph/Data-Types/#dynamic-data-types","text":"Some Data Types are dynamic. This means a port using these Data Types can change their underlying Concrete Data Type based on what Data Type is connected to it. By default, Nodes using dynamic Data Types can only have one Concrete Data Type , meaning that once a connected edge has applied its Data Type to that port, all other Dynamic Data Type slots of that Node will apply the same Data Type . One notable exception to this is the Multiply Node which allows both Dynamic Matrix and Vector types.","title":"Dynamic Data Types"},{"location":"ShaderGraph/Data-Types/#dynamic-vector","text":"The Dynamic Vector type allows connected edges of any Vector type. All connected edges are automatically truncated to the type with the lowest dimension, unless the lowest dimension is 1, in which case the Vector 1 is promoted.","title":"Dynamic Vector"},{"location":"ShaderGraph/Data-Types/#dynamic-matrix","text":"The Dynamic Matrix type allows connected edges of any Matrix type. All connected edges are automatically truncated to the type with the lowest dimension.","title":"Dynamic Matrix"},{"location":"ShaderGraph/Data-Types/#dynamic","text":"The Dynamic type is a special case. Nodes that support it must define how it is validated. In the case of the Multiply Node , it allows connections of any Vector or Matrix type, ensuring the correct multiplication is applied depending on the mix of Data Types .","title":"Dynamic"},{"location":"ShaderGraph/Data/","text":"Data Description This section outlines the underlying data of the Shader Graph system. For an introduction to Shader Graph see Getting Started . Contents Property Types Data Types Port Bindings Shader Stage","title":"Data"},{"location":"ShaderGraph/Data/#data","text":"","title":"Data"},{"location":"ShaderGraph/Data/#description","text":"This section outlines the underlying data of the Shader Graph system. For an introduction to Shader Graph see Getting Started .","title":"Description"},{"location":"ShaderGraph/Data/#contents","text":"Property Types Data Types Port Bindings Shader Stage","title":"Contents"},{"location":"ShaderGraph/Degrees-To-Radians-Node/","text":"Degrees To Radians Node Description Returns the value of input In converted from degrees to radians. One degree is equivalent to approximately 0.0174533 radians and a full rotation of 360 degrees is equal to 2 Pi radians. Ports Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_DegreesToRadians_float4(float4 In, out float4 Out) { Out = radians(In); }","title":"Degrees To Radians Node"},{"location":"ShaderGraph/Degrees-To-Radians-Node/#degrees-to-radians-node","text":"","title":"Degrees To Radians Node"},{"location":"ShaderGraph/Degrees-To-Radians-Node/#description","text":"Returns the value of input In converted from degrees to radians. One degree is equivalent to approximately 0.0174533 radians and a full rotation of 360 degrees is equal to 2 Pi radians.","title":"Description"},{"location":"ShaderGraph/Degrees-To-Radians-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Degrees-To-Radians-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_DegreesToRadians_float4(float4 In, out float4 Out) { Out = radians(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Dielectric-Specular-Node/","text":"Dielectric Specular Node Description Returns a Dielectric Specular F0 value for a physically based material. The material to use can be selected with the Material dropdown parameter on the Node . A Common Material type defines a range between 0.034 and 0.048 sRGB values. The value between this range can be selected with the Range parameter. This Material type should be used for various materials such as plastics and fabrics. You can use Custom material type to define your own physically based material value. The output value in this case is defined by its index of refraction. This can be set by the parameter IOR . Ports Name Direction Type Binding Description Out Output Vector 1 None Output value Controls Name Type Options Description Material Dropdown Common, RustedMetal, Water, Ice, Glass, Custom Selects the material value to output. Range Slider Controls output value for Common material type. IOR Slider Controls index of refraction for Custom material type. Generated Code Example The following example code represents one possible outcome of this node per Material mode. Common float _DielectricSpecular_Range = 0.5; float _DielectricSpecular_Out = lerp(0.034, 0.048, _DielectricSpecular_Range); RustedMetal float _DielectricSpecular_Out = 0.030; Water float _DielectricSpecular_Out = 0.020; Ice float _DielectricSpecular_Out = 0.018; Glass float _DielectricSpecular_Out = 0.040; Custom float _DielectricSpecular_IOR = 1; float _DielectricSpecular_Out = pow(_Node_IOR - 1, 2) / pow(_DielectricSpecular_IOR + 1, 2);","title":"Dielectric Specular Node"},{"location":"ShaderGraph/Dielectric-Specular-Node/#dielectric-specular-node","text":"","title":"Dielectric Specular Node"},{"location":"ShaderGraph/Dielectric-Specular-Node/#description","text":"Returns a Dielectric Specular F0 value for a physically based material. The material to use can be selected with the Material dropdown parameter on the Node . A Common Material type defines a range between 0.034 and 0.048 sRGB values. The value between this range can be selected with the Range parameter. This Material type should be used for various materials such as plastics and fabrics. You can use Custom material type to define your own physically based material value. The output value in this case is defined by its index of refraction. This can be set by the parameter IOR .","title":"Description"},{"location":"ShaderGraph/Dielectric-Specular-Node/#ports","text":"Name Direction Type Binding Description Out Output Vector 1 None Output value","title":"Ports"},{"location":"ShaderGraph/Dielectric-Specular-Node/#controls","text":"Name Type Options Description Material Dropdown Common, RustedMetal, Water, Ice, Glass, Custom Selects the material value to output. Range Slider Controls output value for Common material type. IOR Slider Controls index of refraction for Custom material type.","title":"Controls"},{"location":"ShaderGraph/Dielectric-Specular-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node per Material mode. Common float _DielectricSpecular_Range = 0.5; float _DielectricSpecular_Out = lerp(0.034, 0.048, _DielectricSpecular_Range); RustedMetal float _DielectricSpecular_Out = 0.030; Water float _DielectricSpecular_Out = 0.020; Ice float _DielectricSpecular_Out = 0.018; Glass float _DielectricSpecular_Out = 0.040; Custom float _DielectricSpecular_IOR = 1; float _DielectricSpecular_Out = pow(_Node_IOR - 1, 2) / pow(_DielectricSpecular_IOR + 1, 2);","title":"Generated Code Example"},{"location":"ShaderGraph/Distance-Node/","text":"Distance Node Description Returns the euclidean distance between the values of the inputs A and B . This is useful for, among other things, calculating the distance between two points in space and is commonly used in calculating a Signed Distance Function . Ports Name Direction Type Description A Input Dynamic Vector First input value B Input Dynamic Vector Second input value Out Output Vector 1 Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Distance_float4(float4 A, float4 B, out float Out) { Out = distance(A, B); }","title":"Distance Node"},{"location":"ShaderGraph/Distance-Node/#distance-node","text":"","title":"Distance Node"},{"location":"ShaderGraph/Distance-Node/#description","text":"Returns the euclidean distance between the values of the inputs A and B . This is useful for, among other things, calculating the distance between two points in space and is commonly used in calculating a Signed Distance Function .","title":"Description"},{"location":"ShaderGraph/Distance-Node/#ports","text":"Name Direction Type Description A Input Dynamic Vector First input value B Input Dynamic Vector Second input value Out Output Vector 1 Output value","title":"Ports"},{"location":"ShaderGraph/Distance-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Distance_float4(float4 A, float4 B, out float Out) { Out = distance(A, B); }","title":"Generated Code Example"},{"location":"ShaderGraph/Dither-Node/","text":"Dither Node Description Dither is an intentional form of noise used to randomize quantization error. It is used to prevent large-scale patterns such as color banding in images. The Dither node applies dithering in screen-space to ensure a uniform distribution of the pattern. This can be adjusted by connecting another node to input Screen Position . This Node is commonly used as an input to Alpha Clip Threshold on a Master Node to give the appearance of transparency to an opaque object. This is useful for creating objects that appear to be transparent but have the advantages of rendering as opaque, such as writing depth and/or being rendered in deferred. Ports Name Direction Type Binding Description In Input Dynamic Vector None Input value Screen Position Input Vector 4 Screen Position Coordinates used to apply dither pattern Out Output Dynamic Vector None Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Dither_float4(float4 In, float4 ScreenPosition, out float4 Out) { float2 uv = ScreenPosition.xy * _ScreenParams.xy; float DITHER_THRESHOLDS[16] = { 1.0 / 17.0, 9.0 / 17.0, 3.0 / 17.0, 11.0 / 17.0, 13.0 / 17.0, 5.0 / 17.0, 15.0 / 17.0, 7.0 / 17.0, 4.0 / 17.0, 12.0 / 17.0, 2.0 / 17.0, 10.0 / 17.0, 16.0 / 17.0, 8.0 / 17.0, 14.0 / 17.0, 6.0 / 17.0 }; uint index = (uint(uv.x) % 4) * 4 + uint(uv.y) % 4; Out = In - DITHER_THRESHOLDS[index]; }","title":"Dither Node"},{"location":"ShaderGraph/Dither-Node/#dither-node","text":"","title":"Dither Node"},{"location":"ShaderGraph/Dither-Node/#description","text":"Dither is an intentional form of noise used to randomize quantization error. It is used to prevent large-scale patterns such as color banding in images. The Dither node applies dithering in screen-space to ensure a uniform distribution of the pattern. This can be adjusted by connecting another node to input Screen Position . This Node is commonly used as an input to Alpha Clip Threshold on a Master Node to give the appearance of transparency to an opaque object. This is useful for creating objects that appear to be transparent but have the advantages of rendering as opaque, such as writing depth and/or being rendered in deferred.","title":"Description"},{"location":"ShaderGraph/Dither-Node/#ports","text":"Name Direction Type Binding Description In Input Dynamic Vector None Input value Screen Position Input Vector 4 Screen Position Coordinates used to apply dither pattern Out Output Dynamic Vector None Output value","title":"Ports"},{"location":"ShaderGraph/Dither-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Dither_float4(float4 In, float4 ScreenPosition, out float4 Out) { float2 uv = ScreenPosition.xy * _ScreenParams.xy; float DITHER_THRESHOLDS[16] = { 1.0 / 17.0, 9.0 / 17.0, 3.0 / 17.0, 11.0 / 17.0, 13.0 / 17.0, 5.0 / 17.0, 15.0 / 17.0, 7.0 / 17.0, 4.0 / 17.0, 12.0 / 17.0, 2.0 / 17.0, 10.0 / 17.0, 16.0 / 17.0, 8.0 / 17.0, 14.0 / 17.0, 6.0 / 17.0 }; uint index = (uint(uv.x) % 4) * 4 + uint(uv.y) % 4; Out = In - DITHER_THRESHOLDS[index]; }","title":"Generated Code Example"},{"location":"ShaderGraph/Divide-Node/","text":"Divide Node Description Returns the result of input A (dividend) divided by input B (divisor). Ports Name Direction Type Description A Input Dynamic Vector First input value B Input Dynamic Vector Second input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Divide_float4(float4 A, float4 B, out float4 Out) { Out = A / B; }","title":"Divide Node"},{"location":"ShaderGraph/Divide-Node/#divide-node","text":"","title":"Divide Node"},{"location":"ShaderGraph/Divide-Node/#description","text":"Returns the result of input A (dividend) divided by input B (divisor).","title":"Description"},{"location":"ShaderGraph/Divide-Node/#ports","text":"Name Direction Type Description A Input Dynamic Vector First input value B Input Dynamic Vector Second input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Divide-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Divide_float4(float4 A, float4 B, out float4 Out) { Out = A / B; }","title":"Generated Code Example"},{"location":"ShaderGraph/Dot-Product-Node/","text":"Dot Product Node Description Returns the dot product, or scalar product, of the two input vectors A and B . The dot product is a value equal to the magnitudes of the two vectors multiplied together and then multiplied by the cosine of the angle between them. For normalized input vectors, the Dot Product node returns 1 if they point in exactly the same direction, -1 if they point in completely opposite directions and 0 if the vectors are perpendicular. Ports Name Direction Type Description A Input Dynamic Vector First input value B Input Dynamic Vector Second input value Out Output Vector 1 Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_DotProduct_float4(float4 A, float4 B, out float Out) { Out = dot(A, B); }","title":"Dot Product Node"},{"location":"ShaderGraph/Dot-Product-Node/#dot-product-node","text":"","title":"Dot Product Node"},{"location":"ShaderGraph/Dot-Product-Node/#description","text":"Returns the dot product, or scalar product, of the two input vectors A and B . The dot product is a value equal to the magnitudes of the two vectors multiplied together and then multiplied by the cosine of the angle between them. For normalized input vectors, the Dot Product node returns 1 if they point in exactly the same direction, -1 if they point in completely opposite directions and 0 if the vectors are perpendicular.","title":"Description"},{"location":"ShaderGraph/Dot-Product-Node/#ports","text":"Name Direction Type Description A Input Dynamic Vector First input value B Input Dynamic Vector Second input value Out Output Vector 1 Output value","title":"Ports"},{"location":"ShaderGraph/Dot-Product-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_DotProduct_float4(float4 A, float4 B, out float Out) { Out = dot(A, B); }","title":"Generated Code Example"},{"location":"ShaderGraph/Edge/","text":"Edge Description An Edge defines a connection between two Ports . Edges define how data flows through the Shader Graph node network. They can only be connected from an input Port to an output Port . Each Edge has a Data Type which defines what Ports it can be connected to. Each Data Type has an associated color for identifying its type. You can create a new Edge by clicking and dragging from a Port with the left mouse button. Edges can be deleted with Delete (Windows), Command + Backspace (OSX) or from the context menu by right clicking on the Node . You can open a contextual Create Node Menu by dragging an Edge from a Port with the left mouse button and releasing it in an empty area of the workspace.","title":"Edge"},{"location":"ShaderGraph/Edge/#edge","text":"","title":"Edge"},{"location":"ShaderGraph/Edge/#description","text":"An Edge defines a connection between two Ports . Edges define how data flows through the Shader Graph node network. They can only be connected from an input Port to an output Port . Each Edge has a Data Type which defines what Ports it can be connected to. Each Data Type has an associated color for identifying its type. You can create a new Edge by clicking and dragging from a Port with the left mouse button. Edges can be deleted with Delete (Windows), Command + Backspace (OSX) or from the context menu by right clicking on the Node . You can open a contextual Create Node Menu by dragging an Edge from a Port with the left mouse button and releasing it in an empty area of the workspace.","title":"Description"},{"location":"ShaderGraph/Ellipse-Node/","text":"Ellipse Node Description Generates an ellipse shape based on input UV at the size specified by inputs Width and Height . The generated shape can be offset or tiled by connecting a Tiling And Offset Node . Note that in order to preserve the ability to offset the shape within the UV space the shape will not automatically repeat if tiled. To achieve a repeating dot effect first connect your input through a Fraction Node . NOTE: This Node can only be used in the Fragment Shader Stage . Ports Name Direction Type Binding Description UV Input Vector 2 UV Input UV value Width Input Vector 1 None Ellipse width Height Input Vector 1 None Ellipse height Out Output Vector 1 None Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Ellipse_float(float2 UV, float Width, float Height, out float4 Out) { float d = length((UV * 2 - 1) / float2(Width, Height)); Out = saturate((1 - d) / fwidth(d)); }","title":"Ellipse Node"},{"location":"ShaderGraph/Ellipse-Node/#ellipse-node","text":"","title":"Ellipse Node"},{"location":"ShaderGraph/Ellipse-Node/#description","text":"Generates an ellipse shape based on input UV at the size specified by inputs Width and Height . The generated shape can be offset or tiled by connecting a Tiling And Offset Node . Note that in order to preserve the ability to offset the shape within the UV space the shape will not automatically repeat if tiled. To achieve a repeating dot effect first connect your input through a Fraction Node . NOTE: This Node can only be used in the Fragment Shader Stage .","title":"Description"},{"location":"ShaderGraph/Ellipse-Node/#ports","text":"Name Direction Type Binding Description UV Input Vector 2 UV Input UV value Width Input Vector 1 None Ellipse width Height Input Vector 1 None Ellipse height Out Output Vector 1 None Output value","title":"Ports"},{"location":"ShaderGraph/Ellipse-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Ellipse_float(float2 UV, float Width, float Height, out float4 Out) { float d = length((UV * 2 - 1) / float2(Width, Height)); Out = saturate((1 - d) / fwidth(d)); }","title":"Generated Code Example"},{"location":"ShaderGraph/Exponential-Node/","text":"Exponential Node Description Returns the exponential value of input In . The exponential base can be switched between base-e and base 2 from the Base dropdown on the node. Base E : Returns e to the power of input In Base 2 : Returns 2 to the power of input In Ports Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value Controls Name Type Options Description Base Dropdown BaseE, Base2 Selects the exponential base Generated Code Example The following example code represents one possible outcome of this node per Base mode. Base E void Unity_Exponential_float4(float4 In, out float4 Out) { Out = exp(In); } Base 2 void Unity_Exponential2_float4(float4 In, out float4 Out) { Out = exp2(In); }","title":"Exponential Node"},{"location":"ShaderGraph/Exponential-Node/#exponential-node","text":"","title":"Exponential Node"},{"location":"ShaderGraph/Exponential-Node/#description","text":"Returns the exponential value of input In . The exponential base can be switched between base-e and base 2 from the Base dropdown on the node. Base E : Returns e to the power of input In Base 2 : Returns 2 to the power of input In","title":"Description"},{"location":"ShaderGraph/Exponential-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Exponential-Node/#controls","text":"Name Type Options Description Base Dropdown BaseE, Base2 Selects the exponential base","title":"Controls"},{"location":"ShaderGraph/Exponential-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node per Base mode. Base E void Unity_Exponential_float4(float4 In, out float4 Out) { Out = exp(In); } Base 2 void Unity_Exponential2_float4(float4 In, out float4 Out) { Out = exp2(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Flip-Node/","text":"Flip Node Description Flips the individual channels of input In selected by the Node 's parameters. Positive values become negative values and vice versa. Ports Name Direction Type Binding Description In Input Dynamic Vector None Input value Out Output Dynamic Vector None Output value Controls Name Type Options Description Red Toggle True, False If true red channel will be flipped. Green Toggle True, False If true green channel will be flipped. Disabled if In is Vector 1. Blue Toggle True, False If true blue channel will be flipped. Disabled if In is Vector 2 or smaller. Alpha Toggle True, False If true alpha channel will be flipped. Disabled if In is Vector 3 or smaller. Generated Code Example The following example code represents one possible outcome of this node. float2 _Flip_Flip = float4(Red, Green, Blue, Alpha); void Unity_Flip_float4(float4 In, float4 Flip, out float4 Out) { Out = (Flip * -2 + 1) * In; }","title":"Flip Node"},{"location":"ShaderGraph/Flip-Node/#flip-node","text":"","title":"Flip Node"},{"location":"ShaderGraph/Flip-Node/#description","text":"Flips the individual channels of input In selected by the Node 's parameters. Positive values become negative values and vice versa.","title":"Description"},{"location":"ShaderGraph/Flip-Node/#ports","text":"Name Direction Type Binding Description In Input Dynamic Vector None Input value Out Output Dynamic Vector None Output value","title":"Ports"},{"location":"ShaderGraph/Flip-Node/#controls","text":"Name Type Options Description Red Toggle True, False If true red channel will be flipped. Green Toggle True, False If true green channel will be flipped. Disabled if In is Vector 1. Blue Toggle True, False If true blue channel will be flipped. Disabled if In is Vector 2 or smaller. Alpha Toggle True, False If true alpha channel will be flipped. Disabled if In is Vector 3 or smaller.","title":"Controls"},{"location":"ShaderGraph/Flip-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. float2 _Flip_Flip = float4(Red, Green, Blue, Alpha); void Unity_Flip_float4(float4 In, float4 Flip, out float4 Out) { Out = (Flip * -2 + 1) * In; }","title":"Generated Code Example"},{"location":"ShaderGraph/Flipbook-Node/","text":"Flipbook Node Description Creates a flipbook, or texture sheet animation, of the UVs supplied to input UV . The amount of tiles on the sheet are defined by the values of the inputs Width and Height . The index of the current tile is defined by the value of the input Tile . This node can be used to create a texture animation functionality, commonly used for particle effects and sprites, by supplying Time to the input Tile and outputting to the UV input slot of a Texture Sampler . UV data is typically in the range of 0 to 1 starting from the bottom left of UV space. This can be seen by the black value at the bottom left corner of a UV preview. As flipbooks typically start from top left the parameter Invert Y is enabled by default, however you can change the direction of the Flipbook by switching the Invert X and Invert Y parameters. Ports Name Direction Type Binding Description UV Input Vector 2 UV Input UV value Width Input Vector 1 None Amount of horizontal tiles Height Input Vector 1 None Amount of vertical tiles Tile Input Vector 1 None Current tile index Out Output Vector 2 None Output UV value Controls Name Type Options Description Invert X Toggle True, False If enabled tiles are iterated from right to left Invert Y Toggle True, False If enabled tiles are iterated from top to bottom Generated Code Example The following example code represents one possible outcome of this node. float2 _Flipbook_Invert = float2(FlipX, FlipY); void Unity_Flipbook_float(float2 UV, float Width, float Height, float Tile, float2 Invert, out float2 Out) { Tile = fmod(Tile, Width * Height); float2 tileCount = float2(1.0, 1.0) / float2(Width, Height); float tileY = abs(Invert.y * Height - (floor(Tile * tileCount.x) + Invert.y * 1)); float tileX = abs(Invert.x * Width - ((Tile - Width * floor(Tile * tileCount.x)) + Invert.x * 1)); Out = (UV + float2(tileX, tileY)) * tileCount; }","title":"Flipbook Node"},{"location":"ShaderGraph/Flipbook-Node/#flipbook-node","text":"","title":"Flipbook Node"},{"location":"ShaderGraph/Flipbook-Node/#description","text":"Creates a flipbook, or texture sheet animation, of the UVs supplied to input UV . The amount of tiles on the sheet are defined by the values of the inputs Width and Height . The index of the current tile is defined by the value of the input Tile . This node can be used to create a texture animation functionality, commonly used for particle effects and sprites, by supplying Time to the input Tile and outputting to the UV input slot of a Texture Sampler . UV data is typically in the range of 0 to 1 starting from the bottom left of UV space. This can be seen by the black value at the bottom left corner of a UV preview. As flipbooks typically start from top left the parameter Invert Y is enabled by default, however you can change the direction of the Flipbook by switching the Invert X and Invert Y parameters.","title":"Description"},{"location":"ShaderGraph/Flipbook-Node/#ports","text":"Name Direction Type Binding Description UV Input Vector 2 UV Input UV value Width Input Vector 1 None Amount of horizontal tiles Height Input Vector 1 None Amount of vertical tiles Tile Input Vector 1 None Current tile index Out Output Vector 2 None Output UV value","title":"Ports"},{"location":"ShaderGraph/Flipbook-Node/#controls","text":"Name Type Options Description Invert X Toggle True, False If enabled tiles are iterated from right to left Invert Y Toggle True, False If enabled tiles are iterated from top to bottom","title":"Controls"},{"location":"ShaderGraph/Flipbook-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. float2 _Flipbook_Invert = float2(FlipX, FlipY); void Unity_Flipbook_float(float2 UV, float Width, float Height, float Tile, float2 Invert, out float2 Out) { Tile = fmod(Tile, Width * Height); float2 tileCount = float2(1.0, 1.0) / float2(Width, Height); float tileY = abs(Invert.y * Height - (floor(Tile * tileCount.x) + Invert.y * 1)); float tileX = abs(Invert.x * Width - ((Tile - Width * floor(Tile * tileCount.x)) + Invert.x * 1)); Out = (UV + float2(tileX, tileY)) * tileCount; }","title":"Generated Code Example"},{"location":"ShaderGraph/Floor-Node/","text":"Floor Node Description Returns the largest integer value, or whole number, that is less than or equal to the value of input In . Ports Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Floor_float4(float4 In, out float4 Out) { Out = floor(In); }","title":"Floor Node"},{"location":"ShaderGraph/Floor-Node/#floor-node","text":"","title":"Floor Node"},{"location":"ShaderGraph/Floor-Node/#description","text":"Returns the largest integer value, or whole number, that is less than or equal to the value of input In .","title":"Description"},{"location":"ShaderGraph/Floor-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Floor-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Floor_float4(float4 In, out float4 Out) { Out = floor(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Fog-Node/","text":"Fog Node Description Provides access to the Scene's Fog parameters. Note: The behavior of this Node is undefined globally. Shader Graph does not define the function of the node. Instead, each Render Pipeline defines what HLSL code to execute for this Node . Different Render Pipelines may produce different results. If you're building a shader in one Render Pipeline that you want to use in both, try checking it in both pipelines before production. A Node might be defined in one Render Pipeline and undefined in the other. If this Node is undefined, it returns 0 (black). Unity Pipelines Supported Lightweight Render Pipeline Ports Name Direction Type Binding Description Position Output Vector 3 Position (object space) Mesh vertex/fragment's position Color Output Vector 4 None Fog color Density Output Vector 1 None Fog density at the vertex or fragment's clip space depth Generated Code Example The following example code represents one possible outcome of this node. void Unity_Fog_float(float3 Position, out float4 Color, out float Density) { SHADERGRAPH_FOG(Position, Color, Density); }","title":"Fog Node"},{"location":"ShaderGraph/Fog-Node/#fog-node","text":"","title":"Fog Node"},{"location":"ShaderGraph/Fog-Node/#description","text":"Provides access to the Scene's Fog parameters. Note: The behavior of this Node is undefined globally. Shader Graph does not define the function of the node. Instead, each Render Pipeline defines what HLSL code to execute for this Node . Different Render Pipelines may produce different results. If you're building a shader in one Render Pipeline that you want to use in both, try checking it in both pipelines before production. A Node might be defined in one Render Pipeline and undefined in the other. If this Node is undefined, it returns 0 (black).","title":"Description"},{"location":"ShaderGraph/Fog-Node/#unity-pipelines-supported","text":"Lightweight Render Pipeline","title":"Unity Pipelines Supported"},{"location":"ShaderGraph/Fog-Node/#ports","text":"Name Direction Type Binding Description Position Output Vector 3 Position (object space) Mesh vertex/fragment's position Color Output Vector 4 None Fog color Density Output Vector 1 None Fog density at the vertex or fragment's clip space depth","title":"Ports"},{"location":"ShaderGraph/Fog-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Fog_float(float3 Position, out float4 Color, out float Density) { SHADERGRAPH_FOG(Position, Color, Density); }","title":"Generated Code Example"},{"location":"ShaderGraph/Fraction-Node/","text":"Fraction Node Description Returns the fractional (or decimal) part of input In ; which is greater than or equal to 0 and less than 1. Ports Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Fraction_float4(float4 In, out float4 Out) { Out = frac(In); }","title":"Fraction Node"},{"location":"ShaderGraph/Fraction-Node/#fraction-node","text":"","title":"Fraction Node"},{"location":"ShaderGraph/Fraction-Node/#description","text":"Returns the fractional (or decimal) part of input In ; which is greater than or equal to 0 and less than 1.","title":"Description"},{"location":"ShaderGraph/Fraction-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Fraction-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Fraction_float4(float4 In, out float4 Out) { Out = frac(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Fresnel-Effect-Node/","text":"Fresnel Effect Node Description Fresnel Effect is the effect of differing reflectance on a surface depending on viewing angle, where as you approach the grazing angle more light is reflected. The Fresnel Effect node approximates this by calculating the angle between the surface normal and the view direction. The wider this angle is, the greater the return value will be. This effect is often used to achieve rim lighting, common in many art styles. Ports Name Direction Type Description Normal Input Vector 3 Normal direction. By default bound to World Space Normal View Dir Input Vector 3 View direction. By default bound to World Space View Direction Power Input Vector 1 Exponent of the power calculation Out Output Vector 1 Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_FresnelEffect_float(float3 Normal, float3 ViewDir, float Power, out float Out) { Out = pow((1.0 - saturate(dot(normalize(Normal), normalize(ViewDir)))), Power); }","title":"Fresnel Effect Node"},{"location":"ShaderGraph/Fresnel-Effect-Node/#fresnel-effect-node","text":"","title":"Fresnel Effect Node"},{"location":"ShaderGraph/Fresnel-Effect-Node/#description","text":"Fresnel Effect is the effect of differing reflectance on a surface depending on viewing angle, where as you approach the grazing angle more light is reflected. The Fresnel Effect node approximates this by calculating the angle between the surface normal and the view direction. The wider this angle is, the greater the return value will be. This effect is often used to achieve rim lighting, common in many art styles.","title":"Description"},{"location":"ShaderGraph/Fresnel-Effect-Node/#ports","text":"Name Direction Type Description Normal Input Vector 3 Normal direction. By default bound to World Space Normal View Dir Input Vector 3 View direction. By default bound to World Space View Direction Power Input Vector 1 Exponent of the power calculation Out Output Vector 1 Output value","title":"Ports"},{"location":"ShaderGraph/Fresnel-Effect-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_FresnelEffect_float(float3 Normal, float3 ViewDir, float Power, out float Out) { Out = pow((1.0 - saturate(dot(normalize(Normal), normalize(ViewDir)))), Power); }","title":"Generated Code Example"},{"location":"ShaderGraph/Getting-Started/","text":"Getting Started with Shader Graph What is a Shader Graph? A Shader Graph enables you to build your shaders visually. Instead of hand writing code you create and connect Node in a graph network. You can do things like: Procedurally alter your surface appearance Warp and animate UVs Modify the look of your objects using familiar image adjustment operations Change your object\u2019s surface based on useful information about it, its world location, normals, distance from camera, etc. Expose to the material inspector what you think is important to edit for your shader Share node networks between multiple graphs and users by creating subgraphs Create your own custom shader graph Nodes through C# and HLSL The graph framework gives instant feedback on the changes, and it\u2019s simple enough that new users can become involved in shader creation. How do you create Shader Graphs? To use Shader Graph you must first create a Shader Graph Asset . In Unity a Shader Graph Asset appears as a normal shader. To create a Shader Graph Asset you click the create menu in the Project Window and select Shader from the dropdown. From here you can create either a PBR or Unlit Shader Graph Asset . This will create a Shader Graph Asset in the project. You can double click on the Shader Graph Asset or, with the Shader Graph Asset selected, select the Open Shader Editor button in the Inspector to bring up the Shader Graph Window . Editing the Shader Graph When you open the Shader Graph Window you start with the Master Node . You connect Nodes into the Master Node to create the look of your surface. To learn more about the underlying material models check out the existing Unity Standard Shader documentation. You can quickly edit your surface by changing the default values! But, you know what\u2019s even more exciting? Adding textures and other complex interactions. To add a node simply right click on the workspace in the Shader Graph Window and select Create Node . Each included Shader Graph Node has a number of input Ports , we\u2019ve included default values that you can customize however you like! Adding in a Texture (or other assets) is also really easy, just create a Node of that Data Type and connect it with an Edge ! Your Shader Graph shader is just like a normal shader in Unity. Right click create Material in the Project Window to create a new Material you can use on any object in your game. You can create multiple Materials from the same shader. You can expose Properties in your shader so they can be overwritten in each Material you create from your shader. This is easy. In the shader graph right click on any variable node and select Convert to property node or add a new Property using the Blackboard . These exposed Properties appear in the Material Inspector for each Material you create from your shader. To see your new Shader Graph changes affect your in game Materials click the Save Asset button in the Shader Graph Window How do I get access to the Shader Graph? It is recommended for users to access the Shader Graph via the Package Manager or via Templates . To use the Shader Graph in your project either start a new project using a template that includes Shader Graph or download a Render Pipeline package from the Package Manager . The Shader Graph will be downloaded automatically for your use in either of these cases. Packages that contain Shader Graph : - Lightweight Render Pipeline - HD Render Pipeline Templates that contain Shader Graph : - Lightweight 3D Template - HD 3D Template Download from Github If you wish to download via Github you must clone to SRP repository then reference these package versions directly in your project's package manifest. What are the requirements for using Shader Graph This is a feature for the new Scriptable Render Pipeline , available in 2018.1+. It will not work out of the box without an SRP. We won\u2019t be supporting this feature for the legacy renderer. I want more tutorials! More will be coming (including more examples!) over the coming months. We have an end to end shader creation video Here as a starter point.","title":"Getting Started with Shader Graph"},{"location":"ShaderGraph/Getting-Started/#getting-started-with-shader-graph","text":"","title":"Getting Started with Shader Graph"},{"location":"ShaderGraph/Getting-Started/#what-is-a-shader-graph","text":"A Shader Graph enables you to build your shaders visually. Instead of hand writing code you create and connect Node in a graph network. You can do things like: Procedurally alter your surface appearance Warp and animate UVs Modify the look of your objects using familiar image adjustment operations Change your object\u2019s surface based on useful information about it, its world location, normals, distance from camera, etc. Expose to the material inspector what you think is important to edit for your shader Share node networks between multiple graphs and users by creating subgraphs Create your own custom shader graph Nodes through C# and HLSL The graph framework gives instant feedback on the changes, and it\u2019s simple enough that new users can become involved in shader creation.","title":"What is a Shader Graph?"},{"location":"ShaderGraph/Getting-Started/#how-do-you-create-shader-graphs","text":"To use Shader Graph you must first create a Shader Graph Asset . In Unity a Shader Graph Asset appears as a normal shader. To create a Shader Graph Asset you click the create menu in the Project Window and select Shader from the dropdown. From here you can create either a PBR or Unlit Shader Graph Asset . This will create a Shader Graph Asset in the project. You can double click on the Shader Graph Asset or, with the Shader Graph Asset selected, select the Open Shader Editor button in the Inspector to bring up the Shader Graph Window .","title":"How do you create Shader Graphs?"},{"location":"ShaderGraph/Getting-Started/#editing-the-shader-graph","text":"When you open the Shader Graph Window you start with the Master Node . You connect Nodes into the Master Node to create the look of your surface. To learn more about the underlying material models check out the existing Unity Standard Shader documentation. You can quickly edit your surface by changing the default values! But, you know what\u2019s even more exciting? Adding textures and other complex interactions. To add a node simply right click on the workspace in the Shader Graph Window and select Create Node . Each included Shader Graph Node has a number of input Ports , we\u2019ve included default values that you can customize however you like! Adding in a Texture (or other assets) is also really easy, just create a Node of that Data Type and connect it with an Edge ! Your Shader Graph shader is just like a normal shader in Unity. Right click create Material in the Project Window to create a new Material you can use on any object in your game. You can create multiple Materials from the same shader. You can expose Properties in your shader so they can be overwritten in each Material you create from your shader. This is easy. In the shader graph right click on any variable node and select Convert to property node or add a new Property using the Blackboard . These exposed Properties appear in the Material Inspector for each Material you create from your shader. To see your new Shader Graph changes affect your in game Materials click the Save Asset button in the Shader Graph Window","title":"Editing the Shader Graph"},{"location":"ShaderGraph/Getting-Started/#how-do-i-get-access-to-the-shader-graph","text":"It is recommended for users to access the Shader Graph via the Package Manager or via Templates . To use the Shader Graph in your project either start a new project using a template that includes Shader Graph or download a Render Pipeline package from the Package Manager . The Shader Graph will be downloaded automatically for your use in either of these cases. Packages that contain Shader Graph : - Lightweight Render Pipeline - HD Render Pipeline Templates that contain Shader Graph : - Lightweight 3D Template - HD 3D Template","title":"How do I get access to the Shader Graph?"},{"location":"ShaderGraph/Getting-Started/#download-from-github","text":"If you wish to download via Github you must clone to SRP repository then reference these package versions directly in your project's package manifest.","title":"Download from Github"},{"location":"ShaderGraph/Getting-Started/#what-are-the-requirements-for-using-shader-graph","text":"This is a feature for the new Scriptable Render Pipeline , available in 2018.1+. It will not work out of the box without an SRP. We won\u2019t be supporting this feature for the legacy renderer.","title":"What are the requirements for using Shader Graph"},{"location":"ShaderGraph/Getting-Started/#i-want-more-tutorials","text":"More will be coming (including more examples!) over the coming months. We have an end to end shader creation video Here as a starter point.","title":"I want more tutorials!"},{"location":"ShaderGraph/Gradient-Node/","text":"Gradient Node Description Defines a constant Gradient for use in Shader Graph , although internally to the shader this is defined as a struct . To sample the Gradient it should be used in conjunction with a Sample Gradient Node . When using a separate Gradient Node , you can sample a Gradient multiple times with different Time parameters. Ports Name Direction Type Description Out Output Gradient Output value Controls Name Type Options Description Gradient Field Defines the gradient. Generated Code Example The following example code represents one possible outcome of this node. Gradient Unity_Gradient_float() { Gradient g; g.type = 1; g.colorsLength = 4; g.alphasLength = 4; g.colors[0] = 0.1; g.colors[1] = 0.2; g.colors[2] = 0.3; g.colors[3] = 0.4; g.colors[4] = 0; g.colors[5] = 0; g.colors[6] = 0; g.colors[7] = 0; g.alphas[0] = 0.1; g.alphas[1] = 0.2; g.alphas[2] = 0.3; g.alphas[3] = 0.4; g.alphas[4] = 0; g.alphas[5] = 0; g.alphas[6] = 0; g.alphas[7] = 0; return g; } Gradient _Gradient = Unity_Gradient_float();","title":"Gradient Node"},{"location":"ShaderGraph/Gradient-Node/#gradient-node","text":"","title":"Gradient Node"},{"location":"ShaderGraph/Gradient-Node/#description","text":"Defines a constant Gradient for use in Shader Graph , although internally to the shader this is defined as a struct . To sample the Gradient it should be used in conjunction with a Sample Gradient Node . When using a separate Gradient Node , you can sample a Gradient multiple times with different Time parameters.","title":"Description"},{"location":"ShaderGraph/Gradient-Node/#ports","text":"Name Direction Type Description Out Output Gradient Output value","title":"Ports"},{"location":"ShaderGraph/Gradient-Node/#controls","text":"Name Type Options Description Gradient Field Defines the gradient.","title":"Controls"},{"location":"ShaderGraph/Gradient-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. Gradient Unity_Gradient_float() { Gradient g; g.type = 1; g.colorsLength = 4; g.alphasLength = 4; g.colors[0] = 0.1; g.colors[1] = 0.2; g.colors[2] = 0.3; g.colors[3] = 0.4; g.colors[4] = 0; g.colors[5] = 0; g.colors[6] = 0; g.colors[7] = 0; g.alphas[0] = 0.1; g.alphas[1] = 0.2; g.alphas[2] = 0.3; g.alphas[3] = 0.4; g.alphas[4] = 0; g.alphas[5] = 0; g.alphas[6] = 0; g.alphas[7] = 0; return g; } Gradient _Gradient = Unity_Gradient_float();","title":"Generated Code Example"},{"location":"ShaderGraph/Gradient-Noise-Node/","text":"Gradient Noise Node Description Generates a gradient, or Perlin , noise based on input UV . The scale of the generated noise is controlled by input Scale . Ports Name Direction Type Binding Description UV Input Vector 2 UV Input UV value Scale Input Vector 1 None Noise scale Out Output Vector 1 None Output value Generated Code Example The following example code represents one possible outcome of this node. float2 unity_gradientNoise_dir(float2 p) { p = p % 289; float x = (34 * p.x + 1) * p.x % 289 + p.y; x = (34 * x + 1) * x % 289; x = frac(x / 41) * 2 - 1; return normalize(float2(x - floor(x + 0.5), abs(x) - 0.5)); } float unity_gradientNoise(float2 p) { float2 ip = floor(p); float2 fp = frac(p); float d00 = dot(unity_gradientNoise_dir(ip), fp); float d01 = dot(unity_gradientNoise_dir(ip + float2(0, 1)), fp - float2(0, 1)); float d10 = dot(unity_gradientNoise_dir(ip + float2(1, 0)), fp - float2(1, 0)); float d11 = dot(unity_gradientNoise_dir(ip + float2(1, 1)), fp - float2(1, 1)); fp = fp * fp * fp * (fp * (fp * 6 - 15) + 10); return lerp(lerp(d00, d01, fp.y), lerp(d10, d11, fp.y), fp.x); } void Unity_GradientNoise_float(float2 UV, float Scale, out float Out) { Out = unity_gradientNoise(UV * Scale) + 0.5; }","title":"Gradient Noise Node"},{"location":"ShaderGraph/Gradient-Noise-Node/#gradient-noise-node","text":"","title":"Gradient Noise Node"},{"location":"ShaderGraph/Gradient-Noise-Node/#description","text":"Generates a gradient, or Perlin , noise based on input UV . The scale of the generated noise is controlled by input Scale .","title":"Description"},{"location":"ShaderGraph/Gradient-Noise-Node/#ports","text":"Name Direction Type Binding Description UV Input Vector 2 UV Input UV value Scale Input Vector 1 None Noise scale Out Output Vector 1 None Output value","title":"Ports"},{"location":"ShaderGraph/Gradient-Noise-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. float2 unity_gradientNoise_dir(float2 p) { p = p % 289; float x = (34 * p.x + 1) * p.x % 289 + p.y; x = (34 * x + 1) * x % 289; x = frac(x / 41) * 2 - 1; return normalize(float2(x - floor(x + 0.5), abs(x) - 0.5)); } float unity_gradientNoise(float2 p) { float2 ip = floor(p); float2 fp = frac(p); float d00 = dot(unity_gradientNoise_dir(ip), fp); float d01 = dot(unity_gradientNoise_dir(ip + float2(0, 1)), fp - float2(0, 1)); float d10 = dot(unity_gradientNoise_dir(ip + float2(1, 0)), fp - float2(1, 0)); float d11 = dot(unity_gradientNoise_dir(ip + float2(1, 1)), fp - float2(1, 1)); fp = fp * fp * fp * (fp * (fp * 6 - 15) + 10); return lerp(lerp(d00, d01, fp.y), lerp(d10, d11, fp.y), fp.x); } void Unity_GradientNoise_float(float2 UV, float Scale, out float Out) { Out = unity_gradientNoise(UV * Scale) + 0.5; }","title":"Generated Code Example"},{"location":"ShaderGraph/Hue-Node/","text":"Hue Node Description Offsets the hue of input In by the amount of input Offset . The unit of the offset can be set with the parameter Range . Offset in Degrees is in the range -180 to 180. In Radians it is -Pi to Pi. Ports Name Direction Type Binding Description In Input Vector 3 None Input value Offset Input Vector 1 None Amount to offset hue Out Output Vector 3 None Output value Controls Name Type Options Description Range Dropdown Degrees, Radians The unit used for the input Offset Generated Code Example The following example code represents one possible outcome of this node per Base mode. Degrees void Unity_Hue_Degrees_float(float3 In, float Offset, out float3 Out) { float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); float4 P = lerp(float4(In.bg, K.wz), float4(In.gb, K.xy), step(In.b, In.g)); float4 Q = lerp(float4(P.xyw, In.r), float4(In.r, P.yzx), step(P.x, In.r)); float D = Q.x - min(Q.w, Q.y); float E = 1e-10; float3 hsv = float3(abs(Q.z + (Q.w - Q.y)/(6.0 * D + E)), D / (Q.x + E), Q.x); float hue = hsv.x + Offset / 360; hsv.x = (hue < 0) ? hue + 1 : (hue > 1) ? hue - 1 : hue; float4 K2 = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); float3 P2 = abs(frac(hsv.xxx + K2.xyz) * 6.0 - K2.www); Out = hsv.z * lerp(K2.xxx, saturate(P2 - K2.xxx), hsv.y); } Radians void Unity_Hue_Radians_float(float3 In, float Offset, out float3 Out) { float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); float4 P = lerp(float4(In.bg, K.wz), float4(In.gb, K.xy), step(In.b, In.g)); float4 Q = lerp(float4(P.xyw, In.r), float4(In.r, P.yzx), step(P.x, In.r)); float D = Q.x - min(Q.w, Q.y); float E = 1e-10; float3 hsv = float3(abs(Q.z + (Q.w - Q.y)/(6.0 * D + E)), D / (Q.x + E), Q.x); float hue = hsv.x + Offset; hsv.x = (hue < 0) ? hue + 1 : (hue > 1) ? hue - 1 : hue; // HSV to RGB float4 K2 = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); float3 P2 = abs(frac(hsv.xxx + K2.xyz) * 6.0 - K2.www); Out = hsv.z * lerp(K2.xxx, saturate(P2 - K2.xxx), hsv.y); }","title":"Hue Node"},{"location":"ShaderGraph/Hue-Node/#hue-node","text":"","title":"Hue Node"},{"location":"ShaderGraph/Hue-Node/#description","text":"Offsets the hue of input In by the amount of input Offset . The unit of the offset can be set with the parameter Range . Offset in Degrees is in the range -180 to 180. In Radians it is -Pi to Pi.","title":"Description"},{"location":"ShaderGraph/Hue-Node/#ports","text":"Name Direction Type Binding Description In Input Vector 3 None Input value Offset Input Vector 1 None Amount to offset hue Out Output Vector 3 None Output value","title":"Ports"},{"location":"ShaderGraph/Hue-Node/#controls","text":"Name Type Options Description Range Dropdown Degrees, Radians The unit used for the input Offset","title":"Controls"},{"location":"ShaderGraph/Hue-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node per Base mode. Degrees void Unity_Hue_Degrees_float(float3 In, float Offset, out float3 Out) { float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); float4 P = lerp(float4(In.bg, K.wz), float4(In.gb, K.xy), step(In.b, In.g)); float4 Q = lerp(float4(P.xyw, In.r), float4(In.r, P.yzx), step(P.x, In.r)); float D = Q.x - min(Q.w, Q.y); float E = 1e-10; float3 hsv = float3(abs(Q.z + (Q.w - Q.y)/(6.0 * D + E)), D / (Q.x + E), Q.x); float hue = hsv.x + Offset / 360; hsv.x = (hue < 0) ? hue + 1 : (hue > 1) ? hue - 1 : hue; float4 K2 = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); float3 P2 = abs(frac(hsv.xxx + K2.xyz) * 6.0 - K2.www); Out = hsv.z * lerp(K2.xxx, saturate(P2 - K2.xxx), hsv.y); } Radians void Unity_Hue_Radians_float(float3 In, float Offset, out float3 Out) { float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); float4 P = lerp(float4(In.bg, K.wz), float4(In.gb, K.xy), step(In.b, In.g)); float4 Q = lerp(float4(P.xyw, In.r), float4(In.r, P.yzx), step(P.x, In.r)); float D = Q.x - min(Q.w, Q.y); float E = 1e-10; float3 hsv = float3(abs(Q.z + (Q.w - Q.y)/(6.0 * D + E)), D / (Q.x + E), Q.x); float hue = hsv.x + Offset; hsv.x = (hue < 0) ? hue + 1 : (hue > 1) ? hue - 1 : hue; // HSV to RGB float4 K2 = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); float3 P2 = abs(frac(hsv.xxx + K2.xyz) * 6.0 - K2.www); Out = hsv.z * lerp(K2.xxx, saturate(P2 - K2.xxx), hsv.y); }","title":"Generated Code Example"},{"location":"ShaderGraph/Hyperbolic-Cosine-Node/","text":"Hyperbolic Cosine Node Description Returns the hyperbolic cosine of input In . Ports Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_HyperbolicCosine_float4(float4 In, out float4 Out) { Out = cosh(In); }","title":"Hyperbolic Cosine Node"},{"location":"ShaderGraph/Hyperbolic-Cosine-Node/#hyperbolic-cosine-node","text":"","title":"Hyperbolic Cosine Node"},{"location":"ShaderGraph/Hyperbolic-Cosine-Node/#description","text":"Returns the hyperbolic cosine of input In .","title":"Description"},{"location":"ShaderGraph/Hyperbolic-Cosine-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Hyperbolic-Cosine-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_HyperbolicCosine_float4(float4 In, out float4 Out) { Out = cosh(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Hyperbolic-Sine-Node/","text":"Hyperbolic Sine Node Description Returns the hyperbolic sine of input In . Ports Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_HyperbolicSine_float4(float4 In, out float4 Out) { Out = sinh(In); }","title":"Hyperbolic Sine Node"},{"location":"ShaderGraph/Hyperbolic-Sine-Node/#hyperbolic-sine-node","text":"","title":"Hyperbolic Sine Node"},{"location":"ShaderGraph/Hyperbolic-Sine-Node/#description","text":"Returns the hyperbolic sine of input In .","title":"Description"},{"location":"ShaderGraph/Hyperbolic-Sine-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Hyperbolic-Sine-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_HyperbolicSine_float4(float4 In, out float4 Out) { Out = sinh(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Hyperbolic-Tangent-Node/","text":"Hyperbolic Tangent Node Description Returns the hyperbolic tangent of input In . Ports Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_HyperbolicTangent_float4(float4 In, out float4 Out) { Out = tanh(In); }","title":"Hyperbolic Tangent Node"},{"location":"ShaderGraph/Hyperbolic-Tangent-Node/#hyperbolic-tangent-node","text":"","title":"Hyperbolic Tangent Node"},{"location":"ShaderGraph/Hyperbolic-Tangent-Node/#description","text":"Returns the hyperbolic tangent of input In .","title":"Description"},{"location":"ShaderGraph/Hyperbolic-Tangent-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Hyperbolic-Tangent-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_HyperbolicTangent_float4(float4 In, out float4 Out) { Out = tanh(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Input-Nodes/","text":"Input Nodes Basic Boolean Color Defines a constant Boolean value in the shader. Defines a constant Vector 4 value in the shader using a Color field. Constant Integer Defines a Vector 1 of a mathematical constant value in the shader. Defines a constant Vector 1 value in the shader using an Integer field. Slider Time Defines a constant Vector 1 value in the shader using a Slider field. Provides access to various Time parameters in the shader. Vector 1 Vector 2 Defines a Vector 1 value in the shader. Defines a Vector 2 value in the shader. Vector 3 Vector 4 Defines a Vector 3 value in the shader. Defines a Vector 4 value in the shader. Geometry Bitangent Vector Normal Vector Provides access to the mesh vertex or fragment's Bitangent Vector. Provides access to the mesh vertex or fragment's Normal Vector. Position Screen Position Provides access to the mesh vertex or fragment's Position. Provides access to the mesh vertex or fragment's Screen Position. Tangent Vector UV Provides access to the mesh vertex or fragment's Tangent Vector. Provides access to the mesh vertex or fragment's UV coordinates. Vertex Color View Direction Provides access to the mesh vertex or fragment's Vertex Color value. Provides access to the mesh vertex or fragment's View Direction vector. Gradient Gradient Sample Gradient Defines a constant Gradient in the shader. Samples a Gradient given the input of Time. Matrix Matrix 2x2 Matrix 3x3 Defines a constant Matrix 2x2 value in the shader. Defines a constant Matrix 3x3 value in the shader. Matrix 4x4 Transformation Matrix Defines a constant Matrix 4x4 value in the shader. Defines a constant Matrix 4x4 value for a default Unity Transformation Matrix in the shader. PBR Dielectric Specular Metal Reflectance Returns a Dielectric Specular F0 value for a physically based material. Returns a Metal Reflectance value for a physically based material. Scene Ambient Camera Provides access to the Scene's Ambient color values. Provides access to various parameters of the current Camera. Fog Baked GI Provides access to the Scene's Fog parameters. Provides access to the Baked GI values at the vertex or fragment's position. Object Reflection Probe Provides access to various parameters of the Object. Provides access to the nearest Reflection Probe to the object. Scene Color Scene Depth Provides access to the current Camera's color buffer. Provides access to the current Camera's depth buffer. Screen Provides access to parameters of the screen. Texture Cubemap Asset Sample Cubemap Defines a constant Cubemap Asset for use in the shader. Samples a Cubemap and returns a Vector 4 color value for use in the shader. Sample Texture 2D Sample Texture 2D Array Samples a Texture 2D and returns a color value for use in the shader. Samples a Texture 2D Array at an Index and returns a color value for use in the shader. Sample Texture 2D LOD Sample Texture 3D Samples a Texture 2D at a specific LOD and returns a color value for use in the shader. Samples a Texture 3D and returns a color value for use in the shader. Sampler State Texel Size Defines a Sampler State for sampling textures. Returns the Width and Height of the texel size of Texture 2D input. Texture 2D Array Asset Texture 2D Asset Defines a constant Texture 2D Array Asset for use in the shader. Defines a constant Texture 2D Asset for use in the shader. Texture 3D Asset Defines a constant Texture 3D Asset for use in the shader.","title":"Input Nodes"},{"location":"ShaderGraph/Input-Nodes/#input-nodes","text":"","title":"Input Nodes"},{"location":"ShaderGraph/Input-Nodes/#basic","text":"Boolean Color Defines a constant Boolean value in the shader. Defines a constant Vector 4 value in the shader using a Color field. Constant Integer Defines a Vector 1 of a mathematical constant value in the shader. Defines a constant Vector 1 value in the shader using an Integer field. Slider Time Defines a constant Vector 1 value in the shader using a Slider field. Provides access to various Time parameters in the shader. Vector 1 Vector 2 Defines a Vector 1 value in the shader. Defines a Vector 2 value in the shader. Vector 3 Vector 4 Defines a Vector 3 value in the shader. Defines a Vector 4 value in the shader.","title":"Basic"},{"location":"ShaderGraph/Input-Nodes/#geometry","text":"Bitangent Vector Normal Vector Provides access to the mesh vertex or fragment's Bitangent Vector. Provides access to the mesh vertex or fragment's Normal Vector. Position Screen Position Provides access to the mesh vertex or fragment's Position. Provides access to the mesh vertex or fragment's Screen Position. Tangent Vector UV Provides access to the mesh vertex or fragment's Tangent Vector. Provides access to the mesh vertex or fragment's UV coordinates. Vertex Color View Direction Provides access to the mesh vertex or fragment's Vertex Color value. Provides access to the mesh vertex or fragment's View Direction vector.","title":"Geometry"},{"location":"ShaderGraph/Input-Nodes/#gradient","text":"Gradient Sample Gradient Defines a constant Gradient in the shader. Samples a Gradient given the input of Time.","title":"Gradient"},{"location":"ShaderGraph/Input-Nodes/#matrix","text":"Matrix 2x2 Matrix 3x3 Defines a constant Matrix 2x2 value in the shader. Defines a constant Matrix 3x3 value in the shader. Matrix 4x4 Transformation Matrix Defines a constant Matrix 4x4 value in the shader. Defines a constant Matrix 4x4 value for a default Unity Transformation Matrix in the shader.","title":"Matrix"},{"location":"ShaderGraph/Input-Nodes/#pbr","text":"Dielectric Specular Metal Reflectance Returns a Dielectric Specular F0 value for a physically based material. Returns a Metal Reflectance value for a physically based material.","title":"PBR"},{"location":"ShaderGraph/Input-Nodes/#scene","text":"Ambient Camera Provides access to the Scene's Ambient color values. Provides access to various parameters of the current Camera. Fog Baked GI Provides access to the Scene's Fog parameters. Provides access to the Baked GI values at the vertex or fragment's position. Object Reflection Probe Provides access to various parameters of the Object. Provides access to the nearest Reflection Probe to the object. Scene Color Scene Depth Provides access to the current Camera's color buffer. Provides access to the current Camera's depth buffer. Screen Provides access to parameters of the screen.","title":"Scene"},{"location":"ShaderGraph/Input-Nodes/#texture","text":"Cubemap Asset Sample Cubemap Defines a constant Cubemap Asset for use in the shader. Samples a Cubemap and returns a Vector 4 color value for use in the shader. Sample Texture 2D Sample Texture 2D Array Samples a Texture 2D and returns a color value for use in the shader. Samples a Texture 2D Array at an Index and returns a color value for use in the shader. Sample Texture 2D LOD Sample Texture 3D Samples a Texture 2D at a specific LOD and returns a color value for use in the shader. Samples a Texture 3D and returns a color value for use in the shader. Sampler State Texel Size Defines a Sampler State for sampling textures. Returns the Width and Height of the texel size of Texture 2D input. Texture 2D Array Asset Texture 2D Asset Defines a constant Texture 2D Array Asset for use in the shader. Defines a constant Texture 2D Asset for use in the shader. Texture 3D Asset Defines a constant Texture 3D Asset for use in the shader.","title":"Texture"},{"location":"ShaderGraph/Integer-Node/","text":"Integer Node Description Defines a constant Vector 1 value in the shader using an Integer field. Can be converted to a Vector 1 type Property with a Mode setting of Integer via the Node's context menu. Ports Name Direction Type Binding Description Out Output Vector 1 None Output value Controls Name Type Options Description Integer Defines the output value. Generated Code Example The following example code represents one possible outcome of this node. float _Integer = 1;","title":"Integer Node"},{"location":"ShaderGraph/Integer-Node/#integer-node","text":"","title":"Integer Node"},{"location":"ShaderGraph/Integer-Node/#description","text":"Defines a constant Vector 1 value in the shader using an Integer field. Can be converted to a Vector 1 type Property with a Mode setting of Integer via the Node's context menu.","title":"Description"},{"location":"ShaderGraph/Integer-Node/#ports","text":"Name Direction Type Binding Description Out Output Vector 1 None Output value","title":"Ports"},{"location":"ShaderGraph/Integer-Node/#controls","text":"Name Type Options Description Integer Defines the output value.","title":"Controls"},{"location":"ShaderGraph/Integer-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. float _Integer = 1;","title":"Generated Code Example"},{"location":"ShaderGraph/Inverse-Lerp-Node/","text":"Inverse Lerp Node Description Returns the linear parameter that produces the interpolant specified by input T within the range of input A to input B . Inverse Lerp is the inverse operation of the Lerp Node . It can be used to determine what the input to a Lerp was based on its output. For example, the value of a Lerp between 0 and 2 with a T value of 1 is 0.5. Therefore the value of an Inverse Lerp between 0 and 2 with a T value of 0.5 is 1. Ports Name Direction Type Description A Input Dynamic Vector First input value B Input Dynamic Vector Second input value T Input Dynamic Vector Time value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_InverseLerp_float4(float4 A, float4 B, float4 T, out float4 Out) { Out = (T - A)/(B - A); }","title":"Inverse Lerp Node"},{"location":"ShaderGraph/Inverse-Lerp-Node/#inverse-lerp-node","text":"","title":"Inverse Lerp Node"},{"location":"ShaderGraph/Inverse-Lerp-Node/#description","text":"Returns the linear parameter that produces the interpolant specified by input T within the range of input A to input B . Inverse Lerp is the inverse operation of the Lerp Node . It can be used to determine what the input to a Lerp was based on its output. For example, the value of a Lerp between 0 and 2 with a T value of 1 is 0.5. Therefore the value of an Inverse Lerp between 0 and 2 with a T value of 0.5 is 1.","title":"Description"},{"location":"ShaderGraph/Inverse-Lerp-Node/#ports","text":"Name Direction Type Description A Input Dynamic Vector First input value B Input Dynamic Vector Second input value T Input Dynamic Vector Time value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Inverse-Lerp-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_InverseLerp_float4(float4 A, float4 B, float4 T, out float4 Out) { Out = (T - A)/(B - A); }","title":"Generated Code Example"},{"location":"ShaderGraph/Invert-Colors-Node/","text":"Invert Colors Node Description Inverts the colors of input In on a per channel basis. This Node assumes all input values are in the range 0 - 1. Ports Name Direction Type Binding Description In Input Dynamic Vector None Input value Out Output Dynamic Vector None Output value Controls Name Type Options Description Red Toggle True, False If true red channel is inverted Green Toggle True, False If true green channel is inverted. Disabled if input vector dimension is less than 2 Blue Toggle True, False If true blue channel is inverted. Disabled if input vector dimension is less than 3 Alpha Toggle True, False If true alpha channel is inverted. Disabled if input vector dimension is less than 4 Generated Code Example The following example code represents one possible outcome of this node. float2 _InvertColors_InvertColors = float4(Red, Green, Blue, Alpha); void Unity_InvertColors_float4(float4 In, float4 InvertColors, out float4 Out) { Out = abs(InvertColors - In); }","title":"Invert Colors Node"},{"location":"ShaderGraph/Invert-Colors-Node/#invert-colors-node","text":"","title":"Invert Colors Node"},{"location":"ShaderGraph/Invert-Colors-Node/#description","text":"Inverts the colors of input In on a per channel basis. This Node assumes all input values are in the range 0 - 1.","title":"Description"},{"location":"ShaderGraph/Invert-Colors-Node/#ports","text":"Name Direction Type Binding Description In Input Dynamic Vector None Input value Out Output Dynamic Vector None Output value","title":"Ports"},{"location":"ShaderGraph/Invert-Colors-Node/#controls","text":"Name Type Options Description Red Toggle True, False If true red channel is inverted Green Toggle True, False If true green channel is inverted. Disabled if input vector dimension is less than 2 Blue Toggle True, False If true blue channel is inverted. Disabled if input vector dimension is less than 3 Alpha Toggle True, False If true alpha channel is inverted. Disabled if input vector dimension is less than 4","title":"Controls"},{"location":"ShaderGraph/Invert-Colors-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. float2 _InvertColors_InvertColors = float4(Red, Green, Blue, Alpha); void Unity_InvertColors_float4(float4 In, float4 InvertColors, out float4 Out) { Out = abs(InvertColors - In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Is-Front-Face/","text":"Is Front Face Node Description Returns true if currently rendering a front face and false if rendering a back face. This value is always true unless the Master Node 's Two Sided value is set to true in the Material Options . This is useful for Branching . NOTE: This Node can only be used in the Fragment Shader Stage . Ports Name Direction Type Binding Description Out Output Boolean None Output value","title":"Is Front Face Node"},{"location":"ShaderGraph/Is-Front-Face/#is-front-face-node","text":"","title":"Is Front Face Node"},{"location":"ShaderGraph/Is-Front-Face/#description","text":"Returns true if currently rendering a front face and false if rendering a back face. This value is always true unless the Master Node 's Two Sided value is set to true in the Material Options . This is useful for Branching . NOTE: This Node can only be used in the Fragment Shader Stage .","title":"Description"},{"location":"ShaderGraph/Is-Front-Face/#ports","text":"Name Direction Type Binding Description Out Output Boolean None Output value","title":"Ports"},{"location":"ShaderGraph/Is-Infinite-Node/","text":"Is Infinite Node Description Returns true if any of the components of the input In is an infinite value. This is useful for Branching . Ports Name Direction Type Binding Description In Input Dynamic Vector None Input value Out Output Boolean None Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_IsInfinite_float4(float4 In, out float Out) { Out = isinf(In); }","title":"Is Infinite Node"},{"location":"ShaderGraph/Is-Infinite-Node/#is-infinite-node","text":"","title":"Is Infinite Node"},{"location":"ShaderGraph/Is-Infinite-Node/#description","text":"Returns true if any of the components of the input In is an infinite value. This is useful for Branching .","title":"Description"},{"location":"ShaderGraph/Is-Infinite-Node/#ports","text":"Name Direction Type Binding Description In Input Dynamic Vector None Input value Out Output Boolean None Output value","title":"Ports"},{"location":"ShaderGraph/Is-Infinite-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_IsInfinite_float4(float4 In, out float Out) { Out = isinf(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Is-NaN-Node/","text":"Is NaN Node Description Returns true if any of the components of the input In is not a number (NaN). This is useful for Branching . Ports Name Direction Type Binding Description In Input Dynamic Vector None Input value Out Output Boolean None Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_IsNan_float4(float4 In, out float Out) { Out = (In < 0.0 || In > 0.0 || In == 0.0) ? 0 : 1; }","title":"Is NaN Node"},{"location":"ShaderGraph/Is-NaN-Node/#is-nan-node","text":"","title":"Is NaN Node"},{"location":"ShaderGraph/Is-NaN-Node/#description","text":"Returns true if any of the components of the input In is not a number (NaN). This is useful for Branching .","title":"Description"},{"location":"ShaderGraph/Is-NaN-Node/#ports","text":"Name Direction Type Binding Description In Input Dynamic Vector None Input value Out Output Boolean None Output value","title":"Ports"},{"location":"ShaderGraph/Is-NaN-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_IsNan_float4(float4 In, out float Out) { Out = (In < 0.0 || In > 0.0 || In == 0.0) ? 0 : 1; }","title":"Generated Code Example"},{"location":"ShaderGraph/Length-Node/","text":"Length Node Description Returns the length of input In . This is also known as magnitude. A vector's length is calculated with Pythagorean Theorum . The length of a Vector 2 can be calculated as: Where x and y are the components of the input vector. Length can be calculated for other dimension vectors by adding or removing components. And so on. Ports Name Direction Type Description In Input Dynamic Vector Input value Out Output Vector 1 Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Length_float4(float4 In, out float Out) { Out = length(In); }","title":"Length Node"},{"location":"ShaderGraph/Length-Node/#length-node","text":"","title":"Length Node"},{"location":"ShaderGraph/Length-Node/#description","text":"Returns the length of input In . This is also known as magnitude. A vector's length is calculated with Pythagorean Theorum . The length of a Vector 2 can be calculated as: Where x and y are the components of the input vector. Length can be calculated for other dimension vectors by adding or removing components. And so on.","title":"Description"},{"location":"ShaderGraph/Length-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Out Output Vector 1 Output value","title":"Ports"},{"location":"ShaderGraph/Length-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Length_float4(float4 In, out float Out) { Out = length(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Lerp-Node/","text":"Lerp Node Description Returns the result of linearly interpolating between input A and input B by input T . The value of input T is clamped to the range of 0 to 1. For example, when the value of input T is 0 the return value is equal to the value of input A , when it is 1 the return value is equal to the value of input B and when it is 0.5 the return value is the midpoint of the two inputs A and B . Ports Name Direction Type Description A Input Dynamic Vector First input value B Input Dynamic Vector Second input value T Input Dynamic Vector Time value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Lerp_float4(float4 A, float4 B, float4 T, out float4 Out) { Out = lerp(A, B, T); }","title":"Lerp Node"},{"location":"ShaderGraph/Lerp-Node/#lerp-node","text":"","title":"Lerp Node"},{"location":"ShaderGraph/Lerp-Node/#description","text":"Returns the result of linearly interpolating between input A and input B by input T . The value of input T is clamped to the range of 0 to 1. For example, when the value of input T is 0 the return value is equal to the value of input A , when it is 1 the return value is equal to the value of input B and when it is 0.5 the return value is the midpoint of the two inputs A and B .","title":"Description"},{"location":"ShaderGraph/Lerp-Node/#ports","text":"Name Direction Type Description A Input Dynamic Vector First input value B Input Dynamic Vector Second input value T Input Dynamic Vector Time value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Lerp-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Lerp_float4(float4 A, float4 B, float4 T, out float4 Out) { Out = lerp(A, B, T); }","title":"Generated Code Example"},{"location":"ShaderGraph/Log-Node/","text":"Log Node Description Returns the logarithm of input In . Log is the inverse operation to the Exponential Node . For example, the result of a base-2 Exponential using an input value of 3 is 8. Therefore the result of a base-2 Log using an input value of 8 is 3. The logarithmic base can be switched between base-e, base-2 and base-10 from the Base dropdown on the node. Ports Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value Controls Name Type Options Description Base Dropdown BaseE, Base2, Base10 Selects the logarithmic base Generated Code Example The following example code represents one possible outcome of this node per Base mode. Base E void Unity_Log_float4(float4 In, out float4 Out) { Out = log(In); } Base 2 void Unity_Log2_float4(float4 In, out float4 Out) { Out = log2(In); } Base 10 void Unity_Log10_float4(float4 In, out float4 Out) { Out = log10(In); }","title":"Log Node"},{"location":"ShaderGraph/Log-Node/#log-node","text":"","title":"Log Node"},{"location":"ShaderGraph/Log-Node/#description","text":"Returns the logarithm of input In . Log is the inverse operation to the Exponential Node . For example, the result of a base-2 Exponential using an input value of 3 is 8. Therefore the result of a base-2 Log using an input value of 8 is 3. The logarithmic base can be switched between base-e, base-2 and base-10 from the Base dropdown on the node.","title":"Description"},{"location":"ShaderGraph/Log-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Log-Node/#controls","text":"Name Type Options Description Base Dropdown BaseE, Base2, Base10 Selects the logarithmic base","title":"Controls"},{"location":"ShaderGraph/Log-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node per Base mode. Base E void Unity_Log_float4(float4 In, out float4 Out) { Out = log(In); } Base 2 void Unity_Log2_float4(float4 In, out float4 Out) { Out = log2(In); } Base 10 void Unity_Log10_float4(float4 In, out float4 Out) { Out = log10(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Master-Node/","text":"Master Node Description The Master Node is a special kind of Node . It is the end point of a Shader Graph that defines the final surface appearance of the shader. Your Shader Graph should always contain one, and only one, Master Node . The Master Node will automatically handle the conversion of a shader between different Scriptable Render Pipelines if there is an available backend. For a full list of all available Master Nodes see Master Nodes in the Node Library . Controls All Master Nodes share a common set of Controls although certain Master Nodes may include more. See Master Nodes for special Controls on different Master Nodes .","title":"Master Node"},{"location":"ShaderGraph/Master-Node/#master-node","text":"","title":"Master Node"},{"location":"ShaderGraph/Master-Node/#description","text":"The Master Node is a special kind of Node . It is the end point of a Shader Graph that defines the final surface appearance of the shader. Your Shader Graph should always contain one, and only one, Master Node . The Master Node will automatically handle the conversion of a shader between different Scriptable Render Pipelines if there is an available backend. For a full list of all available Master Nodes see Master Nodes in the Node Library .","title":"Description"},{"location":"ShaderGraph/Master-Node/#controls","text":"All Master Nodes share a common set of Controls although certain Master Nodes may include more. See Master Nodes for special Controls on different Master Nodes .","title":"Controls"},{"location":"ShaderGraph/Master-Nodes/","text":"Master Nodes PBR Master Unlit Master Master Node for physically based rendering. Master Node for unlit materials.","title":"Master Nodes"},{"location":"ShaderGraph/Master-Nodes/#master-nodes","text":"PBR Master Unlit Master Master Node for physically based rendering. Master Node for unlit materials.","title":"Master Nodes"},{"location":"ShaderGraph/Master-Preview/","text":"Master Preview Description The Master Preview displays a representation of the shader on the active Render Pipeline . It updates in real-time and automatically updates to display any changes you make in the Shader Graph . The title bar of the Master Preview displays the name of the current shader. The Master Preview can be moved to anywhere in the Shader Graph Window and will automatically move with the nearest corner of that window. Preview Mesh You can rotate the preview mesh by holding left mouse button and dragging on the Master Preview and you can scale it by using the scroll wheel. The preview mesh can be changed by right clicking on the Master Preview . Here you can select from any primitive mesh types or select a custom mesh.","title":"Master Preview"},{"location":"ShaderGraph/Master-Preview/#master-preview","text":"","title":"Master Preview"},{"location":"ShaderGraph/Master-Preview/#description","text":"The Master Preview displays a representation of the shader on the active Render Pipeline . It updates in real-time and automatically updates to display any changes you make in the Shader Graph . The title bar of the Master Preview displays the name of the current shader. The Master Preview can be moved to anywhere in the Shader Graph Window and will automatically move with the nearest corner of that window.","title":"Description"},{"location":"ShaderGraph/Master-Preview/#preview-mesh","text":"You can rotate the preview mesh by holding left mouse button and dragging on the Master Preview and you can scale it by using the scroll wheel. The preview mesh can be changed by right clicking on the Master Preview . Here you can select from any primitive mesh types or select a custom mesh.","title":"Preview Mesh"},{"location":"ShaderGraph/Math-Nodes/","text":"Math Nodes Advanced Absolute Exponential Returns the absolute value of input In. Returns the exponential value of input In. Length Log Returns the length of input In. Returns the logarithm of input In. Modulo Negate Returns the remainder of input A divided by input B. Returns the inverse value of input In. Normalize Posterize Returns the normalized vector of input In. Returns the input In converted into a number of values defined by input Steps. Reciprocal Reciprocal Square Root Returns the result of 1 divided by input In. Returns the result of 1 divided by the square root of input In. Basic Add Divide Returns the sum of the two input values. Returns the result of input A divided by input B. Multiply Power Returns the result of input A multiplied by input B. Returns the result of input A to the power of input B. Square Root Subtract Returns the square root of input In. Returns the result of input A minus input B. Derivative DDX DDXY Returns the partial derivative with respect to the screen-space x-coordinate. Returns the sum of both partial derivatives. DDY Returns the partial derivative with respect to the screen-space y-coordinate. Interpolation Inverse Lerp Lerp Returns the parameter that produces the interpolant specified by input T within the range of input A to input B. Returns the result of linearly interpolating between input A and input B by input T. Smoothstep Returns the result of a smooth Hermite interpolation between 0 and 1, if input In is between inputs Edge1 and Edge2. Matrix Matrix Construction Matrix Determinant Constructs square matrices from the four input vectors M0, M1, M2 and M3. Returns the determinant of the matrix defined by input In. Matrix Split Matrix Transpose Splits a square matrix defined by input In into vectors. Returns the transposed value of the matrix defined by input In. Range Clamp Fraction Returns the input In clamped between the minimum and maximum values defined by inputs Min and Max respectively. Returns the fractional (or decimal) part of input In; which is greater than or equal to 0 and less than 1. Maximum Minimum Returns the largest of the two inputs values A and B. Returns the smallest of the two inputs values A and B. One Minus Random Range Returns the result of input In subtracted from 1. Returns a pseudo-random number that is between the minimum and maximum values defined by inputs Min and Max. Remap Saturate Remaps the value of input In from between the values of input Out Min Max to between the values of input In Min Max. Returns the value of input In clamped between 0 and 1. Round Ceiling Floor Returns the smallest integer value, or whole number, that is greater than or equal to the value of input In. Returns the largest integer value, or whole number, that is less than or equal to the value of input In. Round Sign Returns the value of input In rounded to the nearest integer, or whole number. Returns -1 if the value of input In is less than zero, 0 if equal to zero and 1 if greater than zero. Step Truncate Returns 1 if the value of input In is greater than or equal to the value of input Edge, otherwise returns 0. Returns the integer, or whole number, component of the value of input In. Trigonometry Arccosine Arcsine Returns the arccosine of each component the input In as a vector of equal length. Returns the arcsine of each component the input In as a vector of equal length. Arctangent Arctangent2 Returns the arctangent of the value of input In. Each component should be within the range of -Pi/2 to Pi/2. Returns the arctangent of the values of both input A and input B. Cosine Degrees to Radians Returns the cosine of the value of input In. Returns the value of input In converted from degrees to radians. Hyperbolic Cosine Hyperbolic Sine Returns the hyperbolic cosine of input In. Returns the hyperbolic sine of input In. Hyperbolic Tangent Radians to Degrees Returns the hyperbolic tangent of input In. Returns the value of input In converted from radians to degrees. Sine Tangent Returns the sine of the value of input In. Returns the tangent of the value of input In. Vector Cross Product Distance Returns the cross product of the values of the inputs A and B. Returns the Euclidean distance between the values of the inputs A and B. Dot Product Fresnel Effect Returns the dot product, or scalar product, of the values of the inputs A and B. Fresnel Effect is the effect of differing reflectance on a surface depending on viewing angle, where as you approach the grazing angle more light is reflected. Projection Reflection Returns the result of projecting the value of input A onto a straight line parallel to the value of input B. Returns a reflection vector using input In and a surface normal Normal. Rejection Rotate About Axis Returns the result of the projection of the value of input A onto the plane orthogonal, or perpendicular, to the value of input B. Rotates the input vector In around the axis Axis by the value of Rotation. Projection Rejection Returns the result of projecting the value of input A onto a straight line parallel to the value of input B. Returns the result of the projection of the value of input A onto the plane orthogonal, or perpendicular, to the value of input B. Sphere Mask Transform Creates a sphere mask originating from input Center. Returns the result of transforming the value of input In from one coordinate space to another. Wave Noise Sine Wave Sawtooth Wave Returns the sine of the value of input In. For variance, random noise is added to the amplitude of the sine wave. Returns a sawtooth wave from the value of input In. Matrix Split Matrix Transpose Splits a square matrix defined by input In into vectors. Returns the transposed value of the matrix defined by input In. Noise Sine Wave Sawtooth Wave Square Wavve Triangle Wave","title":"Math Nodes"},{"location":"ShaderGraph/Math-Nodes/#math-nodes","text":"","title":"Math Nodes"},{"location":"ShaderGraph/Math-Nodes/#advanced","text":"Absolute Exponential Returns the absolute value of input In. Returns the exponential value of input In. Length Log Returns the length of input In. Returns the logarithm of input In. Modulo Negate Returns the remainder of input A divided by input B. Returns the inverse value of input In. Normalize Posterize Returns the normalized vector of input In. Returns the input In converted into a number of values defined by input Steps. Reciprocal Reciprocal Square Root Returns the result of 1 divided by input In. Returns the result of 1 divided by the square root of input In.","title":"Advanced"},{"location":"ShaderGraph/Math-Nodes/#basic","text":"Add Divide Returns the sum of the two input values. Returns the result of input A divided by input B. Multiply Power Returns the result of input A multiplied by input B. Returns the result of input A to the power of input B. Square Root Subtract Returns the square root of input In. Returns the result of input A minus input B.","title":"Basic"},{"location":"ShaderGraph/Math-Nodes/#derivative","text":"DDX DDXY Returns the partial derivative with respect to the screen-space x-coordinate. Returns the sum of both partial derivatives. DDY Returns the partial derivative with respect to the screen-space y-coordinate.","title":"Derivative"},{"location":"ShaderGraph/Math-Nodes/#interpolation","text":"Inverse Lerp Lerp Returns the parameter that produces the interpolant specified by input T within the range of input A to input B. Returns the result of linearly interpolating between input A and input B by input T. Smoothstep Returns the result of a smooth Hermite interpolation between 0 and 1, if input In is between inputs Edge1 and Edge2.","title":"Interpolation"},{"location":"ShaderGraph/Math-Nodes/#matrix","text":"Matrix Construction Matrix Determinant Constructs square matrices from the four input vectors M0, M1, M2 and M3. Returns the determinant of the matrix defined by input In. Matrix Split Matrix Transpose Splits a square matrix defined by input In into vectors. Returns the transposed value of the matrix defined by input In.","title":"Matrix"},{"location":"ShaderGraph/Math-Nodes/#range","text":"Clamp Fraction Returns the input In clamped between the minimum and maximum values defined by inputs Min and Max respectively. Returns the fractional (or decimal) part of input In; which is greater than or equal to 0 and less than 1. Maximum Minimum Returns the largest of the two inputs values A and B. Returns the smallest of the two inputs values A and B. One Minus Random Range Returns the result of input In subtracted from 1. Returns a pseudo-random number that is between the minimum and maximum values defined by inputs Min and Max. Remap Saturate Remaps the value of input In from between the values of input Out Min Max to between the values of input In Min Max. Returns the value of input In clamped between 0 and 1.","title":"Range"},{"location":"ShaderGraph/Math-Nodes/#round","text":"Ceiling Floor Returns the smallest integer value, or whole number, that is greater than or equal to the value of input In. Returns the largest integer value, or whole number, that is less than or equal to the value of input In. Round Sign Returns the value of input In rounded to the nearest integer, or whole number. Returns -1 if the value of input In is less than zero, 0 if equal to zero and 1 if greater than zero. Step Truncate Returns 1 if the value of input In is greater than or equal to the value of input Edge, otherwise returns 0. Returns the integer, or whole number, component of the value of input In.","title":"Round"},{"location":"ShaderGraph/Math-Nodes/#trigonometry","text":"Arccosine Arcsine Returns the arccosine of each component the input In as a vector of equal length. Returns the arcsine of each component the input In as a vector of equal length. Arctangent Arctangent2 Returns the arctangent of the value of input In. Each component should be within the range of -Pi/2 to Pi/2. Returns the arctangent of the values of both input A and input B. Cosine Degrees to Radians Returns the cosine of the value of input In. Returns the value of input In converted from degrees to radians. Hyperbolic Cosine Hyperbolic Sine Returns the hyperbolic cosine of input In. Returns the hyperbolic sine of input In. Hyperbolic Tangent Radians to Degrees Returns the hyperbolic tangent of input In. Returns the value of input In converted from radians to degrees. Sine Tangent Returns the sine of the value of input In. Returns the tangent of the value of input In.","title":"Trigonometry"},{"location":"ShaderGraph/Math-Nodes/#vector","text":"Cross Product Distance Returns the cross product of the values of the inputs A and B. Returns the Euclidean distance between the values of the inputs A and B. Dot Product Fresnel Effect Returns the dot product, or scalar product, of the values of the inputs A and B. Fresnel Effect is the effect of differing reflectance on a surface depending on viewing angle, where as you approach the grazing angle more light is reflected. Projection Reflection Returns the result of projecting the value of input A onto a straight line parallel to the value of input B. Returns a reflection vector using input In and a surface normal Normal. Rejection Rotate About Axis Returns the result of the projection of the value of input A onto the plane orthogonal, or perpendicular, to the value of input B. Rotates the input vector In around the axis Axis by the value of Rotation. Projection Rejection Returns the result of projecting the value of input A onto a straight line parallel to the value of input B. Returns the result of the projection of the value of input A onto the plane orthogonal, or perpendicular, to the value of input B. Sphere Mask Transform Creates a sphere mask originating from input Center. Returns the result of transforming the value of input In from one coordinate space to another.","title":"Vector"},{"location":"ShaderGraph/Math-Nodes/#wave","text":"Noise Sine Wave Sawtooth Wave Returns the sine of the value of input In. For variance, random noise is added to the amplitude of the sine wave. Returns a sawtooth wave from the value of input In. Matrix Split Matrix Transpose Splits a square matrix defined by input In into vectors. Returns the transposed value of the matrix defined by input In. Noise Sine Wave Sawtooth Wave Square Wavve Triangle Wave","title":"Wave"},{"location":"ShaderGraph/Matrix-2x2-Node/","text":"Matrix 2x2 Node Description Defines a constant Matrix 2x2 value in the shader. Ports Name Direction Type Binding Description Out Output Matrix 2 None Output value Controls Name Type Options Description Matrix 2x2 Sets output value Generated Code Example The following example code represents one possible outcome of this node. float2x2 _Matrix2x2 = float2x2(1, 0, 0, 1);","title":"Matrix 2x2 Node"},{"location":"ShaderGraph/Matrix-2x2-Node/#matrix-2x2-node","text":"","title":"Matrix 2x2 Node"},{"location":"ShaderGraph/Matrix-2x2-Node/#description","text":"Defines a constant Matrix 2x2 value in the shader.","title":"Description"},{"location":"ShaderGraph/Matrix-2x2-Node/#ports","text":"Name Direction Type Binding Description Out Output Matrix 2 None Output value","title":"Ports"},{"location":"ShaderGraph/Matrix-2x2-Node/#controls","text":"Name Type Options Description Matrix 2x2 Sets output value","title":"Controls"},{"location":"ShaderGraph/Matrix-2x2-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. float2x2 _Matrix2x2 = float2x2(1, 0, 0, 1);","title":"Generated Code Example"},{"location":"ShaderGraph/Matrix-3x3-Node/","text":"Matrix 3x3 Node Description Defines a constant Matrix 3x3 value in the shader. Ports Name Direction Type Binding Description Out Output Matrix 3 None Output value Controls Name Type Options Description Matrix 3x3 Sets output value Generated Code Example The following example code represents one possible outcome of this node. float3x3 _Matrix3x3 = float3x3(1, 0, 0, 0, 1, 0, 0, 0, 1);","title":"Matrix 3x3 Node"},{"location":"ShaderGraph/Matrix-3x3-Node/#matrix-3x3-node","text":"","title":"Matrix 3x3 Node"},{"location":"ShaderGraph/Matrix-3x3-Node/#description","text":"Defines a constant Matrix 3x3 value in the shader.","title":"Description"},{"location":"ShaderGraph/Matrix-3x3-Node/#ports","text":"Name Direction Type Binding Description Out Output Matrix 3 None Output value","title":"Ports"},{"location":"ShaderGraph/Matrix-3x3-Node/#controls","text":"Name Type Options Description Matrix 3x3 Sets output value","title":"Controls"},{"location":"ShaderGraph/Matrix-3x3-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. float3x3 _Matrix3x3 = float3x3(1, 0, 0, 0, 1, 0, 0, 0, 1);","title":"Generated Code Example"},{"location":"ShaderGraph/Matrix-4x4-Node/","text":"Matrix 4x4 Node Description Defines a constant Matrix 4x4 value in the shader. Ports Name Direction Type Binding Description Out Output Matrix 4 None Output value Controls Name Type Options Description Matrix 4x4 Sets output value Generated Code Example The following example code represents one possible outcome of this node. float4x4 _Matrix4x4 = float4x4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);","title":"Matrix 4x4 Node"},{"location":"ShaderGraph/Matrix-4x4-Node/#matrix-4x4-node","text":"","title":"Matrix 4x4 Node"},{"location":"ShaderGraph/Matrix-4x4-Node/#description","text":"Defines a constant Matrix 4x4 value in the shader.","title":"Description"},{"location":"ShaderGraph/Matrix-4x4-Node/#ports","text":"Name Direction Type Binding Description Out Output Matrix 4 None Output value","title":"Ports"},{"location":"ShaderGraph/Matrix-4x4-Node/#controls","text":"Name Type Options Description Matrix 4x4 Sets output value","title":"Controls"},{"location":"ShaderGraph/Matrix-4x4-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. float4x4 _Matrix4x4 = float4x4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);","title":"Generated Code Example"},{"location":"ShaderGraph/Matrix-Construction-Node/","text":"Matrix Construction Node Description Constructs square matrices from the four input vectors M0 , M1 , M2 and M3 . This node can be used to generate matrices of types Matrix 2x2 , Matrix 3x3 and Matrix 4x4 . The dropdown on the node can be used to select whether the inputs values specify the matrix rows or columns. Row : Input vectors specify matrix rows from top to bottom. Column : Input vectors specify matrix columns from left to right. Matrix outputs are taken from the top left corner of the construction of the inputs. This can be used to generate different dimension square matrices from different dimension vectors. For example, connecting Vector 2 type values to inputs M0 and M1 will generate the desired matrix from the output 2x2 . Ports Name Direction Type Description M0 Input Vector 4 First row or column M1 Input Vector 4 Second row or column M2 Input Vector 4 Third row or column M3 Input Vector 4 Fourth row or column 4x4 Output Matrix 4x4 Output as Matrix 4x4 3x3 Output Matrix 3x3 Output as Matrix 3x3 2x2 Output Matrix 2x2 Output as Matrix 2x2 Controls Name Type Options Description Dropdown Row, Column Selects how the output matrix should be filled Generated Code Example The following example code represents one possible outcome of this node per mode. Row void Unity_MatrixConstruction_Row_float(float4 M0, float4 M1, float4 M2, float3 M3, out float4x4 Out4x4, out float3x3 Out3x3, out float2x2 Out2x2) { Out4x4 = float4x4(M0.x, M0.y, M0.z, M0.w, M1.x, M1.y, M1.z, M1.w, M2.x, M2.y, M2.z, M2.w, M3.x, M3.y, M3.z, M3.w); Out3x3 = float3x3(M0.x, M0.y, M0.z, M1.x, M1.y, M1.z, M2.x, M2.y, M2.z); Out2x2 = float2x2(M0.x, M0.y, M1.x, M1.y); } Column void Unity_MatrixConstruction_Column_float(float4 M0, float4 M1, float4 M2, float3 M3, out float4x4 Out4x4, out float3x3 Out3x3, out float2x2 Out2x2) { Out4x4 = float4x4(M0.x, M1.x, M2.x, M3.x, M0.y, M1.y, M2.y, M3.y, M0.z, M1.z, M2.z, M3.z, M0.w, M1.w, M2.w, M3.w); Out3x3 = float3x3(M0.x, M1.x, M2.x, M0.y, M1.y, M2.y, M0.z, M1.z, M2.z); Out2x2 = float2x2(M0.x, M1.x, M0.y, M1.y); }","title":"Matrix Construction Node"},{"location":"ShaderGraph/Matrix-Construction-Node/#matrix-construction-node","text":"","title":"Matrix Construction Node"},{"location":"ShaderGraph/Matrix-Construction-Node/#description","text":"Constructs square matrices from the four input vectors M0 , M1 , M2 and M3 . This node can be used to generate matrices of types Matrix 2x2 , Matrix 3x3 and Matrix 4x4 . The dropdown on the node can be used to select whether the inputs values specify the matrix rows or columns. Row : Input vectors specify matrix rows from top to bottom. Column : Input vectors specify matrix columns from left to right. Matrix outputs are taken from the top left corner of the construction of the inputs. This can be used to generate different dimension square matrices from different dimension vectors. For example, connecting Vector 2 type values to inputs M0 and M1 will generate the desired matrix from the output 2x2 .","title":"Description"},{"location":"ShaderGraph/Matrix-Construction-Node/#ports","text":"Name Direction Type Description M0 Input Vector 4 First row or column M1 Input Vector 4 Second row or column M2 Input Vector 4 Third row or column M3 Input Vector 4 Fourth row or column 4x4 Output Matrix 4x4 Output as Matrix 4x4 3x3 Output Matrix 3x3 Output as Matrix 3x3 2x2 Output Matrix 2x2 Output as Matrix 2x2","title":"Ports"},{"location":"ShaderGraph/Matrix-Construction-Node/#controls","text":"Name Type Options Description Dropdown Row, Column Selects how the output matrix should be filled","title":"Controls"},{"location":"ShaderGraph/Matrix-Construction-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node per mode. Row void Unity_MatrixConstruction_Row_float(float4 M0, float4 M1, float4 M2, float3 M3, out float4x4 Out4x4, out float3x3 Out3x3, out float2x2 Out2x2) { Out4x4 = float4x4(M0.x, M0.y, M0.z, M0.w, M1.x, M1.y, M1.z, M1.w, M2.x, M2.y, M2.z, M2.w, M3.x, M3.y, M3.z, M3.w); Out3x3 = float3x3(M0.x, M0.y, M0.z, M1.x, M1.y, M1.z, M2.x, M2.y, M2.z); Out2x2 = float2x2(M0.x, M0.y, M1.x, M1.y); } Column void Unity_MatrixConstruction_Column_float(float4 M0, float4 M1, float4 M2, float3 M3, out float4x4 Out4x4, out float3x3 Out3x3, out float2x2 Out2x2) { Out4x4 = float4x4(M0.x, M1.x, M2.x, M3.x, M0.y, M1.y, M2.y, M3.y, M0.z, M1.z, M2.z, M3.z, M0.w, M1.w, M2.w, M3.w); Out3x3 = float3x3(M0.x, M1.x, M2.x, M0.y, M1.y, M2.y, M0.z, M1.z, M2.z); Out2x2 = float2x2(M0.x, M1.x, M0.y, M1.y); }","title":"Generated Code Example"},{"location":"ShaderGraph/Matrix-Determinant-Node/","text":"Matrix Determinant Description Returns the determinant of the matrix defined by input In . It can be viewed as the scaling factor of the transformation described by the matrix. Ports Name Direction Type Description In Input Dynamic Matrix Input value Out Output Vector 1 Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_MatrixDeterminant_float4x4(float4x4 In, out float Out) { Out = determinant(In); }","title":"Matrix Determinant"},{"location":"ShaderGraph/Matrix-Determinant-Node/#matrix-determinant","text":"","title":"Matrix Determinant"},{"location":"ShaderGraph/Matrix-Determinant-Node/#description","text":"Returns the determinant of the matrix defined by input In . It can be viewed as the scaling factor of the transformation described by the matrix.","title":"Description"},{"location":"ShaderGraph/Matrix-Determinant-Node/#ports","text":"Name Direction Type Description In Input Dynamic Matrix Input value Out Output Vector 1 Output value","title":"Ports"},{"location":"ShaderGraph/Matrix-Determinant-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_MatrixDeterminant_float4x4(float4x4 In, out float Out) { Out = determinant(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Matrix-Split-Node/","text":"Matrix Split Node Description Splits a square matrix defined by input In into vectors. Output vector dimension is defined by the dimension of the input matrix. The dropdown on the node can be used to select whether the output values are taken from the rows or columns of the input matrix. Row : Output vectors are composed of matrix rows from top to bottom. Column : Output vectors are composed of matrix columns from left to right. An input matrix of type Matrix 2x2 or Matrix 3x3 will return 0 values in the rows (or columns, depending on dropdown selection) that are beyond their dimension. For example, connecting Matrix 2x2 type to input In will return the correct Vector 2 type outputs to output slots M0 and M1 , leaving outputs M2 and M3 to return 0 values. Ports Name Direction Type Description In Input Dynamic Matrix Input value M0 Output Dynamic Vector First row or column M1 Output Dynamic Vector Second row or column M2 Output Dynamic Vector Third row or column M3 Output Dynamic Vector Fourth row or column Controls Name Type Options Description Dropdown Row, Column Selects how the output vectors should be filled Generated Code Example The following example code represents one possible outcome of this node. float2 _MatrixSplit_M0 = float2(In[0].r, In[0].g); float2 _MatrixSplit_M1 = float2(In[1].r, In[1].g); float2 _MatrixSplit_M2 = float2(0, 0); float2 _MatrixSplit_M3 = float2(0, 0);","title":"Matrix Split Node"},{"location":"ShaderGraph/Matrix-Split-Node/#matrix-split-node","text":"","title":"Matrix Split Node"},{"location":"ShaderGraph/Matrix-Split-Node/#description","text":"Splits a square matrix defined by input In into vectors. Output vector dimension is defined by the dimension of the input matrix. The dropdown on the node can be used to select whether the output values are taken from the rows or columns of the input matrix. Row : Output vectors are composed of matrix rows from top to bottom. Column : Output vectors are composed of matrix columns from left to right. An input matrix of type Matrix 2x2 or Matrix 3x3 will return 0 values in the rows (or columns, depending on dropdown selection) that are beyond their dimension. For example, connecting Matrix 2x2 type to input In will return the correct Vector 2 type outputs to output slots M0 and M1 , leaving outputs M2 and M3 to return 0 values.","title":"Description"},{"location":"ShaderGraph/Matrix-Split-Node/#ports","text":"Name Direction Type Description In Input Dynamic Matrix Input value M0 Output Dynamic Vector First row or column M1 Output Dynamic Vector Second row or column M2 Output Dynamic Vector Third row or column M3 Output Dynamic Vector Fourth row or column","title":"Ports"},{"location":"ShaderGraph/Matrix-Split-Node/#controls","text":"Name Type Options Description Dropdown Row, Column Selects how the output vectors should be filled","title":"Controls"},{"location":"ShaderGraph/Matrix-Split-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. float2 _MatrixSplit_M0 = float2(In[0].r, In[0].g); float2 _MatrixSplit_M1 = float2(In[1].r, In[1].g); float2 _MatrixSplit_M2 = float2(0, 0); float2 _MatrixSplit_M3 = float2(0, 0);","title":"Generated Code Example"},{"location":"ShaderGraph/Matrix-Transpose-Node/","text":"Matrix Transpose Description Returns the transposed value of the matrix defined by input In . This can be seen as the operation of flipping the matrix over its diagonal. The result is that it switches the row and column indices of the matrix. Ports Name Direction Type Description In Input Dynamic Matrix Input value Out Output Dynamic Matrix Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_MatrixTranspose_float4x4(float4x4 In, out float4x4 Out) { Out = transpose(In); }","title":"Matrix Transpose"},{"location":"ShaderGraph/Matrix-Transpose-Node/#matrix-transpose","text":"","title":"Matrix Transpose"},{"location":"ShaderGraph/Matrix-Transpose-Node/#description","text":"Returns the transposed value of the matrix defined by input In . This can be seen as the operation of flipping the matrix over its diagonal. The result is that it switches the row and column indices of the matrix.","title":"Description"},{"location":"ShaderGraph/Matrix-Transpose-Node/#ports","text":"Name Direction Type Description In Input Dynamic Matrix Input value Out Output Dynamic Matrix Output value","title":"Ports"},{"location":"ShaderGraph/Matrix-Transpose-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_MatrixTranspose_float4x4(float4x4 In, out float4x4 Out) { Out = transpose(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Maximum-Node/","text":"Maximum Node Description Returns the largest of the two inputs values A and B . Ports Name Direction Type Description A Input Dynamic Vector First input value B Input Dynamic Vector Second input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Maximum_float4(float4 A, float4 B, out float4 Out) { Out = max(A, B); }","title":"Maximum Node"},{"location":"ShaderGraph/Maximum-Node/#maximum-node","text":"","title":"Maximum Node"},{"location":"ShaderGraph/Maximum-Node/#description","text":"Returns the largest of the two inputs values A and B .","title":"Description"},{"location":"ShaderGraph/Maximum-Node/#ports","text":"Name Direction Type Description A Input Dynamic Vector First input value B Input Dynamic Vector Second input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Maximum-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Maximum_float4(float4 A, float4 B, out float4 Out) { Out = max(A, B); }","title":"Generated Code Example"},{"location":"ShaderGraph/Metal-Reflectance-Node/","text":"Metal Reflectance Node Description Returns a Metal Reflectance value for a physically based material. The material to use can be selected with the Material dropdown parameter on the Node . When using Specular Workflow on a PBR Master Node this value should be supplied to the Specular Port . When using Metallic Workflow this value should be supplied to the Albedo Port . Ports Name Direction Type Binding Description Out Output Vector 3 None Output value Controls Name Type Options Description Material Dropdown Iron, Silver, Aluminium, Gold, Copper, Chromium, Nickel, Titanium, Cobalt, Platform Selects the material value to output. Generated Code Example The following example code represents one possible outcome of this node. Iron float3 _MetalReflectance_Out = float3(0.560, 0.570, 0.580); Silver float3 _MetalReflectance_Out = float3(0.972, 0.960, 0.915); Aluminium float3 _MetalReflectance_Out = float3(0.913, 0.921, 0.925); Gold float3 _MetalReflectance_Out = float3(1.000, 0.766, 0.336); Copper float3 _MetalReflectance_Out = float3(0.955, 0.637, 0.538); Chromium float3 _MetalReflectance_Out = float3(0.550, 0.556, 0.554); Nickel float3 _MetalReflectance_Out = float3(0.660, 0.609, 0.526); Titanium float3 _MetalReflectance_Out = float3(0.542, 0.497, 0.449); Cobalt float3 _MetalReflectance_Out = float3(0.662, 0.655, 0.634); Platinum float3 _MetalReflectance_Out = float3(0.672, 0.637, 0.585);","title":"Metal Reflectance Node"},{"location":"ShaderGraph/Metal-Reflectance-Node/#metal-reflectance-node","text":"","title":"Metal Reflectance Node"},{"location":"ShaderGraph/Metal-Reflectance-Node/#description","text":"Returns a Metal Reflectance value for a physically based material. The material to use can be selected with the Material dropdown parameter on the Node . When using Specular Workflow on a PBR Master Node this value should be supplied to the Specular Port . When using Metallic Workflow this value should be supplied to the Albedo Port .","title":"Description"},{"location":"ShaderGraph/Metal-Reflectance-Node/#ports","text":"Name Direction Type Binding Description Out Output Vector 3 None Output value","title":"Ports"},{"location":"ShaderGraph/Metal-Reflectance-Node/#controls","text":"Name Type Options Description Material Dropdown Iron, Silver, Aluminium, Gold, Copper, Chromium, Nickel, Titanium, Cobalt, Platform Selects the material value to output.","title":"Controls"},{"location":"ShaderGraph/Metal-Reflectance-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. Iron float3 _MetalReflectance_Out = float3(0.560, 0.570, 0.580); Silver float3 _MetalReflectance_Out = float3(0.972, 0.960, 0.915); Aluminium float3 _MetalReflectance_Out = float3(0.913, 0.921, 0.925); Gold float3 _MetalReflectance_Out = float3(1.000, 0.766, 0.336); Copper float3 _MetalReflectance_Out = float3(0.955, 0.637, 0.538); Chromium float3 _MetalReflectance_Out = float3(0.550, 0.556, 0.554); Nickel float3 _MetalReflectance_Out = float3(0.660, 0.609, 0.526); Titanium float3 _MetalReflectance_Out = float3(0.542, 0.497, 0.449); Cobalt float3 _MetalReflectance_Out = float3(0.662, 0.655, 0.634); Platinum float3 _MetalReflectance_Out = float3(0.672, 0.637, 0.585);","title":"Generated Code Example"},{"location":"ShaderGraph/Minimum-Node/","text":"Minimum Node Description Returns the smallest of the two inputs values A and B . Ports Name Direction Type Description A Input Dynamic Vector First input value B Input Dynamic Vector Second input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Minimum_float4(float4 A, float4 B, out float4 Out) { Out = min(A, B); }","title":"Minimum Node"},{"location":"ShaderGraph/Minimum-Node/#minimum-node","text":"","title":"Minimum Node"},{"location":"ShaderGraph/Minimum-Node/#description","text":"Returns the smallest of the two inputs values A and B .","title":"Description"},{"location":"ShaderGraph/Minimum-Node/#ports","text":"Name Direction Type Description A Input Dynamic Vector First input value B Input Dynamic Vector Second input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Minimum-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Minimum_float4(float4 A, float4 B, out float4 Out) { Out = min(A, B); }","title":"Generated Code Example"},{"location":"ShaderGraph/Modulo-Node/","text":"Modulo Node Description Returns the remainder of dividing input A by input B . Ports Name Direction Type Description A Input Dynamic Vector First input value B Input Dynamic Vector Second input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Modulo_float4(float4 A, float4 B, out float4 Out) { Out = fmod(A, B); }","title":"Modulo Node"},{"location":"ShaderGraph/Modulo-Node/#modulo-node","text":"","title":"Modulo Node"},{"location":"ShaderGraph/Modulo-Node/#description","text":"Returns the remainder of dividing input A by input B .","title":"Description"},{"location":"ShaderGraph/Modulo-Node/#ports","text":"Name Direction Type Description A Input Dynamic Vector First input value B Input Dynamic Vector Second input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Modulo-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Modulo_float4(float4 A, float4 B, out float4 Out) { Out = fmod(A, B); }","title":"Generated Code Example"},{"location":"ShaderGraph/Multiply-Node/","text":"Multiply Node Description Returns the result of input A multiplied by input B . If both inputs are a vector type, the output type will be a vector type with the same dimension as the evaluated type of those inputs. If both inputs are a matrix type, the output type will be a matrix type with the same dimension as the evaluated type of those inputs. If one input is a vector type and the other is a matrix type, then output type will be a vector with the same dimension as the vector type input. Ports Name Direction Type Description A Input Dynamic First input value B Input Dynamic Second input value Out Output Dynamic Output value Generated Code Example The following example code represents different possible outcomes of this node. Vector * Vector void Unity_Multiply_float4_float4(float4 A, float4 B, out float4 Out) { Out = A * B; } Vector * Matrix void Unity_Multiply_float4_float4x4(float4 A, float4x4 B, out float4 Out) { Out = mul(A, B); } Matrix * Matrix void Unity_Multiply_float4x4_float4x4(float4x4 A, float4x4 B, out float4x4 Out) { Out = mul(A, B); }","title":"Multiply Node"},{"location":"ShaderGraph/Multiply-Node/#multiply-node","text":"","title":"Multiply Node"},{"location":"ShaderGraph/Multiply-Node/#description","text":"Returns the result of input A multiplied by input B . If both inputs are a vector type, the output type will be a vector type with the same dimension as the evaluated type of those inputs. If both inputs are a matrix type, the output type will be a matrix type with the same dimension as the evaluated type of those inputs. If one input is a vector type and the other is a matrix type, then output type will be a vector with the same dimension as the vector type input.","title":"Description"},{"location":"ShaderGraph/Multiply-Node/#ports","text":"Name Direction Type Description A Input Dynamic First input value B Input Dynamic Second input value Out Output Dynamic Output value","title":"Ports"},{"location":"ShaderGraph/Multiply-Node/#generated-code-example","text":"The following example code represents different possible outcomes of this node. Vector * Vector void Unity_Multiply_float4_float4(float4 A, float4 B, out float4 Out) { Out = A * B; } Vector * Matrix void Unity_Multiply_float4_float4x4(float4 A, float4x4 B, out float4 Out) { Out = mul(A, B); } Matrix * Matrix void Unity_Multiply_float4x4_float4x4(float4x4 A, float4x4 B, out float4x4 Out) { Out = mul(A, B); }","title":"Generated Code Example"},{"location":"ShaderGraph/Nand-Node/","text":"Nand Node Description Returns true if both the inputs A and B are false. This is useful for Branching . Ports Name Direction Type Binding Description A Input Boolean None First input value B Input Boolean None Second input value Out Output Boolean None Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Nand_float(float A, float B, out float Out) { Out = !A && !B; }","title":"Nand Node"},{"location":"ShaderGraph/Nand-Node/#nand-node","text":"","title":"Nand Node"},{"location":"ShaderGraph/Nand-Node/#description","text":"Returns true if both the inputs A and B are false. This is useful for Branching .","title":"Description"},{"location":"ShaderGraph/Nand-Node/#ports","text":"Name Direction Type Binding Description A Input Boolean None First input value B Input Boolean None Second input value Out Output Boolean None Output value","title":"Ports"},{"location":"ShaderGraph/Nand-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Nand_float(float A, float B, out float Out) { Out = !A && !B; }","title":"Generated Code Example"},{"location":"ShaderGraph/Negate-Node/","text":"Negate Node Description Returns the flipped sign value of input In . Positive values become negative and negative values become positive. Ports Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Negate_float4(float4 In, out float4 Out) { Out = -1 * In; }","title":"Negate Node"},{"location":"ShaderGraph/Negate-Node/#negate-node","text":"","title":"Negate Node"},{"location":"ShaderGraph/Negate-Node/#description","text":"Returns the flipped sign value of input In . Positive values become negative and negative values become positive.","title":"Description"},{"location":"ShaderGraph/Negate-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Negate-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Negate_float4(float4 In, out float4 Out) { Out = -1 * In; }","title":"Generated Code Example"},{"location":"ShaderGraph/Node-Library/","text":"Node Library Description The Node Library contains documentation for all the individual Nodes in Shader Graph ; including descriptions, ports, parameters, shader code and example images. The Nodes are organised in the same categories as found in the Create Node Menu for convenience. Categories Artistic Channel Input Master Math Procedural Utility UV","title":"Node Library"},{"location":"ShaderGraph/Node-Library/#node-library","text":"","title":"Node Library"},{"location":"ShaderGraph/Node-Library/#description","text":"The Node Library contains documentation for all the individual Nodes in Shader Graph ; including descriptions, ports, parameters, shader code and example images. The Nodes are organised in the same categories as found in the Create Node Menu for convenience.","title":"Description"},{"location":"ShaderGraph/Node-Library/#categories","text":"Artistic Channel Input Master Math Procedural Utility UV","title":"Categories"},{"location":"ShaderGraph/Node/","text":"Node Description A Node defines an input, output or operation on the Shader Graph , depending on its available Ports . A Node may have any number of input and/or output Ports . You create a Shader Graph by connecting these Ports with Edges . A Node might also have any number of Controls , these are controls on the Node that do not have Ports . You can collapse a Node by clicking the Collapse button in the top-right corner of the Node . This will hide all unconnected Ports . For components of a Node see: Port Edge There are many available Nodes in Shader Graph . For a full list of all available Nodes see the Node Library . Preview Some Nodes have a preview on the Node . This preview displays the main output value at that stage in the graph. The preview can be hidden with the Collapse button at the top of the preview. This is displayed when the mouse cursor is hovering over the node. You can also collapse and expand previews on all node via the context menu on the Shader Graph Window . Context Menu Right clicking on a Node will open a context menu. This menu contains many operations that can be performed on the Node . Note that when multiple nodes are selected, these operations will be applied to the entire selection. Item Description Copy Shader Copies the generated HLSL code at this stage in the graph to the clipboard Disconnect All Removes all Edges from all Ports on the Node(s) Cut Cuts selected Node(s) to the clipboard Copy Copies selected Nodes(s) to the clipboard Paste Pastes Node(s) in the clipboard Delete Deletes selected Node(s) Duplicate Duplicates selected Node(s) Convert To Sub-graph Creates a new Sub-graph Asset with the selected Node(s) included Convert To Inline Node Converts a Property Node into a regular node of the appropriate Data Type Convert To Property Converts a Node into a new Property on the Blackboard of the appropriate Property Type Open Documentation Opens a new web browser to the selected Nodes documentation page in the Node Library","title":"Node"},{"location":"ShaderGraph/Node/#node","text":"","title":"Node"},{"location":"ShaderGraph/Node/#description","text":"A Node defines an input, output or operation on the Shader Graph , depending on its available Ports . A Node may have any number of input and/or output Ports . You create a Shader Graph by connecting these Ports with Edges . A Node might also have any number of Controls , these are controls on the Node that do not have Ports . You can collapse a Node by clicking the Collapse button in the top-right corner of the Node . This will hide all unconnected Ports . For components of a Node see: Port Edge There are many available Nodes in Shader Graph . For a full list of all available Nodes see the Node Library .","title":"Description"},{"location":"ShaderGraph/Node/#preview","text":"Some Nodes have a preview on the Node . This preview displays the main output value at that stage in the graph. The preview can be hidden with the Collapse button at the top of the preview. This is displayed when the mouse cursor is hovering over the node. You can also collapse and expand previews on all node via the context menu on the Shader Graph Window .","title":"Preview"},{"location":"ShaderGraph/Node/#context-menu","text":"Right clicking on a Node will open a context menu. This menu contains many operations that can be performed on the Node . Note that when multiple nodes are selected, these operations will be applied to the entire selection. Item Description Copy Shader Copies the generated HLSL code at this stage in the graph to the clipboard Disconnect All Removes all Edges from all Ports on the Node(s) Cut Cuts selected Node(s) to the clipboard Copy Copies selected Nodes(s) to the clipboard Paste Pastes Node(s) in the clipboard Delete Deletes selected Node(s) Duplicate Duplicates selected Node(s) Convert To Sub-graph Creates a new Sub-graph Asset with the selected Node(s) included Convert To Inline Node Converts a Property Node into a regular node of the appropriate Data Type Convert To Property Converts a Node into a new Property on the Blackboard of the appropriate Property Type Open Documentation Opens a new web browser to the selected Nodes documentation page in the Node Library","title":"Context Menu"},{"location":"ShaderGraph/Noise-Sine-Wave-Node/","text":"Noise Sine Wave Node Description Returns the sine of the value of input In . For variance, psuedo-random noise is added to the amplitude of the sine wave, within a range determined by input Min Max . Ports Name Direction Type Description In Input Dynamic Vector Input value Min Max Input Vector 2 Minimum and Maximum values for noise intensity Out Output Dynamic Vector Output value Generated Code Example void Unity_NoiseSineWave_float4(float4 In, float2 MinMax, out float4 Out) { float sinIn = sin(In); float sinInOffset = sin(In + 1.0); float randomno = frac(sin((sinIn - sinInOffset) * (12.9898 + 78.233))*43758.5453); float noise = lerp(MinMax.x, MinMax.y, randomno); Out = sinIn + noise; }","title":"Noise Sine Wave Node"},{"location":"ShaderGraph/Noise-Sine-Wave-Node/#noise-sine-wave-node","text":"","title":"Noise Sine Wave Node"},{"location":"ShaderGraph/Noise-Sine-Wave-Node/#description","text":"Returns the sine of the value of input In . For variance, psuedo-random noise is added to the amplitude of the sine wave, within a range determined by input Min Max .","title":"Description"},{"location":"ShaderGraph/Noise-Sine-Wave-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Min Max Input Vector 2 Minimum and Maximum values for noise intensity Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Noise-Sine-Wave-Node/#generated-code-example","text":"void Unity_NoiseSineWave_float4(float4 In, float2 MinMax, out float4 Out) { float sinIn = sin(In); float sinInOffset = sin(In + 1.0); float randomno = frac(sin((sinIn - sinInOffset) * (12.9898 + 78.233))*43758.5453); float noise = lerp(MinMax.x, MinMax.y, randomno); Out = sinIn + noise; }","title":"Generated Code Example"},{"location":"ShaderGraph/Normal-Blend-Node/","text":"Normal Blend Node Description Blends two normal maps defined by inputs A and B together, normalizing the result to create a valid normal map. Ports Name Direction Type Binding Description A Input Vector 3 None First input value B Input Vector 3 None Second input value Out Output Vector 3 None Output value Controls Name Type Options Description Mode Dropdown Default, Reoriented Selects the the method used for blending. Generated Code Example The following example code represents one possible outcome of this node per Mode . Default void Unity_NormalBlend_float(float3 A, float3 B, out float3 Out) { Out = normalize(float3(A.rg + B.rg, A.b * B.b)); } Reoriented void Unity_NormalBlend_Reoriented_float(float3 A, float3 B, out float3 Out) { float3 t = A.xyz + float3(0.0, 0.0, 1.0); float3 u = B.xyz * float3(-1.0, -1.0, 1.0); Out = (t / t.z) * dot(t, u) - u; }","title":"Normal Blend Node"},{"location":"ShaderGraph/Normal-Blend-Node/#normal-blend-node","text":"","title":"Normal Blend Node"},{"location":"ShaderGraph/Normal-Blend-Node/#description","text":"Blends two normal maps defined by inputs A and B together, normalizing the result to create a valid normal map.","title":"Description"},{"location":"ShaderGraph/Normal-Blend-Node/#ports","text":"Name Direction Type Binding Description A Input Vector 3 None First input value B Input Vector 3 None Second input value Out Output Vector 3 None Output value","title":"Ports"},{"location":"ShaderGraph/Normal-Blend-Node/#controls","text":"Name Type Options Description Mode Dropdown Default, Reoriented Selects the the method used for blending.","title":"Controls"},{"location":"ShaderGraph/Normal-Blend-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node per Mode . Default void Unity_NormalBlend_float(float3 A, float3 B, out float3 Out) { Out = normalize(float3(A.rg + B.rg, A.b * B.b)); } Reoriented void Unity_NormalBlend_Reoriented_float(float3 A, float3 B, out float3 Out) { float3 t = A.xyz + float3(0.0, 0.0, 1.0); float3 u = B.xyz * float3(-1.0, -1.0, 1.0); Out = (t / t.z) * dot(t, u) - u; }","title":"Generated Code Example"},{"location":"ShaderGraph/Normal-From-Height-Node/","text":"Normal From Height Node Description Creates a normal map from a height value defined by input Input . Ports Name Direction Type Description In Input Vector 1 Input height value Out Output Vector 3 Output value Controls Name Type Options Description Output Space Dropdown Tangent, World Sets the coordinate space of the output normal. Generated Code Example The following example code represents one possible outcome of this node per Output Space mode. Tangent void Unity_NormalFromHeight_Tangent(float In, out float3 Out) { float3 worldDirivativeX = ddx(Position * 100); float3 worldDirivativeY = ddy(Position * 100); float3 crossX = cross(TangentMatrix[2].xyz, worldDirivativeX); float3 crossY = cross(TangentMatrix[2].xyz, worldDirivativeY); float3 d = abs(dot(crossY, worldDirivativeX)); float3 inToNormal = ((((In + ddx(In)) - In) * crossY) + (((In + ddy(In)) - In) * crossX)) * sign(d); inToNormal.y *= -1.0; Out = normalize((d * TangentMatrix[2].xyz) - inToNormal); Out = TransformWorldToTangent(Out, TangentMatrix); } World void Unity_NormalFromHeight_World(float In, out float3 Out) { float3 worldDirivativeX = ddx(Position * 100); float3 worldDirivativeY = ddy(Position * 100); float3 crossX = cross(TangentMatrix[2].xyz, worldDirivativeX); float3 crossY = cross(TangentMatrix[2].xyz, worldDirivativeY); float3 d = abs(dot(crossY, worldDirivativeX)); float3 inToNormal = ((((In + ddx(In)) - In) * crossY) + (((In + ddy(In)) - In) * crossX)) * sign(d); inToNormal.y *= -1.0; Out = normalize((d * TangentMatrix[2].xyz) - inToNormal); }","title":"Normal From Height Node"},{"location":"ShaderGraph/Normal-From-Height-Node/#normal-from-height-node","text":"","title":"Normal From Height Node"},{"location":"ShaderGraph/Normal-From-Height-Node/#description","text":"Creates a normal map from a height value defined by input Input .","title":"Description"},{"location":"ShaderGraph/Normal-From-Height-Node/#ports","text":"Name Direction Type Description In Input Vector 1 Input height value Out Output Vector 3 Output value","title":"Ports"},{"location":"ShaderGraph/Normal-From-Height-Node/#controls","text":"Name Type Options Description Output Space Dropdown Tangent, World Sets the coordinate space of the output normal.","title":"Controls"},{"location":"ShaderGraph/Normal-From-Height-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node per Output Space mode. Tangent void Unity_NormalFromHeight_Tangent(float In, out float3 Out) { float3 worldDirivativeX = ddx(Position * 100); float3 worldDirivativeY = ddy(Position * 100); float3 crossX = cross(TangentMatrix[2].xyz, worldDirivativeX); float3 crossY = cross(TangentMatrix[2].xyz, worldDirivativeY); float3 d = abs(dot(crossY, worldDirivativeX)); float3 inToNormal = ((((In + ddx(In)) - In) * crossY) + (((In + ddy(In)) - In) * crossX)) * sign(d); inToNormal.y *= -1.0; Out = normalize((d * TangentMatrix[2].xyz) - inToNormal); Out = TransformWorldToTangent(Out, TangentMatrix); } World void Unity_NormalFromHeight_World(float In, out float3 Out) { float3 worldDirivativeX = ddx(Position * 100); float3 worldDirivativeY = ddy(Position * 100); float3 crossX = cross(TangentMatrix[2].xyz, worldDirivativeX); float3 crossY = cross(TangentMatrix[2].xyz, worldDirivativeY); float3 d = abs(dot(crossY, worldDirivativeX)); float3 inToNormal = ((((In + ddx(In)) - In) * crossY) + (((In + ddy(In)) - In) * crossX)) * sign(d); inToNormal.y *= -1.0; Out = normalize((d * TangentMatrix[2].xyz) - inToNormal); }","title":"Generated Code Example"},{"location":"ShaderGraph/Normal-From-Texture-Node/","text":"Normal From Texture Node Description Converts a height map defined by input Texture into a normal map. UV values and sampler state can be defined by inputs UV and Sampler respectively. If nothing is connected to these ports they will use default values from the inputs. See Port Bindings for more information. The strength of the created normal map can be defined by inputs Offset and Strength , where Offset defines the maximum distance of a normal detail and Strength acts as a multiplier to the result. Ports Name Direction Type Binding Description Texture Input Texture None Height map UV Input Vector 2 UV Texture coordinates Sampler Input Sampler State None Sampler for Texture Offset Input Vector 1 None Amount to offset samples Strength Input Vector 1 None Strength multiplier Out Output Vector 3 None Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_NormalFromTexture_float(Texture texture, SamplerState Sampler, float2 UV, float Offset, float Strength, out float3 Out) { Offset = pow(Offset, 3) * 0.1; float2 offsetU = float2(UV.x + Offset, UV.y); float2 offsetV = float2(UV.x, UV.y + Offset); float normalSample = Texture.Sample(Sampler, UV); float uSample = Texture.Sample(Sampler, offsetU); float vSample = Texture.Sample(Sampler, offsetV); float3 va = float3(1, 0, (uSample - normalSample) * Strength); float3 vb = float3(0, 1, (vSample - normalSample) * Strength); Out = normalize(cross(va, vb)); }","title":"Normal From Texture Node"},{"location":"ShaderGraph/Normal-From-Texture-Node/#normal-from-texture-node","text":"","title":"Normal From Texture Node"},{"location":"ShaderGraph/Normal-From-Texture-Node/#description","text":"Converts a height map defined by input Texture into a normal map. UV values and sampler state can be defined by inputs UV and Sampler respectively. If nothing is connected to these ports they will use default values from the inputs. See Port Bindings for more information. The strength of the created normal map can be defined by inputs Offset and Strength , where Offset defines the maximum distance of a normal detail and Strength acts as a multiplier to the result.","title":"Description"},{"location":"ShaderGraph/Normal-From-Texture-Node/#ports","text":"Name Direction Type Binding Description Texture Input Texture None Height map UV Input Vector 2 UV Texture coordinates Sampler Input Sampler State None Sampler for Texture Offset Input Vector 1 None Amount to offset samples Strength Input Vector 1 None Strength multiplier Out Output Vector 3 None Output value","title":"Ports"},{"location":"ShaderGraph/Normal-From-Texture-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_NormalFromTexture_float(Texture texture, SamplerState Sampler, float2 UV, float Offset, float Strength, out float3 Out) { Offset = pow(Offset, 3) * 0.1; float2 offsetU = float2(UV.x + Offset, UV.y); float2 offsetV = float2(UV.x, UV.y + Offset); float normalSample = Texture.Sample(Sampler, UV); float uSample = Texture.Sample(Sampler, offsetU); float vSample = Texture.Sample(Sampler, offsetV); float3 va = float3(1, 0, (uSample - normalSample) * Strength); float3 vb = float3(0, 1, (vSample - normalSample) * Strength); Out = normalize(cross(va, vb)); }","title":"Generated Code Example"},{"location":"ShaderGraph/Normal-Reconstruct-Z-Node/","text":"Normal Reconstruct Z Node Description Derives the correct Z value for generated normal maps using a given X and Y value from input In . Ports Name Direction Type Description In Input Vector 2 Normal X and Y value Out Output Vector 3 Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_NormalReconstructZ_float(float2 In, out float3 Out) { float reconstructZ = sqrt(1 - ( In.x * In.x + In.y * In.y)); float3 normalVector = float3(In.x, In.y, reconstructZ); Out = normalize(normalVector); }","title":"Normal Reconstruct Z Node"},{"location":"ShaderGraph/Normal-Reconstruct-Z-Node/#normal-reconstruct-z-node","text":"","title":"Normal Reconstruct Z Node"},{"location":"ShaderGraph/Normal-Reconstruct-Z-Node/#description","text":"Derives the correct Z value for generated normal maps using a given X and Y value from input In .","title":"Description"},{"location":"ShaderGraph/Normal-Reconstruct-Z-Node/#ports","text":"Name Direction Type Description In Input Vector 2 Normal X and Y value Out Output Vector 3 Output value","title":"Ports"},{"location":"ShaderGraph/Normal-Reconstruct-Z-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_NormalReconstructZ_float(float2 In, out float3 Out) { float reconstructZ = sqrt(1 - ( In.x * In.x + In.y * In.y)); float3 normalVector = float3(In.x, In.y, reconstructZ); Out = normalize(normalVector); }","title":"Generated Code Example"},{"location":"ShaderGraph/Normal-Strength-Node/","text":"Normal Strength Node Description Adjusts the strength of the normal map defined by input In by the amount of input Strength . A Strength value of 1 will return the input unaltered. A Strength value of 0 will return a blank normal map. Ports Name Direction Type Binding Description In Input Vector 3 None Input value Strength Input Vector 1 None Strength value Out Output Vector 3 None Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_NormalStrength_float(float3 In, float Strength, out float3 Out) { Out = {precision}3(In.rg * Strength, lerp(1, In.b, saturate(Strength))); }","title":"Normal Strength Node"},{"location":"ShaderGraph/Normal-Strength-Node/#normal-strength-node","text":"","title":"Normal Strength Node"},{"location":"ShaderGraph/Normal-Strength-Node/#description","text":"Adjusts the strength of the normal map defined by input In by the amount of input Strength . A Strength value of 1 will return the input unaltered. A Strength value of 0 will return a blank normal map.","title":"Description"},{"location":"ShaderGraph/Normal-Strength-Node/#ports","text":"Name Direction Type Binding Description In Input Vector 3 None Input value Strength Input Vector 1 None Strength value Out Output Vector 3 None Output value","title":"Ports"},{"location":"ShaderGraph/Normal-Strength-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_NormalStrength_float(float3 In, float Strength, out float3 Out) { Out = {precision}3(In.rg * Strength, lerp(1, In.b, saturate(Strength))); }","title":"Generated Code Example"},{"location":"ShaderGraph/Normal-Unpack-Node/","text":"Normal Unpack Node Description Unpacks a normal map defined by input In . This node is used to unpack a texture that is defined as a Normal Map in its Texture Import Settings when it is sampled as if it were a default texture. Note that in most cases this node is unnecessary as the normal map should be sampled as such by setting its Type parameter to Normal when it is sampled using a Sample Texture 2D or Triplanar node. Ports Name Direction Type Binding Description In Input Vector 4 None Input value Out Output Vector 3 None Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_NormalUnpack_float(float4 In, out float3 Out) { Out = UnpackNormalmapRGorAG(In); }","title":"Normal Unpack Node"},{"location":"ShaderGraph/Normal-Unpack-Node/#normal-unpack-node","text":"","title":"Normal Unpack Node"},{"location":"ShaderGraph/Normal-Unpack-Node/#description","text":"Unpacks a normal map defined by input In . This node is used to unpack a texture that is defined as a Normal Map in its Texture Import Settings when it is sampled as if it were a default texture. Note that in most cases this node is unnecessary as the normal map should be sampled as such by setting its Type parameter to Normal when it is sampled using a Sample Texture 2D or Triplanar node.","title":"Description"},{"location":"ShaderGraph/Normal-Unpack-Node/#ports","text":"Name Direction Type Binding Description In Input Vector 4 None Input value Out Output Vector 3 None Output value","title":"Ports"},{"location":"ShaderGraph/Normal-Unpack-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_NormalUnpack_float(float4 In, out float3 Out) { Out = UnpackNormalmapRGorAG(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Normal-Vector-Node/","text":"Description Provides access to the mesh vertex or fragment's Normal Vector . The coordinate space of the output value can be selected with the Space dropdown parameter. Ports Name Direction Type Binding Description Out Output Vector 3 None Mesh's Normal Vector . Parameters Name Type Options Description Space Dropdown Object, View, World, Tangent Selects coordinate space of Normal Vector to output.","title":"Normal Vector Node"},{"location":"ShaderGraph/Normal-Vector-Node/#description","text":"Provides access to the mesh vertex or fragment's Normal Vector . The coordinate space of the output value can be selected with the Space dropdown parameter.","title":"Description"},{"location":"ShaderGraph/Normal-Vector-Node/#ports","text":"Name Direction Type Binding Description Out Output Vector 3 None Mesh's Normal Vector .","title":"Ports"},{"location":"ShaderGraph/Normal-Vector-Node/#parameters","text":"Name Type Options Description Space Dropdown Object, View, World, Tangent Selects coordinate space of Normal Vector to output.","title":"Parameters"},{"location":"ShaderGraph/Normalize-Node/","text":"Normalize Node Description Returns the normalized value of input In . The output vector will have the same direction as input In but a length of 1. Ports Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Normalize_float4(float4 In, out float4 Out) { Out = normalize(In); }","title":"Normalize Node"},{"location":"ShaderGraph/Normalize-Node/#normalize-node","text":"","title":"Normalize Node"},{"location":"ShaderGraph/Normalize-Node/#description","text":"Returns the normalized value of input In . The output vector will have the same direction as input In but a length of 1.","title":"Description"},{"location":"ShaderGraph/Normalize-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Normalize-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Normalize_float4(float4 In, out float4 Out) { Out = normalize(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Not-Node/","text":"Not Node Description Returns the opposite of input In . If In is true the output will be false, otherwise it will be true. This is useful for Branching . Ports Name Direction Type Binding Description In Input Boolean None Input value Out Output Boolean None Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_NormalUnpack_float(float In, out float Out) { Out = !In; }","title":"Not Node"},{"location":"ShaderGraph/Not-Node/#not-node","text":"","title":"Not Node"},{"location":"ShaderGraph/Not-Node/#description","text":"Returns the opposite of input In . If In is true the output will be false, otherwise it will be true. This is useful for Branching .","title":"Description"},{"location":"ShaderGraph/Not-Node/#ports","text":"Name Direction Type Binding Description In Input Boolean None Input value Out Output Boolean None Output value","title":"Ports"},{"location":"ShaderGraph/Not-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_NormalUnpack_float(float In, out float Out) { Out = !In; }","title":"Generated Code Example"},{"location":"ShaderGraph/Object-Node/","text":"Object Node Description Provides access to various parameters of the currently rendering Object . Note: The behaviour of the Position Port can be defined per Render Pipeline. Different Render Pipelines may produce different results. If you're building a shader in one Render Pipeline that you want to use in both, try checking it in both pipelines before production. Ports Name Direction Type Binding Description Position Output Vector 3 None Object position in world space Scale Output Vector 3 None Object scale in world space Generated Code Example The following example code represents one possible outcome of this node. float3 _Object_Position = SHADERGRAPH_OBJECT_POSITION; float3 _Object_Scale = float3(length(float3(UNITY_MATRIX_M[0].x, UNITY_MATRIX_M[1].x, UNITY_MATRIX_M[2].x)), length(float3(UNITY_MATRIX_M[0].y, UNITY_MATRIX_M[1].y, UNITY_MATRIX_M[2].y)), length(float3(UNITY_MATRIX_M[0].z, UNITY_MATRIX_M[1].z, UNITY_MATRIX_M[2].z)));","title":"Object Node"},{"location":"ShaderGraph/Object-Node/#object-node","text":"","title":"Object Node"},{"location":"ShaderGraph/Object-Node/#description","text":"Provides access to various parameters of the currently rendering Object . Note: The behaviour of the Position Port can be defined per Render Pipeline. Different Render Pipelines may produce different results. If you're building a shader in one Render Pipeline that you want to use in both, try checking it in both pipelines before production.","title":"Description"},{"location":"ShaderGraph/Object-Node/#ports","text":"Name Direction Type Binding Description Position Output Vector 3 None Object position in world space Scale Output Vector 3 None Object scale in world space","title":"Ports"},{"location":"ShaderGraph/Object-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. float3 _Object_Position = SHADERGRAPH_OBJECT_POSITION; float3 _Object_Scale = float3(length(float3(UNITY_MATRIX_M[0].x, UNITY_MATRIX_M[1].x, UNITY_MATRIX_M[2].x)), length(float3(UNITY_MATRIX_M[0].y, UNITY_MATRIX_M[1].y, UNITY_MATRIX_M[2].y)), length(float3(UNITY_MATRIX_M[0].z, UNITY_MATRIX_M[1].z, UNITY_MATRIX_M[2].z)));","title":"Generated Code Example"},{"location":"ShaderGraph/One-Minus-Node/","text":"One Minus Node Description Returns the result of input In subtracted from 1. Ports Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_OneMinus_float4(float4 In, out float4 Out) { Out = 1 - In; }","title":"One Minus Node"},{"location":"ShaderGraph/One-Minus-Node/#one-minus-node","text":"","title":"One Minus Node"},{"location":"ShaderGraph/One-Minus-Node/#description","text":"Returns the result of input In subtracted from 1.","title":"Description"},{"location":"ShaderGraph/One-Minus-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/One-Minus-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_OneMinus_float4(float4 In, out float4 Out) { Out = 1 - In; }","title":"Generated Code Example"},{"location":"ShaderGraph/Or-Node/","text":"Or Node Description Returns true if either of the inputs A and B are true. This is useful for Branching . Ports Name Direction Type Binding Description A Input Boolean None First input value B Input Boolean None Second input value Out Output Boolean None Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Or_float(float In, out float Out) { Out = A || B; }","title":"Or Node"},{"location":"ShaderGraph/Or-Node/#or-node","text":"","title":"Or Node"},{"location":"ShaderGraph/Or-Node/#description","text":"Returns true if either of the inputs A and B are true. This is useful for Branching .","title":"Description"},{"location":"ShaderGraph/Or-Node/#ports","text":"Name Direction Type Binding Description A Input Boolean None First input value B Input Boolean None Second input value Out Output Boolean None Output value","title":"Ports"},{"location":"ShaderGraph/Or-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Or_float(float In, out float Out) { Out = A || B; }","title":"Generated Code Example"},{"location":"ShaderGraph/PBR-Master-Node/","text":"PBR Master Node Description A Master Node for physically based rendering. Can be used in either Metallic or Specular workflow modes as defined by the Workflow dropdown parameter. Values supplied to the input Normal are expected to be in tangent space. Use the Transform Node to convert to tangent space. Ports Name Direction Type Stage Binding Description Position Input Vector 3 Vertex None Defines the absolute object space vertex position per vertex Albedo Input Vector 3 Fragment None Defines material's albedo value. Expected range 0 - 1. Normal Input Vector 3 Fragment Tangent Space Normal Defines material's normal value. Expects normals in tangent space. Emission Input Vector 3 Fragment None Defines material's emission color value. Expects positive values. Metallic Input Vector 1 Fragment None Defines material's metallic value where 0 is non-metallic and 1 is metallic. Only available in Metallic Workflow mode. Specular Input Vector 3 Fragment None Defines material's specular color value. Expected range 0 - 1. Only available in Specular Workflow mode. Smoothness Input Vector 1 Fragment None Defines material's smoothness value. Expected range 0 - 1. Occlusion Input Vector 1 Fragment None Defines material's ambient occlusion value. Expected range 0 - 1. Alpha Input Vector 1 Fragment None Defines material's alpha value. Used for transparency and/or alpha clip. Expected range 0 - 1. Alpha Clip Threshold Input Vector 1 Fragment None Fragments with an alpha below this value will be discarded. Requires a node connection. Expected range 0 - 1. Material Options PBR Master Node material options can be accessed by clicking the cog icon in the top right corner of the PBR Master Node . Name Type Options Description Workflow Dropdown Metallic, Specular Defines workflow mode for the material Surface Dropdown Opaque, Transparent Defines if the material is transparent Blend Dropdown Alpha, Premultiply, Additive, Multiply Defines blend mode of a transparent material Two Sided Toggle True, False If true both front and back faces of the mesh are rendered","title":"PBR Master Node"},{"location":"ShaderGraph/PBR-Master-Node/#pbr-master-node","text":"","title":"PBR Master Node"},{"location":"ShaderGraph/PBR-Master-Node/#description","text":"A Master Node for physically based rendering. Can be used in either Metallic or Specular workflow modes as defined by the Workflow dropdown parameter. Values supplied to the input Normal are expected to be in tangent space. Use the Transform Node to convert to tangent space.","title":"Description"},{"location":"ShaderGraph/PBR-Master-Node/#ports","text":"Name Direction Type Stage Binding Description Position Input Vector 3 Vertex None Defines the absolute object space vertex position per vertex Albedo Input Vector 3 Fragment None Defines material's albedo value. Expected range 0 - 1. Normal Input Vector 3 Fragment Tangent Space Normal Defines material's normal value. Expects normals in tangent space. Emission Input Vector 3 Fragment None Defines material's emission color value. Expects positive values. Metallic Input Vector 1 Fragment None Defines material's metallic value where 0 is non-metallic and 1 is metallic. Only available in Metallic Workflow mode. Specular Input Vector 3 Fragment None Defines material's specular color value. Expected range 0 - 1. Only available in Specular Workflow mode. Smoothness Input Vector 1 Fragment None Defines material's smoothness value. Expected range 0 - 1. Occlusion Input Vector 1 Fragment None Defines material's ambient occlusion value. Expected range 0 - 1. Alpha Input Vector 1 Fragment None Defines material's alpha value. Used for transparency and/or alpha clip. Expected range 0 - 1. Alpha Clip Threshold Input Vector 1 Fragment None Fragments with an alpha below this value will be discarded. Requires a node connection. Expected range 0 - 1.","title":"Ports"},{"location":"ShaderGraph/PBR-Master-Node/#material-options","text":"PBR Master Node material options can be accessed by clicking the cog icon in the top right corner of the PBR Master Node . Name Type Options Description Workflow Dropdown Metallic, Specular Defines workflow mode for the material Surface Dropdown Opaque, Transparent Defines if the material is transparent Blend Dropdown Alpha, Premultiply, Additive, Multiply Defines blend mode of a transparent material Two Sided Toggle True, False If true both front and back faces of the mesh are rendered","title":"Material Options"},{"location":"ShaderGraph/Polar-Coordinates-Node/","text":"Polar Coordinates Node Description Converts the value of input UV to polar coordinates. In mathematics, the polar coordinate system is a two-dimensional coordinate system in which each point on a plane is determined by a distance from a reference point and an angle from a reference direction. The resulting effect is that the x channel of the input to UV is converted to a distance value from the point specified by the value of input Center and the y channel of same input is converted to the value of an angle of rotation around that point. These values can be scaled by the values of inputs Radial Scale and Length Scale respectively. Ports Name Direction Type Binding Description UV Input Vector 2 UV Input UV value Center Input Vector 2 None Center reference point Radial Scale Input Vector 1 None Scale of distance value Length Scale Input Vector 1 None Scale of angle value Out Output Vector 2 None Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_PolarCoordinates_float(float2 UV, float2 Center, float RadialScale, float LengthScale, out float2 Out) { float2 delta = UV - Center; float radius = length(delta) * 2 * RadialScale; float angle = atan2(delta.x, delta.y) * 1.0/6.28 * LengthScale; Out = float2(radius, angle); }","title":"Polar Coordinates Node"},{"location":"ShaderGraph/Polar-Coordinates-Node/#polar-coordinates-node","text":"","title":"Polar Coordinates Node"},{"location":"ShaderGraph/Polar-Coordinates-Node/#description","text":"Converts the value of input UV to polar coordinates. In mathematics, the polar coordinate system is a two-dimensional coordinate system in which each point on a plane is determined by a distance from a reference point and an angle from a reference direction. The resulting effect is that the x channel of the input to UV is converted to a distance value from the point specified by the value of input Center and the y channel of same input is converted to the value of an angle of rotation around that point. These values can be scaled by the values of inputs Radial Scale and Length Scale respectively.","title":"Description"},{"location":"ShaderGraph/Polar-Coordinates-Node/#ports","text":"Name Direction Type Binding Description UV Input Vector 2 UV Input UV value Center Input Vector 2 None Center reference point Radial Scale Input Vector 1 None Scale of distance value Length Scale Input Vector 1 None Scale of angle value Out Output Vector 2 None Output value","title":"Ports"},{"location":"ShaderGraph/Polar-Coordinates-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_PolarCoordinates_float(float2 UV, float2 Center, float RadialScale, float LengthScale, out float2 Out) { float2 delta = UV - Center; float radius = length(delta) * 2 * RadialScale; float angle = atan2(delta.x, delta.y) * 1.0/6.28 * LengthScale; Out = float2(radius, angle); }","title":"Generated Code Example"},{"location":"ShaderGraph/Polygon-Node/","text":"Polygon Node Description Generates a regular polygon shape based on input UV at the size specified by inputs Width and Height . The polygon's amount of sides is determined by input Sides . The generated shape can be offset or tiled by connecting a Tiling And Offset Node . Note that in order to preserve the ability to offset the shape within the UV space the shape will not automatically repeat if tiled. To achieve a repeating polygon effect first connect your input through a Fraction Node . NOTE: This Node can only be used in the Fragment shader stage. Ports Name Direction Type Binding Description UV Input Vector 2 UV Input UV value Sides Input Vector 1 None Amount of sides Width Input Vector 1 None Polygon width Height Input Vector 1 None Polygon height Out Output Vector 1 None Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Polygon_float(float2 UV, float Sides, float Width, float Height, out float Out) { float pi = 3.14159265359; float aWidth = Width * cos(pi / Sides); float aHeight = Height * cos(pi / Sides); float2 uv = (UV * 2 - 1) / float2(aWidth, aHeight); uv.y *= -1; float pCoord = atan2(uv.x, uv.y); float r = 2 * pi / Sides; float distance = cos(floor(0.5 + pCoord / r) * r - pCoord) * length(uv); Out = saturate((1 - distance) / fwidth(distance)); }","title":"Polygon Node"},{"location":"ShaderGraph/Polygon-Node/#polygon-node","text":"","title":"Polygon Node"},{"location":"ShaderGraph/Polygon-Node/#description","text":"Generates a regular polygon shape based on input UV at the size specified by inputs Width and Height . The polygon's amount of sides is determined by input Sides . The generated shape can be offset or tiled by connecting a Tiling And Offset Node . Note that in order to preserve the ability to offset the shape within the UV space the shape will not automatically repeat if tiled. To achieve a repeating polygon effect first connect your input through a Fraction Node . NOTE: This Node can only be used in the Fragment shader stage.","title":"Description"},{"location":"ShaderGraph/Polygon-Node/#ports","text":"Name Direction Type Binding Description UV Input Vector 2 UV Input UV value Sides Input Vector 1 None Amount of sides Width Input Vector 1 None Polygon width Height Input Vector 1 None Polygon height Out Output Vector 1 None Output value","title":"Ports"},{"location":"ShaderGraph/Polygon-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Polygon_float(float2 UV, float Sides, float Width, float Height, out float Out) { float pi = 3.14159265359; float aWidth = Width * cos(pi / Sides); float aHeight = Height * cos(pi / Sides); float2 uv = (UV * 2 - 1) / float2(aWidth, aHeight); uv.y *= -1; float pCoord = atan2(uv.x, uv.y); float r = 2 * pi / Sides; float distance = cos(floor(0.5 + pCoord / r) * r - pCoord) * length(uv); Out = saturate((1 - distance) / fwidth(distance)); }","title":"Generated Code Example"},{"location":"ShaderGraph/Port-Bindings/","text":"Port Bindings Description Some input Ports might have Port Bindings . This means there is an expectation of the data that should be supplied to the Port , such as a Normal Vector or UV . However, a Port Binding only affects a Port that does not have a connected Edge . These Ports still have a regular Data Type that define what Edges can be connected to them. In practice this means that if no Edge is connected to the Port the default data used in that port will be taken from its Port Binding . A full list of Port Bindings and their associated default options is found below. Port Bindings List Name Data Type Options Description Bitangent Vector 3 Vertex or fragment bitangent, label describes expected transform space Color Vector 4 RGBA Color picker ColorRGB Vector 3 RGB Color picker Normal Vector 3 Vertex or fragment normal vector, label describes expected transform space Position Vector 3 Vertex or fragment position, label describes expected transform space Screen Position Vector 4 Default, Raw, Center, Tiled Tangent Vector 3 Vertex or fragment tangent vector, label describes expected transform space UV Vector 2 UV0, UV1, UV2, UV3 Vertex Color Vector 4 RGBA vertex color value. View Direction Vector 3 Vertex or fragment view direction vector, label describes expected transform space","title":"Port Bindings"},{"location":"ShaderGraph/Port-Bindings/#port-bindings","text":"","title":"Port Bindings"},{"location":"ShaderGraph/Port-Bindings/#description","text":"Some input Ports might have Port Bindings . This means there is an expectation of the data that should be supplied to the Port , such as a Normal Vector or UV . However, a Port Binding only affects a Port that does not have a connected Edge . These Ports still have a regular Data Type that define what Edges can be connected to them. In practice this means that if no Edge is connected to the Port the default data used in that port will be taken from its Port Binding . A full list of Port Bindings and their associated default options is found below.","title":"Description"},{"location":"ShaderGraph/Port-Bindings/#port-bindings-list","text":"Name Data Type Options Description Bitangent Vector 3 Vertex or fragment bitangent, label describes expected transform space Color Vector 4 RGBA Color picker ColorRGB Vector 3 RGB Color picker Normal Vector 3 Vertex or fragment normal vector, label describes expected transform space Position Vector 3 Vertex or fragment position, label describes expected transform space Screen Position Vector 4 Default, Raw, Center, Tiled Tangent Vector 3 Vertex or fragment tangent vector, label describes expected transform space UV Vector 2 UV0, UV1, UV2, UV3 Vertex Color Vector 4 RGBA vertex color value. View Direction Vector 3 Vertex or fragment view direction vector, label describes expected transform space","title":"Port Bindings List"},{"location":"ShaderGraph/Port/","text":"Port Description A Port defines an input or output on a Node . Connecting Edges to a Port allows data to flow through the Shader Graph node network. Each Port has a Data Type which defines what Edges can be connected to it. Each Data Type has an associated color for identifying its type. Only one Edge can be connected to any input Port but multiple Edges can be connected to an output Port . You can open a contextual Create Node Menu by dragging an Edge from a Port with left mouse button and releasing it in an empty area of the workspace. Default Inputs Each Input Port , a Port on the left side of a Node implying that it is for inputting data into the Node , has a Default Input . This appears as a small field connected to the Port when there is no Edge connected. This field will display an input for the ports Data Type unless the Port has a Port Binding . If a Port does have a Port Binding the default input field may display a special field, such as a dropdown for selecting UV channels, or just a label to help you undestand the intended input, such as coordindate space labels for geometry data.","title":"Port"},{"location":"ShaderGraph/Port/#port","text":"","title":"Port"},{"location":"ShaderGraph/Port/#description","text":"A Port defines an input or output on a Node . Connecting Edges to a Port allows data to flow through the Shader Graph node network. Each Port has a Data Type which defines what Edges can be connected to it. Each Data Type has an associated color for identifying its type. Only one Edge can be connected to any input Port but multiple Edges can be connected to an output Port . You can open a contextual Create Node Menu by dragging an Edge from a Port with left mouse button and releasing it in an empty area of the workspace.","title":"Description"},{"location":"ShaderGraph/Port/#default-inputs","text":"Each Input Port , a Port on the left side of a Node implying that it is for inputting data into the Node , has a Default Input . This appears as a small field connected to the Port when there is no Edge connected. This field will display an input for the ports Data Type unless the Port has a Port Binding . If a Port does have a Port Binding the default input field may display a special field, such as a dropdown for selecting UV channels, or just a label to help you undestand the intended input, such as coordindate space labels for geometry data.","title":"Default Inputs"},{"location":"ShaderGraph/Position-Node/","text":"Position Node Description Provides access to the mesh vertex or fragment's Position , depending on the effective Shader Stage of the graph section the Node is part of. The coordinate space of the output value can be selected with the Space dropdown parameter. Ports Name Direction Type Binding Description Out Output Vector 3 None Position for the Mesh Vertex/Fragment. Controls Name Type Options Description Space Dropdown Object, View, World, Tangent Selects coordinate space of Position to output.","title":"Position Node"},{"location":"ShaderGraph/Position-Node/#position-node","text":"","title":"Position Node"},{"location":"ShaderGraph/Position-Node/#description","text":"Provides access to the mesh vertex or fragment's Position , depending on the effective Shader Stage of the graph section the Node is part of. The coordinate space of the output value can be selected with the Space dropdown parameter.","title":"Description"},{"location":"ShaderGraph/Position-Node/#ports","text":"Name Direction Type Binding Description Out Output Vector 3 None Position for the Mesh Vertex/Fragment.","title":"Ports"},{"location":"ShaderGraph/Position-Node/#controls","text":"Name Type Options Description Space Dropdown Object, View, World, Tangent Selects coordinate space of Position to output.","title":"Controls"},{"location":"ShaderGraph/Posterize-Node/","text":"Posterize Node Description Posterization or posterisation of an image entails conversion of a continuous gradation of tone to several regions of fewer tones, with abrupt changes from one tone to another. https://en.wikipedia.org/wiki/Posterization This node returns the posterized (also known as quantized) value of the input In into an amount of values specified by input Steps . Ports Name Direction Type Description In Input Dynamic Vector Input value Steps Input Dynamic Vector Input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Posterize_float4(float4 In, float4 Steps, out float4 Out) { Out = floor(In / (1 / Steps)) * (1 / Steps); }","title":"Posterize Node"},{"location":"ShaderGraph/Posterize-Node/#posterize-node","text":"","title":"Posterize Node"},{"location":"ShaderGraph/Posterize-Node/#description","text":"Posterization or posterisation of an image entails conversion of a continuous gradation of tone to several regions of fewer tones, with abrupt changes from one tone to another. https://en.wikipedia.org/wiki/Posterization This node returns the posterized (also known as quantized) value of the input In into an amount of values specified by input Steps .","title":"Description"},{"location":"ShaderGraph/Posterize-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Steps Input Dynamic Vector Input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Posterize-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Posterize_float4(float4 In, float4 Steps, out float4 Out) { Out = floor(In / (1 / Steps)) * (1 / Steps); }","title":"Generated Code Example"},{"location":"ShaderGraph/Power-Node/","text":"Power Node Description Returns the result of input A to the power of input B . Ports Name Direction Type Description A Input Dynamic Vector First input value B Input Dynamic Vector Second input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Power_float4(float4 A, float4 B, out float4 Out) { Out = pow(A, B); }","title":"Power Node"},{"location":"ShaderGraph/Power-Node/#power-node","text":"","title":"Power Node"},{"location":"ShaderGraph/Power-Node/#description","text":"Returns the result of input A to the power of input B .","title":"Description"},{"location":"ShaderGraph/Power-Node/#ports","text":"Name Direction Type Description A Input Dynamic Vector First input value B Input Dynamic Vector Second input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Power-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Power_float4(float4 A, float4 B, out float4 Out) { Out = pow(A, B); }","title":"Generated Code Example"},{"location":"ShaderGraph/Preview-Node/","text":"Preview Node Description Provides a preview window and passes the input value through without modification. This Node is useful for providing a preview at a specific point in a Shader Graph if the user prefers to generally collapse Node previews. Ports Name Direction Type Binding Description In Input Dynamic Vector None Input value Out Output Dynamic Vector None Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Preview_float4(float4 In, out float4 Out) { Out = In; }","title":"Preview Node"},{"location":"ShaderGraph/Preview-Node/#preview-node","text":"","title":"Preview Node"},{"location":"ShaderGraph/Preview-Node/#description","text":"Provides a preview window and passes the input value through without modification. This Node is useful for providing a preview at a specific point in a Shader Graph if the user prefers to generally collapse Node previews.","title":"Description"},{"location":"ShaderGraph/Preview-Node/#ports","text":"Name Direction Type Binding Description In Input Dynamic Vector None Input value Out Output Dynamic Vector None Output value","title":"Ports"},{"location":"ShaderGraph/Preview-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Preview_float4(float4 In, out float4 Out) { Out = In; }","title":"Generated Code Example"},{"location":"ShaderGraph/Procedural-Nodes/","text":"Procedural Nodes Checkerboard Generates a checkerboard of alternating colors between inputs Color A and Color B based on input UV. Noise Gradient Noise Simple Noise Generates a gradient, or Perlin, noise based on input UV. Generates a simple, or Value, noise based on input UV. Voronoi Generates a Voronoi, or Worley, noise based on input UV. Shape Ellipse Polygon Generates an ellipse shape based on input UV at the size specified by inputs Width and Height. Generates a regular polygon shape based on input UV at the size specified by inputs Width and Height. The polygon's amount of sides is determined by input Sides. Rectangle Rounded Rectangle Generates a rectangle shape based on input UV at the size specified by inputs Width and Height. Generates a rounded rectangle shape based on input UV at the size specified by inputs Width and Height. The radius of each corner is defined by input Radius.","title":"Procedural Nodes"},{"location":"ShaderGraph/Procedural-Nodes/#procedural-nodes","text":"Checkerboard Generates a checkerboard of alternating colors between inputs Color A and Color B based on input UV.","title":"Procedural Nodes"},{"location":"ShaderGraph/Procedural-Nodes/#noise","text":"Gradient Noise Simple Noise Generates a gradient, or Perlin, noise based on input UV. Generates a simple, or Value, noise based on input UV. Voronoi Generates a Voronoi, or Worley, noise based on input UV.","title":"Noise"},{"location":"ShaderGraph/Procedural-Nodes/#shape","text":"Ellipse Polygon Generates an ellipse shape based on input UV at the size specified by inputs Width and Height. Generates a regular polygon shape based on input UV at the size specified by inputs Width and Height. The polygon's amount of sides is determined by input Sides. Rectangle Rounded Rectangle Generates a rectangle shape based on input UV at the size specified by inputs Width and Height. Generates a rounded rectangle shape based on input UV at the size specified by inputs Width and Height. The radius of each corner is defined by input Radius.","title":"Shape"},{"location":"ShaderGraph/Projection-Node/","text":"Projection Node Description Returns the result of projecting the value of input A onto a straight line parallel to the value of input B . Ports Name Direction Type Description A Input Dynamic Vector First input value B Input Dynamic Vector Second input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Projection_float4(float4 A, float4 B, out float4 Out) { Out = B * dot(A, B) / dot(B, B); }","title":"Projection Node"},{"location":"ShaderGraph/Projection-Node/#projection-node","text":"","title":"Projection Node"},{"location":"ShaderGraph/Projection-Node/#description","text":"Returns the result of projecting the value of input A onto a straight line parallel to the value of input B .","title":"Description"},{"location":"ShaderGraph/Projection-Node/#ports","text":"Name Direction Type Description A Input Dynamic Vector First input value B Input Dynamic Vector Second input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Projection-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Projection_float4(float4 A, float4 B, out float4 Out) { Out = B * dot(A, B) / dot(B, B); }","title":"Generated Code Example"},{"location":"ShaderGraph/Property-Types/","text":"Property Types Description Property Types are the types of Property than can be defined on the Blackboard for use in the Graph . These Properties will be exposed to the Inspector for Materials that use the shader. Each property has an associated Data Type . See Data Types for more information. Common Parameters In addition to values specific to their Data Types , all properties have the following parameters. Name Type Description Display Name String The display name of the property Exposed Boolean If true this property will be exposed on the material inspector Reference Name String The internal name used for the property inside the shader NOTE: If you overwrite the Reference Name parameter be aware of the following conditions: - If your Reference Name does not begin with an underscore, one will be automatically appended. - If your Reference Name contains any characters which are unsupported in HLSL they will be removed. - You can revert to the default Reference Name by right clicking on it and selecting Reset Reference . Vector 1 Defines a Vector 1 value. Data Type Modes Vector 1 Default, Slider, Integer Default Displays a scalar input field in the material inspector. Field Type Description Default Vector 1 The default value of the Property . Slider Displays a slider field in the material inspector. Field Type Description Default Vector 1 The default value of the Property . Min Vector 1 The minimum value of the slider. Max Vector 1 The maximum value of the slider. Integer Displays an integer input field in the material inspector. Field Type Description Default Integer The default value of the Property . Vector 2 Defines a Vector 2 value. Displays a Vector 4 input field in the material inspector, where the z and w components are not used. Data Type Modes Vector 2 Field Type Description Default Vector 2 The default value of the Property . Vector 3 Defines a Vector 3 value. Displays a Vector 4 input field in the material inspector, where the w component is not used. Data Type Modes Vector 3 Field Type Description Default Vector 3 The default value of the Property . Vector 4 Defines a Vector 4 value. Displays a Vector 4 input field in the material inspector. Data Type Modes Vector 4 Field Type Description Default Vector 4 The default value of the Property . Color Defines a Color value. Data Type Modes Color Default, HDR Default Displays an sRGB color field in the material inspector. Field Type Description Default Vector 4 The default value of the Property . HDR Displays an HDR color field in the material inspector. Field Type Description Default Vector 4 The default value of the Property . Texture 2D Defines a Texture 2D value. Displays an object field of type Texture in the material inspector. Data Type Modes Texture White, Black, Grey, Bump Field Type Description Default Texture The default value of the Property . Texture 3D Defines a Texture 3D value. Displays an object field of type Texture 3D in the material inspector. Data Type Modes Texture Field Type Description Default Texture The default value of the Property . Texture 2D Array Defines a Texture 2D Array value. Displays an object field of type Texture 2D Array in the material inspector. Data Type Modes Texture Field Type Description Default Texture The default value of the Property . Cubemap Defines a Cubemap value. Displays an object field of type Texture in the material inspector. Data Type Modes Cubemap Field Type Description Default Cubemap The default value of the Property . Boolean Defines a Boolean value. Displays a Toggle field in the material inspector. Note that internally to the shader this value is a Vector 1 . The Boolean type in Shader Graph is merely for usability. Data Type Modes Boolean Field Type Description Default Boolean The default value of the Property .","title":"Property Types"},{"location":"ShaderGraph/Property-Types/#property-types","text":"","title":"Property Types"},{"location":"ShaderGraph/Property-Types/#description","text":"Property Types are the types of Property than can be defined on the Blackboard for use in the Graph . These Properties will be exposed to the Inspector for Materials that use the shader. Each property has an associated Data Type . See Data Types for more information.","title":"Description"},{"location":"ShaderGraph/Property-Types/#common-parameters","text":"In addition to values specific to their Data Types , all properties have the following parameters. Name Type Description Display Name String The display name of the property Exposed Boolean If true this property will be exposed on the material inspector Reference Name String The internal name used for the property inside the shader NOTE: If you overwrite the Reference Name parameter be aware of the following conditions: - If your Reference Name does not begin with an underscore, one will be automatically appended. - If your Reference Name contains any characters which are unsupported in HLSL they will be removed. - You can revert to the default Reference Name by right clicking on it and selecting Reset Reference .","title":"Common Parameters"},{"location":"ShaderGraph/Property-Types/#vector-1","text":"Defines a Vector 1 value. Data Type Modes Vector 1 Default, Slider, Integer","title":"Vector 1"},{"location":"ShaderGraph/Property-Types/#default","text":"Displays a scalar input field in the material inspector. Field Type Description Default Vector 1 The default value of the Property .","title":"Default"},{"location":"ShaderGraph/Property-Types/#slider","text":"Displays a slider field in the material inspector. Field Type Description Default Vector 1 The default value of the Property . Min Vector 1 The minimum value of the slider. Max Vector 1 The maximum value of the slider.","title":"Slider"},{"location":"ShaderGraph/Property-Types/#integer","text":"Displays an integer input field in the material inspector. Field Type Description Default Integer The default value of the Property .","title":"Integer"},{"location":"ShaderGraph/Property-Types/#vector-2","text":"Defines a Vector 2 value. Displays a Vector 4 input field in the material inspector, where the z and w components are not used. Data Type Modes Vector 2 Field Type Description Default Vector 2 The default value of the Property .","title":"Vector 2"},{"location":"ShaderGraph/Property-Types/#vector-3","text":"Defines a Vector 3 value. Displays a Vector 4 input field in the material inspector, where the w component is not used. Data Type Modes Vector 3 Field Type Description Default Vector 3 The default value of the Property .","title":"Vector 3"},{"location":"ShaderGraph/Property-Types/#vector-4","text":"Defines a Vector 4 value. Displays a Vector 4 input field in the material inspector. Data Type Modes Vector 4 Field Type Description Default Vector 4 The default value of the Property .","title":"Vector 4"},{"location":"ShaderGraph/Property-Types/#color","text":"Defines a Color value. Data Type Modes Color Default, HDR","title":"Color"},{"location":"ShaderGraph/Property-Types/#default_1","text":"Displays an sRGB color field in the material inspector. Field Type Description Default Vector 4 The default value of the Property .","title":"Default"},{"location":"ShaderGraph/Property-Types/#hdr","text":"Displays an HDR color field in the material inspector. Field Type Description Default Vector 4 The default value of the Property .","title":"HDR"},{"location":"ShaderGraph/Property-Types/#texture-2d","text":"Defines a Texture 2D value. Displays an object field of type Texture in the material inspector. Data Type Modes Texture White, Black, Grey, Bump Field Type Description Default Texture The default value of the Property .","title":"Texture 2D"},{"location":"ShaderGraph/Property-Types/#texture-3d","text":"Defines a Texture 3D value. Displays an object field of type Texture 3D in the material inspector. Data Type Modes Texture Field Type Description Default Texture The default value of the Property .","title":"Texture 3D"},{"location":"ShaderGraph/Property-Types/#texture-2d-array","text":"Defines a Texture 2D Array value. Displays an object field of type Texture 2D Array in the material inspector. Data Type Modes Texture Field Type Description Default Texture The default value of the Property .","title":"Texture 2D Array"},{"location":"ShaderGraph/Property-Types/#cubemap","text":"Defines a Cubemap value. Displays an object field of type Texture in the material inspector. Data Type Modes Cubemap Field Type Description Default Cubemap The default value of the Property .","title":"Cubemap"},{"location":"ShaderGraph/Property-Types/#boolean","text":"Defines a Boolean value. Displays a Toggle field in the material inspector. Note that internally to the shader this value is a Vector 1 . The Boolean type in Shader Graph is merely for usability. Data Type Modes Boolean Field Type Description Default Boolean The default value of the Property .","title":"Boolean"},{"location":"ShaderGraph/Radial-Shear-Node/","text":"Radial Shear Node Description Applies a radial shear warping effect similar to a wave to the value of input UV . The center reference point of the warping effect is defined by input Center and the overall strength of the effect is defined by the value of input Strength . Input Offset can be used to offset the individual channels of the result. Ports Name Direction Type Binding Description UV Input Vector 2 UV Input UV value Center Input Vector 2 None Center reference point Strength Input Vector 1 None Strength of the effect Offset Input Vector 2 None Individual channel offsets Out Output Vector 2 None Output UV value Generated Code Example The following example code represents one possible outcome of this node. void Unity_RadialShear_float(float2 UV, float2 Center, float Strength, float2 Offset, out float2 Out) { float2 delta = UV - Center; float delta2 = dot(delta.xy, delta.xy); float2 delta_offset = delta2 * Strength; Out = UV + float2(delta.y, -delta.x) * delta_offset + Offset; }","title":"Radial Shear Node"},{"location":"ShaderGraph/Radial-Shear-Node/#radial-shear-node","text":"","title":"Radial Shear Node"},{"location":"ShaderGraph/Radial-Shear-Node/#description","text":"Applies a radial shear warping effect similar to a wave to the value of input UV . The center reference point of the warping effect is defined by input Center and the overall strength of the effect is defined by the value of input Strength . Input Offset can be used to offset the individual channels of the result.","title":"Description"},{"location":"ShaderGraph/Radial-Shear-Node/#ports","text":"Name Direction Type Binding Description UV Input Vector 2 UV Input UV value Center Input Vector 2 None Center reference point Strength Input Vector 1 None Strength of the effect Offset Input Vector 2 None Individual channel offsets Out Output Vector 2 None Output UV value","title":"Ports"},{"location":"ShaderGraph/Radial-Shear-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_RadialShear_float(float2 UV, float2 Center, float Strength, float2 Offset, out float2 Out) { float2 delta = UV - Center; float delta2 = dot(delta.xy, delta.xy); float2 delta_offset = delta2 * Strength; Out = UV + float2(delta.y, -delta.x) * delta_offset + Offset; }","title":"Generated Code Example"},{"location":"ShaderGraph/Radians-To-Degrees-Node/","text":"Radians To Degrees Node Description Returns the value of input In converted from radians to degrees. One radian is equivalent to approximately 57.2958 degrees and a full rotation of 2 Pi radians is equal to 360 degrees. Ports Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_RadiansToDegrees_float4(float4 In, out float4 Out) { Out = degrees(In); }","title":"Radians To Degrees Node"},{"location":"ShaderGraph/Radians-To-Degrees-Node/#radians-to-degrees-node","text":"","title":"Radians To Degrees Node"},{"location":"ShaderGraph/Radians-To-Degrees-Node/#description","text":"Returns the value of input In converted from radians to degrees. One radian is equivalent to approximately 57.2958 degrees and a full rotation of 2 Pi radians is equal to 360 degrees.","title":"Description"},{"location":"ShaderGraph/Radians-To-Degrees-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Radians-To-Degrees-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_RadiansToDegrees_float4(float4 In, out float4 Out) { Out = degrees(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Random-Range-Node/","text":"Random Range Node Description Returns a pseudo-random number value based on input Seed that is between the minimum and maximum values defined by inputs Min and Max respectively. Whilst the same value in input Seed will always result in the same output value, the output value itself will appear random. Input Seed is a Vector 2 value for the convenience of generating a random number based on a UV input, however for most cases a Vector 1 input will suffice. Ports Name Direction Type Description Seed Input Vector 2 Seed value used for generation Min Input Vector 1 Minimum value Max Input Vector 1 Maximum value Out Output Vector 1 Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_RandomRange_float(float2 Seed, float Min, float Max, out float Out) { float randomno = frac(sin(dot(Seed, float2(12.9898, 78.233)))*43758.5453); Out = lerp(Min, Max, randomno); }","title":"Random Range Node"},{"location":"ShaderGraph/Random-Range-Node/#random-range-node","text":"","title":"Random Range Node"},{"location":"ShaderGraph/Random-Range-Node/#description","text":"Returns a pseudo-random number value based on input Seed that is between the minimum and maximum values defined by inputs Min and Max respectively. Whilst the same value in input Seed will always result in the same output value, the output value itself will appear random. Input Seed is a Vector 2 value for the convenience of generating a random number based on a UV input, however for most cases a Vector 1 input will suffice.","title":"Description"},{"location":"ShaderGraph/Random-Range-Node/#ports","text":"Name Direction Type Description Seed Input Vector 2 Seed value used for generation Min Input Vector 1 Minimum value Max Input Vector 1 Maximum value Out Output Vector 1 Output value","title":"Ports"},{"location":"ShaderGraph/Random-Range-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_RandomRange_float(float2 Seed, float Min, float Max, out float Out) { float randomno = frac(sin(dot(Seed, float2(12.9898, 78.233)))*43758.5453); Out = lerp(Min, Max, randomno); }","title":"Generated Code Example"},{"location":"ShaderGraph/Reciprocal-Node/","text":"Reciprocal Node Description Returns the result of dividing 1 by the input In . This can be calculated by a fast approximation on Shader Model 5 by setting Method to Fast . Ports Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value Controls Name Type Options Description Method Dropdown Default, Fast Selects the method used Generated Code Example The following example code represents one possible outcome of this node per Method mode. Default void Unity_Reciprocal_float4(float4 In, out float4 Out) { Out = 1.0/In; } Fast (Requires Shader Model 5) void Unity_Reciprocal_Fast_float4(float4 In, out float4 Out) { Out = rcp(In); }","title":"Reciprocal Node"},{"location":"ShaderGraph/Reciprocal-Node/#reciprocal-node","text":"","title":"Reciprocal Node"},{"location":"ShaderGraph/Reciprocal-Node/#description","text":"Returns the result of dividing 1 by the input In . This can be calculated by a fast approximation on Shader Model 5 by setting Method to Fast .","title":"Description"},{"location":"ShaderGraph/Reciprocal-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Reciprocal-Node/#controls","text":"Name Type Options Description Method Dropdown Default, Fast Selects the method used","title":"Controls"},{"location":"ShaderGraph/Reciprocal-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node per Method mode. Default void Unity_Reciprocal_float4(float4 In, out float4 Out) { Out = 1.0/In; } Fast (Requires Shader Model 5) void Unity_Reciprocal_Fast_float4(float4 In, out float4 Out) { Out = rcp(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Reciprocal-Square-Root-Node/","text":"Reciprocal Square Root Node Description Returns the result of 1 divided by the square root of the input In . Ports Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_ReciprocalSquareRoot_float4(float4 In, out float4 Out) { Out = rsqrt(In); }","title":"Reciprocal Square Root Node"},{"location":"ShaderGraph/Reciprocal-Square-Root-Node/#reciprocal-square-root-node","text":"","title":"Reciprocal Square Root Node"},{"location":"ShaderGraph/Reciprocal-Square-Root-Node/#description","text":"Returns the result of 1 divided by the square root of the input In .","title":"Description"},{"location":"ShaderGraph/Reciprocal-Square-Root-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Reciprocal-Square-Root-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_ReciprocalSquareRoot_float4(float4 In, out float4 Out) { Out = rsqrt(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Rectangle-Node/","text":"Rectangle Node Description Generates a rectangle shape based on input UV at the size specified by inputs Width and Height . The generated shape can be offset or tiled by connecting a Tiling And Offset Node . Note that in order to preserve the ability to offset the shape within the UV space the shape will not automatically repeat if tiled. To achieve a repeating rectangle effect first connect your input through a Fraction Node . NOTE: This Node can only be used in the Fragment Shader Stage . Ports Name Direction Type Binding Description UV Input Vector 2 UV Input UV value Width Input Vector 1 None Rectangle width Height Input Vector 1 None Rectangle height Out Output Vector 1 None Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Rectangle_float(float2 UV, float Width, float Height, out float Out) { float2 d = abs(UV * 2 - 1) - float2(Width, Height); d = 1 - d / fwidth(d); Out = saturate(min(d.x, d.y)); }","title":"Rectangle Node"},{"location":"ShaderGraph/Rectangle-Node/#rectangle-node","text":"","title":"Rectangle Node"},{"location":"ShaderGraph/Rectangle-Node/#description","text":"Generates a rectangle shape based on input UV at the size specified by inputs Width and Height . The generated shape can be offset or tiled by connecting a Tiling And Offset Node . Note that in order to preserve the ability to offset the shape within the UV space the shape will not automatically repeat if tiled. To achieve a repeating rectangle effect first connect your input through a Fraction Node . NOTE: This Node can only be used in the Fragment Shader Stage .","title":"Description"},{"location":"ShaderGraph/Rectangle-Node/#ports","text":"Name Direction Type Binding Description UV Input Vector 2 UV Input UV value Width Input Vector 1 None Rectangle width Height Input Vector 1 None Rectangle height Out Output Vector 1 None Output value","title":"Ports"},{"location":"ShaderGraph/Rectangle-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Rectangle_float(float2 UV, float Width, float Height, out float Out) { float2 d = abs(UV * 2 - 1) - float2(Width, Height); d = 1 - d / fwidth(d); Out = saturate(min(d.x, d.y)); }","title":"Generated Code Example"},{"location":"ShaderGraph/Reflection-Node/","text":"Reflection Node Description Returns a reflection vector using input In and a surface normal Normal . Ports Name Direction Type Description In Input Dynamic Vector Incident vector value Normal Input Dynamic Vector Normal vector value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Reflection_float4(float4 In, float4 Normal, out float4 Out) { Out = reflect(In, Normal); }","title":"Reflection Node"},{"location":"ShaderGraph/Reflection-Node/#reflection-node","text":"","title":"Reflection Node"},{"location":"ShaderGraph/Reflection-Node/#description","text":"Returns a reflection vector using input In and a surface normal Normal .","title":"Description"},{"location":"ShaderGraph/Reflection-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Incident vector value Normal Input Dynamic Vector Normal vector value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Reflection-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Reflection_float4(float4 In, float4 Normal, out float4 Out) { Out = reflect(In, Normal); }","title":"Generated Code Example"},{"location":"ShaderGraph/Reflection-Probe-Node/","text":"Reflection Probe Node Description Provides access to the nearest Reflection Probe to the object. Requires Normal and View Direction to sample the probe. You can achieve a blurring effect by sampling at a different Level of Detail using the LOD input. Note: The behavior of this Node is undefined globally. Shader Graph does not define the function of the node. Instead, each Render Pipeline defines what HLSL code to execute for this Node . Different Render Pipelines may produce different results. If you're building a shader in one Render Pipeline that you want to use in both, try checking it in both pipelines before production. A Node might be defined in one Render Pipeline and undefined in the other. If this Node is undefined, it returns 0 (black). Unity Pipelines Supported Lightweight Render Pipeline Ports Name Direction Type Binding Description View Dir Input Vector 3 View Direction (object space) Mesh's view direction Normal Input Vector 3 Normal (object space) Mesh's normal vector LOD Input Vector 1 None Level of detail for sampling Out Output Vector 3 None Output color value Generated Code Example The following example code represents one possible outcome of this node. void Unity_ReflectionProbe_float(float3 ViewDir, float3 Normal, float LOD, out float3 Out) { Out = SHADERGRAPH_REFLECTION_PROBE(ViewDir, Normal, LOD); }","title":"Reflection Probe Node"},{"location":"ShaderGraph/Reflection-Probe-Node/#reflection-probe-node","text":"","title":"Reflection Probe Node"},{"location":"ShaderGraph/Reflection-Probe-Node/#description","text":"Provides access to the nearest Reflection Probe to the object. Requires Normal and View Direction to sample the probe. You can achieve a blurring effect by sampling at a different Level of Detail using the LOD input. Note: The behavior of this Node is undefined globally. Shader Graph does not define the function of the node. Instead, each Render Pipeline defines what HLSL code to execute for this Node . Different Render Pipelines may produce different results. If you're building a shader in one Render Pipeline that you want to use in both, try checking it in both pipelines before production. A Node might be defined in one Render Pipeline and undefined in the other. If this Node is undefined, it returns 0 (black).","title":"Description"},{"location":"ShaderGraph/Reflection-Probe-Node/#unity-pipelines-supported","text":"Lightweight Render Pipeline","title":"Unity Pipelines Supported"},{"location":"ShaderGraph/Reflection-Probe-Node/#ports","text":"Name Direction Type Binding Description View Dir Input Vector 3 View Direction (object space) Mesh's view direction Normal Input Vector 3 Normal (object space) Mesh's normal vector LOD Input Vector 1 None Level of detail for sampling Out Output Vector 3 None Output color value","title":"Ports"},{"location":"ShaderGraph/Reflection-Probe-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_ReflectionProbe_float(float3 ViewDir, float3 Normal, float LOD, out float3 Out) { Out = SHADERGRAPH_REFLECTION_PROBE(ViewDir, Normal, LOD); }","title":"Generated Code Example"},{"location":"ShaderGraph/Rejection-Node/","text":"Rejection Node Description Returns the result of the projection of the value of input A onto the plane orthogonal, or perpendicular, to the value of input B . The value of the rejection vector is equal to the original vector, the value of input A , minus the value of the Projection of the same inputs. Ports Name Direction Type Description A Input Dynamic Vector First input value B Input Dynamic Vector Second input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Rejection_float4(float4 A, float4 B, out float4 Out) { Out = A - (B * dot(A, B) / dot(B, B)) }","title":"Rejection Node"},{"location":"ShaderGraph/Rejection-Node/#rejection-node","text":"","title":"Rejection Node"},{"location":"ShaderGraph/Rejection-Node/#description","text":"Returns the result of the projection of the value of input A onto the plane orthogonal, or perpendicular, to the value of input B . The value of the rejection vector is equal to the original vector, the value of input A , minus the value of the Projection of the same inputs.","title":"Description"},{"location":"ShaderGraph/Rejection-Node/#ports","text":"Name Direction Type Description A Input Dynamic Vector First input value B Input Dynamic Vector Second input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Rejection-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Rejection_float4(float4 A, float4 B, out float4 Out) { Out = A - (B * dot(A, B) / dot(B, B)) }","title":"Generated Code Example"},{"location":"ShaderGraph/Remap-Node/","text":"Remap Node Description Returns a value between the x and y components of input Out Min Max based on the linear interpolation of the value of input In between the x and y components of input In Min Max . Ports Name Direction Type Description In Input Dynamic Vector Input value In Min Max Input Vector 2 Minimum and Maximum values for input interpolation Out Min Max Input Vector 2 Minimum and Maximum values for output interpolation Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Remap_float4(float4 In, float2 InMinMax, float2 OutMinMax, out float4 Out) { Out = OutMinMax.x + (In - InMinMax.x) * (OutMinMax.y - OutMinMax.x) / (InMinMax.y - InMinMax.x); }","title":"Remap Node"},{"location":"ShaderGraph/Remap-Node/#remap-node","text":"","title":"Remap Node"},{"location":"ShaderGraph/Remap-Node/#description","text":"Returns a value between the x and y components of input Out Min Max based on the linear interpolation of the value of input In between the x and y components of input In Min Max .","title":"Description"},{"location":"ShaderGraph/Remap-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value In Min Max Input Vector 2 Minimum and Maximum values for input interpolation Out Min Max Input Vector 2 Minimum and Maximum values for output interpolation Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Remap-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Remap_float4(float4 In, float2 InMinMax, float2 OutMinMax, out float4 Out) { Out = OutMinMax.x + (In - InMinMax.x) * (OutMinMax.y - OutMinMax.x) / (InMinMax.y - InMinMax.x); }","title":"Generated Code Example"},{"location":"ShaderGraph/Replace-Color-Node/","text":"Replace Color Node Description Replaces values in input In equal to input From to the value of input To . Input Range can be used to define a wider range of values around input From to replace. Input Fuzziness can be used to soften the edges around the selection similar to anti-aliasing. Ports Name Direction Type Binding Description In Input Vector 3 None Input value From Input Vector 3 Color Color to replace To Input Vector 3 Color Color to replace with Range Input Vector 1 None Replace colors within this range from input From Fuzziness Input Vector 1 None Soften edges around selection Out Output Vector 3 None Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_ReplaceColor_float(float3 In, float3 From, float3 To, float Range, float Fuzziness, out float3 Out) { float Distance = distance(From, In); Out = lerp(To, In, saturate((Distance - Range) / max(Fuzziness, 1e-5f))); }","title":"Replace Color Node"},{"location":"ShaderGraph/Replace-Color-Node/#replace-color-node","text":"","title":"Replace Color Node"},{"location":"ShaderGraph/Replace-Color-Node/#description","text":"Replaces values in input In equal to input From to the value of input To . Input Range can be used to define a wider range of values around input From to replace. Input Fuzziness can be used to soften the edges around the selection similar to anti-aliasing.","title":"Description"},{"location":"ShaderGraph/Replace-Color-Node/#ports","text":"Name Direction Type Binding Description In Input Vector 3 None Input value From Input Vector 3 Color Color to replace To Input Vector 3 Color Color to replace with Range Input Vector 1 None Replace colors within this range from input From Fuzziness Input Vector 1 None Soften edges around selection Out Output Vector 3 None Output value","title":"Ports"},{"location":"ShaderGraph/Replace-Color-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_ReplaceColor_float(float3 In, float3 From, float3 To, float Range, float Fuzziness, out float3 Out) { float Distance = distance(From, In); Out = lerp(To, In, saturate((Distance - Range) / max(Fuzziness, 1e-5f))); }","title":"Generated Code Example"},{"location":"ShaderGraph/Rotate-About-Axis-Node/","text":"Rotate About Axis Node Description Rotates the input vector In around the axis Axis by the value of Rotation . The unit for rotation angle can be selected by the parameter Unit . Ports Name Direction Type Binding Description In Input Vector 3 None Input value Axis Input Vector 3 None Axis to rotate around Rotation Input Vector 1 None Amount of rotation to apply Out Output Vector 3 None Output value Controls Name Type Options Description Unit Dropdown Radians, Degrees Switches the unit for input Rotation Generated Code Example The following example code represents one possible outcome of this node per Unit mode. Radians void Unity_RotateAboutAxis_Radians_float(float3 In, float3 Axis, float Rotation, out float3 Out) { Rotation = radians(Rotation); float s = sin(Rotation); float c = cos(Rotation); float one_minus_c = 1.0 - c; Axis = normalize(Axis); float3x3 rot_mat = { one_minus_c * Axis.x * Axis.x + c, one_minus_c * Axis.x * Axis.y - Axis.z * s, one_minus_c * Axis.z * Axis.x + Axis.y * s, one_minus_c * Axis.x * Axis.y + Axis.z * s, one_minus_c * Axis.y * Axis.y + c, one_minus_c * Axis.y * Axis.z - Axis.x * s, one_minus_c * Axis.z * Axis.x - Axis.y * s, one_minus_c * Axis.y * Axis.z + Axis.x * s, one_minus_c * Axis.z * Axis.z + c }; Out = mul(rot_mat, In); } Degrees void Unity_RotateAboutAxis_Degrees_float(float3 In, float3 Axis, float Rotation, out float3 Out) { float s = sin(Rotation); float c = cos(Rotation); float one_minus_c = 1.0 - c; Axis = normalize(Axis); float3x3 rot_mat = { one_minus_c * Axis.x * Axis.x + c, one_minus_c * Axis.x * Axis.y - Axis.z * s, one_minus_c * Axis.z * Axis.x + Axis.y * s, one_minus_c * Axis.x * Axis.y + Axis.z * s, one_minus_c * Axis.y * Axis.y + c, one_minus_c * Axis.y * Axis.z - Axis.x * s, one_minus_c * Axis.z * Axis.x - Axis.y * s, one_minus_c * Axis.y * Axis.z + Axis.x * s, one_minus_c * Axis.z * Axis.z + c }; Out = mul(rot_mat, In); }","title":"Rotate About Axis Node"},{"location":"ShaderGraph/Rotate-About-Axis-Node/#rotate-about-axis-node","text":"","title":"Rotate About Axis Node"},{"location":"ShaderGraph/Rotate-About-Axis-Node/#description","text":"Rotates the input vector In around the axis Axis by the value of Rotation . The unit for rotation angle can be selected by the parameter Unit .","title":"Description"},{"location":"ShaderGraph/Rotate-About-Axis-Node/#ports","text":"Name Direction Type Binding Description In Input Vector 3 None Input value Axis Input Vector 3 None Axis to rotate around Rotation Input Vector 1 None Amount of rotation to apply Out Output Vector 3 None Output value","title":"Ports"},{"location":"ShaderGraph/Rotate-About-Axis-Node/#controls","text":"Name Type Options Description Unit Dropdown Radians, Degrees Switches the unit for input Rotation","title":"Controls"},{"location":"ShaderGraph/Rotate-About-Axis-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node per Unit mode. Radians void Unity_RotateAboutAxis_Radians_float(float3 In, float3 Axis, float Rotation, out float3 Out) { Rotation = radians(Rotation); float s = sin(Rotation); float c = cos(Rotation); float one_minus_c = 1.0 - c; Axis = normalize(Axis); float3x3 rot_mat = { one_minus_c * Axis.x * Axis.x + c, one_minus_c * Axis.x * Axis.y - Axis.z * s, one_minus_c * Axis.z * Axis.x + Axis.y * s, one_minus_c * Axis.x * Axis.y + Axis.z * s, one_minus_c * Axis.y * Axis.y + c, one_minus_c * Axis.y * Axis.z - Axis.x * s, one_minus_c * Axis.z * Axis.x - Axis.y * s, one_minus_c * Axis.y * Axis.z + Axis.x * s, one_minus_c * Axis.z * Axis.z + c }; Out = mul(rot_mat, In); } Degrees void Unity_RotateAboutAxis_Degrees_float(float3 In, float3 Axis, float Rotation, out float3 Out) { float s = sin(Rotation); float c = cos(Rotation); float one_minus_c = 1.0 - c; Axis = normalize(Axis); float3x3 rot_mat = { one_minus_c * Axis.x * Axis.x + c, one_minus_c * Axis.x * Axis.y - Axis.z * s, one_minus_c * Axis.z * Axis.x + Axis.y * s, one_minus_c * Axis.x * Axis.y + Axis.z * s, one_minus_c * Axis.y * Axis.y + c, one_minus_c * Axis.y * Axis.z - Axis.x * s, one_minus_c * Axis.z * Axis.x - Axis.y * s, one_minus_c * Axis.y * Axis.z + Axis.x * s, one_minus_c * Axis.z * Axis.z + c }; Out = mul(rot_mat, In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Rotate-Node/","text":"Rotate Node Description Rotates value of input UV around a reference point defined by input Center by the amount of input Rotation . The unit for rotation angle can be selected by the parameter Unit . Ports Name Direction Type Binding Description UV Input Vector 2 UV Input UV value Center Input Vector 2 None Center point to rotate around Rotation Input Vector 1 None Amount of rotation to apply Out Output Vector 2 None Output UV value Controls Name Type Options Description Unit Dropdown Radians, Degrees Switches the unit for input Rotation Generated Code Example The following example code represents one possible outcome of this node per Unit mode. Radians void Unity_Rotate_Radians_float(float2 UV, float2 Center, float Rotation, out float2 Out) { UV -= Center; float s = sin(Rotation); float c = cos(Rotation); float2x2 rMatrix = float2x2(c, -s, s, c); rMatrix *= 0.5; rMatrix += 0.5; rMatrix = rMatrix * 2 - 1; UV.xy = mul(UV.xy, rMatrix); UV += Center; Out = UV; } Degrees void Unity_Rotate_Degrees_float(float2 UV, float2 Center, float Rotation, out float2 Out) { Rotation = Rotation * (3.1415926f/180.0f); UV -= Center; float s = sin(Rotation); float c = cos(Rotation); float2x2 rMatrix = float2x2(c, -s, s, c); rMatrix *= 0.5; rMatrix += 0.5; rMatrix = rMatrix * 2 - 1; UV.xy = mul(UV.xy, rMatrix); UV += Center; Out = UV; }","title":"Rotate Node"},{"location":"ShaderGraph/Rotate-Node/#rotate-node","text":"","title":"Rotate Node"},{"location":"ShaderGraph/Rotate-Node/#description","text":"Rotates value of input UV around a reference point defined by input Center by the amount of input Rotation . The unit for rotation angle can be selected by the parameter Unit .","title":"Description"},{"location":"ShaderGraph/Rotate-Node/#ports","text":"Name Direction Type Binding Description UV Input Vector 2 UV Input UV value Center Input Vector 2 None Center point to rotate around Rotation Input Vector 1 None Amount of rotation to apply Out Output Vector 2 None Output UV value","title":"Ports"},{"location":"ShaderGraph/Rotate-Node/#controls","text":"Name Type Options Description Unit Dropdown Radians, Degrees Switches the unit for input Rotation","title":"Controls"},{"location":"ShaderGraph/Rotate-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node per Unit mode. Radians void Unity_Rotate_Radians_float(float2 UV, float2 Center, float Rotation, out float2 Out) { UV -= Center; float s = sin(Rotation); float c = cos(Rotation); float2x2 rMatrix = float2x2(c, -s, s, c); rMatrix *= 0.5; rMatrix += 0.5; rMatrix = rMatrix * 2 - 1; UV.xy = mul(UV.xy, rMatrix); UV += Center; Out = UV; } Degrees void Unity_Rotate_Degrees_float(float2 UV, float2 Center, float Rotation, out float2 Out) { Rotation = Rotation * (3.1415926f/180.0f); UV -= Center; float s = sin(Rotation); float c = cos(Rotation); float2x2 rMatrix = float2x2(c, -s, s, c); rMatrix *= 0.5; rMatrix += 0.5; rMatrix = rMatrix * 2 - 1; UV.xy = mul(UV.xy, rMatrix); UV += Center; Out = UV; }","title":"Generated Code Example"},{"location":"ShaderGraph/Round-Node/","text":"Round Node Description Returns the value of input In rounded to the nearest integer, or whole number. Ports Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Round_float4(float4 In, out float4 Out) { Out = round(In); }","title":"Round Node"},{"location":"ShaderGraph/Round-Node/#round-node","text":"","title":"Round Node"},{"location":"ShaderGraph/Round-Node/#description","text":"Returns the value of input In rounded to the nearest integer, or whole number.","title":"Description"},{"location":"ShaderGraph/Round-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Round-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Round_float4(float4 In, out float4 Out) { Out = round(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Rounded-Rectangle-Node/","text":"Rounded Rectangle Node Description Generates a rounded rectangle shape based on input UV at the size specified by inputs Width and Height . The radius of each corner is defined by input Radius . The generated shape can be offset or tiled by connecting a Tiling And Offset Node . Note that in order to preserve the ability to offset the shape within the UV space the shape will not automatically repeat if tiled. To achieve a repeating rounded rectangle effect first connect your input through a Fraction Node . NOTE: This Node can only be used in the Fragment Shader Stage . Ports Name Direction Type Binding Description UV Input Vector 2 UV Input UV value Width Input Vector 1 None Rounded Rectangle width Height Input Vector 1 None Rounded Rectangle height Radius Input Vector 1 None Corner radius Out Output Vector 1 None Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_RoundedRectangle_float(float2 UV, float Width, float Height, float Radius, out float Out) { Radius = max(min(min(abs(Radius * 2), abs(Width)), abs(Height)), 1e-5); float2 uv = abs(UV * 2 - 1) - float2(Width, Height) + Radius; float d = length(max(0, uv)) / Radius; Out = saturate((1 - d) / fwidth(d)); }","title":"Rounded Rectangle Node"},{"location":"ShaderGraph/Rounded-Rectangle-Node/#rounded-rectangle-node","text":"","title":"Rounded Rectangle Node"},{"location":"ShaderGraph/Rounded-Rectangle-Node/#description","text":"Generates a rounded rectangle shape based on input UV at the size specified by inputs Width and Height . The radius of each corner is defined by input Radius . The generated shape can be offset or tiled by connecting a Tiling And Offset Node . Note that in order to preserve the ability to offset the shape within the UV space the shape will not automatically repeat if tiled. To achieve a repeating rounded rectangle effect first connect your input through a Fraction Node . NOTE: This Node can only be used in the Fragment Shader Stage .","title":"Description"},{"location":"ShaderGraph/Rounded-Rectangle-Node/#ports","text":"Name Direction Type Binding Description UV Input Vector 2 UV Input UV value Width Input Vector 1 None Rounded Rectangle width Height Input Vector 1 None Rounded Rectangle height Radius Input Vector 1 None Corner radius Out Output Vector 1 None Output value","title":"Ports"},{"location":"ShaderGraph/Rounded-Rectangle-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_RoundedRectangle_float(float2 UV, float Width, float Height, float Radius, out float Out) { Radius = max(min(min(abs(Radius * 2), abs(Width)), abs(Height)), 1e-5); float2 uv = abs(UV * 2 - 1) - float2(Width, Height) + Radius; float d = length(max(0, uv)) / Radius; Out = saturate((1 - d) / fwidth(d)); }","title":"Generated Code Example"},{"location":"ShaderGraph/Sample-Cubemap-Node/","text":"Sample Cubemap Node Description Samples a Cubemap and returns a Vector 4 color value for use in the shader. Requires View Direction and Normal inputs to sample the Cubemap . You can achieve a blurring effect by sampling at a different Level of Detail using the LOD input. You can also define a custom Sampler State using the Sampler input. Ports Name Direction Type Binding Description Cube Input Cubemap None Cubemap to sample View Dir Input Vector 3 View Direction (object space) Mesh's view direction Normal Input Vector 3 Normal (object space) Mesh's normal vector Sampler Input Sampler State Default sampler state Sampler for the Cubemap LOD Input Vector 1 None Level of detail for sampling Out Output Vector 4 None Output value Generated Code Example The following example code represents one possible outcome of this node. float4 _SampleCubemap_Out = SAMPLE_TEXTURECUBE_LOD(Cubemap, Sampler, reflect(-ViewDir, Normal), LOD);","title":"Sample Cubemap Node"},{"location":"ShaderGraph/Sample-Cubemap-Node/#sample-cubemap-node","text":"","title":"Sample Cubemap Node"},{"location":"ShaderGraph/Sample-Cubemap-Node/#description","text":"Samples a Cubemap and returns a Vector 4 color value for use in the shader. Requires View Direction and Normal inputs to sample the Cubemap . You can achieve a blurring effect by sampling at a different Level of Detail using the LOD input. You can also define a custom Sampler State using the Sampler input.","title":"Description"},{"location":"ShaderGraph/Sample-Cubemap-Node/#ports","text":"Name Direction Type Binding Description Cube Input Cubemap None Cubemap to sample View Dir Input Vector 3 View Direction (object space) Mesh's view direction Normal Input Vector 3 Normal (object space) Mesh's normal vector Sampler Input Sampler State Default sampler state Sampler for the Cubemap LOD Input Vector 1 None Level of detail for sampling Out Output Vector 4 None Output value","title":"Ports"},{"location":"ShaderGraph/Sample-Cubemap-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. float4 _SampleCubemap_Out = SAMPLE_TEXTURECUBE_LOD(Cubemap, Sampler, reflect(-ViewDir, Normal), LOD);","title":"Generated Code Example"},{"location":"ShaderGraph/Sample-Gradient-Node/","text":"Sample Gradient Node Description Samples a Gradient given the input of Time . Returns a Vector 4 color value for use in the shader. Ports Name Direction Type Binding Description Gradient Input Gradient None Gradient to sample Time Input Vector 1 None Point at which to sample gradient Out Output Vector 4 None Output value as Vector4 Generated Code Example The following example code represents one possible outcome of this node. void Unity_SampleGradient_float(float4 Gradient, float Time, out float4 Out) { float3 color = Gradient.colors[0].rgb; [unroll] for (int c = 1; c < 8; c++) { float colorPos = saturate((Time - Gradient.colors[c-1].w) / (Gradient.colors[c].w - Gradient.colors[c-1].w)) * step(c, Gradient.colorsLength-1); color = lerp(color, Gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), Gradient.type)); } #ifndef UNITY_COLORSPACE_GAMMA color = SRGBToLinear(color); #endif float alpha = Gradient.alphas[0].x; [unroll] for (int a = 1; a < 8; a++) { float alphaPos = saturate((Time - Gradient.alphas[a-1].y) / (Gradient.alphas[a].y - Gradient.alphas[a-1].y)) * step(a, Gradient.alphasLength-1); alpha = lerp(alpha, Gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), Gradient.type)); } Out = float4(color, alpha); }","title":"Sample Gradient Node"},{"location":"ShaderGraph/Sample-Gradient-Node/#sample-gradient-node","text":"","title":"Sample Gradient Node"},{"location":"ShaderGraph/Sample-Gradient-Node/#description","text":"Samples a Gradient given the input of Time . Returns a Vector 4 color value for use in the shader.","title":"Description"},{"location":"ShaderGraph/Sample-Gradient-Node/#ports","text":"Name Direction Type Binding Description Gradient Input Gradient None Gradient to sample Time Input Vector 1 None Point at which to sample gradient Out Output Vector 4 None Output value as Vector4","title":"Ports"},{"location":"ShaderGraph/Sample-Gradient-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_SampleGradient_float(float4 Gradient, float Time, out float4 Out) { float3 color = Gradient.colors[0].rgb; [unroll] for (int c = 1; c < 8; c++) { float colorPos = saturate((Time - Gradient.colors[c-1].w) / (Gradient.colors[c].w - Gradient.colors[c-1].w)) * step(c, Gradient.colorsLength-1); color = lerp(color, Gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), Gradient.type)); } #ifndef UNITY_COLORSPACE_GAMMA color = SRGBToLinear(color); #endif float alpha = Gradient.alphas[0].x; [unroll] for (int a = 1; a < 8; a++) { float alphaPos = saturate((Time - Gradient.alphas[a-1].y) / (Gradient.alphas[a].y - Gradient.alphas[a-1].y)) * step(a, Gradient.alphasLength-1); alpha = lerp(alpha, Gradient.alphas[a].x, lerp(alphaPos, step(0.01, alphaPos), Gradient.type)); } Out = float4(color, alpha); }","title":"Generated Code Example"},{"location":"ShaderGraph/Sample-Texture-2D-Array-Node/","text":"Sample Texture 2D Array Node Description Samples a Texture 2D Array and returns a Vector 4 color value for use in the shader. You can override the UV coordinates using the UV input and define a custom Sampler State using the Sampler input. Use the Index input to specify which index of the array to sample. NOTE: This Node can only be used in the Fragment shader stage. Ports Name Direction Type Binding Description Texture Array Input Texture 2D Array None Texture 2D Array to sample Index Input Vector 1 None Index of array to sample UV Input Vector 2 UV Mesh's normal vector Sampler Input Sampler State Default sampler state Sampler for the texture RGBA Output Vector 4 None Output value as RGBA R Output Vector 1 None red (x) component of RGBA output G Output Vector 1 None green (y) component of RGBA output B Output Vector 1 None blue (z) component of RGBA output A Output Vector 1 None alpha (w) component of RGBA output Generated Code Example The following example code represents one possible outcome of this node. float4 _SampleTexture2DArray_RGBA = SAMPLE_TEXTURE2D_ARRAY(Texture, Sampler, UV, Index); float _SampleTexture2DArray_R = _SampleTexture2DArray_RGBA.r; float _SampleTexture2DArray_G = _SampleTexture2DArray_RGBA.g; float _SampleTexture2DArray_B = _SampleTexture2DArray_RGBA.b; float _SampleTexture2DArray_A = _SampleTexture2DArray_RGBA.a;","title":"Sample Texture 2D Array Node"},{"location":"ShaderGraph/Sample-Texture-2D-Array-Node/#sample-texture-2d-array-node","text":"","title":"Sample Texture 2D Array Node"},{"location":"ShaderGraph/Sample-Texture-2D-Array-Node/#description","text":"Samples a Texture 2D Array and returns a Vector 4 color value for use in the shader. You can override the UV coordinates using the UV input and define a custom Sampler State using the Sampler input. Use the Index input to specify which index of the array to sample. NOTE: This Node can only be used in the Fragment shader stage.","title":"Description"},{"location":"ShaderGraph/Sample-Texture-2D-Array-Node/#ports","text":"Name Direction Type Binding Description Texture Array Input Texture 2D Array None Texture 2D Array to sample Index Input Vector 1 None Index of array to sample UV Input Vector 2 UV Mesh's normal vector Sampler Input Sampler State Default sampler state Sampler for the texture RGBA Output Vector 4 None Output value as RGBA R Output Vector 1 None red (x) component of RGBA output G Output Vector 1 None green (y) component of RGBA output B Output Vector 1 None blue (z) component of RGBA output A Output Vector 1 None alpha (w) component of RGBA output","title":"Ports"},{"location":"ShaderGraph/Sample-Texture-2D-Array-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. float4 _SampleTexture2DArray_RGBA = SAMPLE_TEXTURE2D_ARRAY(Texture, Sampler, UV, Index); float _SampleTexture2DArray_R = _SampleTexture2DArray_RGBA.r; float _SampleTexture2DArray_G = _SampleTexture2DArray_RGBA.g; float _SampleTexture2DArray_B = _SampleTexture2DArray_RGBA.b; float _SampleTexture2DArray_A = _SampleTexture2DArray_RGBA.a;","title":"Generated Code Example"},{"location":"ShaderGraph/Sample-Texture-2D-LOD-Node/","text":"Sample Texture 2D LOD Node Description Samples a Texture 2D and returns a Vector 4 color value for use in the shader. You can override the UV coordinates using the UV input and define a custom Sampler State using the Sampler input. Use the LOD input to adjust the level of detail of the sample. To use the Sample Texture 2D LOD Node to sample a normal map, set the Type dropdown parameter to Normal . This Node is useful for sampling a Texture in the vertex Shader Stage as the Sample Texture 2D Node is unavailable in this Shader Stage . Ports Name Direction Type Binding Description Texture Input Texture 2D None Texture 2D to sample UV Input Vector 2 UV Mesh's normal vector Sampler Input Sampler State Default sampler state Sampler for the texture LOD Input Vector 1 None Level of detail to sample RGBA Output Vector 4 None Output value as RGBA R Output Vector 1 None red (x) component of RGBA output G Output Vector 1 None green (y) component of RGBA output B Output Vector 1 None blue (z) component of RGBA output A Output Vector 1 None alpha (w) component of RGBA output Controls Name Type Options Description Type Dropdown Default, Normal Selects the texture type Generated Code Example The following example code represents one possible outcome of this node per Type mode. Default float4 _SampleTexture2DLOD_RGBA = SAMPLE_TEXTURE2D_LOD(Texture, Sampler, UV, LOD); float _SampleTexture2DLOD_R = _SampleTexture2DLOD_RGBA.r; float _SampleTexture2DLOD_G = _SampleTexture2DLOD_RGBA.g; float _SampleTexture2DLOD_B = _SampleTexture2DLOD_RGBA.b; float _SampleTexture2DLOD_A = _SampleTexture2DLOD_RGBA.a; Normal float4 _SampleTexture2DLOD_RGBA = SAMPLE_TEXTURE2D_LOD(Texture, Sampler, UV, LOD); _SampleTexture2DLOD_RGBA.rgb = UnpackNormalRGorAG(_SampleTexture2DLOD_RGBA); float _SampleTexture2DLOD_R = _SampleTexture2DLOD_RGBA.r; float _SampleTexture2DLOD_G = _SampleTexture2DLOD_RGBA.g; float _SampleTexture2DLOD_B = _SampleTexture2DLOD_RGBA.b; float _SampleTexture2DLOD_A = _SampleTexture2DLOD_RGBA.a;","title":"Sample Texture 2D LOD Node"},{"location":"ShaderGraph/Sample-Texture-2D-LOD-Node/#sample-texture-2d-lod-node","text":"","title":"Sample Texture 2D LOD Node"},{"location":"ShaderGraph/Sample-Texture-2D-LOD-Node/#description","text":"Samples a Texture 2D and returns a Vector 4 color value for use in the shader. You can override the UV coordinates using the UV input and define a custom Sampler State using the Sampler input. Use the LOD input to adjust the level of detail of the sample. To use the Sample Texture 2D LOD Node to sample a normal map, set the Type dropdown parameter to Normal . This Node is useful for sampling a Texture in the vertex Shader Stage as the Sample Texture 2D Node is unavailable in this Shader Stage .","title":"Description"},{"location":"ShaderGraph/Sample-Texture-2D-LOD-Node/#ports","text":"Name Direction Type Binding Description Texture Input Texture 2D None Texture 2D to sample UV Input Vector 2 UV Mesh's normal vector Sampler Input Sampler State Default sampler state Sampler for the texture LOD Input Vector 1 None Level of detail to sample RGBA Output Vector 4 None Output value as RGBA R Output Vector 1 None red (x) component of RGBA output G Output Vector 1 None green (y) component of RGBA output B Output Vector 1 None blue (z) component of RGBA output A Output Vector 1 None alpha (w) component of RGBA output","title":"Ports"},{"location":"ShaderGraph/Sample-Texture-2D-LOD-Node/#controls","text":"Name Type Options Description Type Dropdown Default, Normal Selects the texture type","title":"Controls"},{"location":"ShaderGraph/Sample-Texture-2D-LOD-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node per Type mode. Default float4 _SampleTexture2DLOD_RGBA = SAMPLE_TEXTURE2D_LOD(Texture, Sampler, UV, LOD); float _SampleTexture2DLOD_R = _SampleTexture2DLOD_RGBA.r; float _SampleTexture2DLOD_G = _SampleTexture2DLOD_RGBA.g; float _SampleTexture2DLOD_B = _SampleTexture2DLOD_RGBA.b; float _SampleTexture2DLOD_A = _SampleTexture2DLOD_RGBA.a; Normal float4 _SampleTexture2DLOD_RGBA = SAMPLE_TEXTURE2D_LOD(Texture, Sampler, UV, LOD); _SampleTexture2DLOD_RGBA.rgb = UnpackNormalRGorAG(_SampleTexture2DLOD_RGBA); float _SampleTexture2DLOD_R = _SampleTexture2DLOD_RGBA.r; float _SampleTexture2DLOD_G = _SampleTexture2DLOD_RGBA.g; float _SampleTexture2DLOD_B = _SampleTexture2DLOD_RGBA.b; float _SampleTexture2DLOD_A = _SampleTexture2DLOD_RGBA.a;","title":"Generated Code Example"},{"location":"ShaderGraph/Sample-Texture-2D-Node/","text":"Sample Texture 2D Node Description Samples a Texture 2D and returns a Vector 4 color value for use in the shader. You can override the UV coordinates using the UV input and define a custom Sampler State using the Sampler input. To use the Sample Texture 2D Node to sample a normal map, set the Type dropdown parameter to Normal . NOTE: This Node can only be used in the Fragment Shader Stage . To sample a Texture 2D in the Vertex Shader Stage use a Sample Texture 2D LOD Node instead. Ports Name Direction Type Binding Description Texture Input Texture 2D None Texture 2D to sample UV Input Vector 2 UV Mesh's normal vector Sampler Input Sampler State Default sampler state Sampler for the texture RGBA Output Vector 4 None Output value as RGBA R Output Vector 1 None red (x) component of RGBA output G Output Vector 1 None green (y) component of RGBA output B Output Vector 1 None blue (z) component of RGBA output A Output Vector 1 None alpha (w) component of RGBA output Controls Name Type Options Description Type Dropdown Default, Normal Selects the texture type Generated Code Example The following example code represents one possible outcome of this node per Type mode. Default float4 _SampleTexture2D_RGBA = SAMPLE_TEXTURE2D(Texture, Sampler, UV); float _SampleTexture2D_R = _SampleTexture2D_RGBA.r; float _SampleTexture2D_G = _SampleTexture2D_RGBA.g; float _SampleTexture2D_B = _SampleTexture2D_RGBA.b; float _SampleTexture2D_A = _SampleTexture2D_RGBA.a; Normal float4 _SampleTexture2D_RGBA = SAMPLE_TEXTURE2D(Texture, Sampler, UV); _SampleTexture2D_RGBA.rgb = UnpackNormalRGorAG(_SampleTexture2D_RGBA); float _SampleTexture2D_R = _SampleTexture2D_RGBA.r; float _SampleTexture2D_G = _SampleTexture2D_RGBA.g; float _SampleTexture2D_B = _SampleTexture2D_RGBA.b; float _SampleTexture2D_A = _SampleTexture2D_RGBA.a;","title":"Sample Texture 2D Node"},{"location":"ShaderGraph/Sample-Texture-2D-Node/#sample-texture-2d-node","text":"","title":"Sample Texture 2D Node"},{"location":"ShaderGraph/Sample-Texture-2D-Node/#description","text":"Samples a Texture 2D and returns a Vector 4 color value for use in the shader. You can override the UV coordinates using the UV input and define a custom Sampler State using the Sampler input. To use the Sample Texture 2D Node to sample a normal map, set the Type dropdown parameter to Normal . NOTE: This Node can only be used in the Fragment Shader Stage . To sample a Texture 2D in the Vertex Shader Stage use a Sample Texture 2D LOD Node instead.","title":"Description"},{"location":"ShaderGraph/Sample-Texture-2D-Node/#ports","text":"Name Direction Type Binding Description Texture Input Texture 2D None Texture 2D to sample UV Input Vector 2 UV Mesh's normal vector Sampler Input Sampler State Default sampler state Sampler for the texture RGBA Output Vector 4 None Output value as RGBA R Output Vector 1 None red (x) component of RGBA output G Output Vector 1 None green (y) component of RGBA output B Output Vector 1 None blue (z) component of RGBA output A Output Vector 1 None alpha (w) component of RGBA output","title":"Ports"},{"location":"ShaderGraph/Sample-Texture-2D-Node/#controls","text":"Name Type Options Description Type Dropdown Default, Normal Selects the texture type","title":"Controls"},{"location":"ShaderGraph/Sample-Texture-2D-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node per Type mode. Default float4 _SampleTexture2D_RGBA = SAMPLE_TEXTURE2D(Texture, Sampler, UV); float _SampleTexture2D_R = _SampleTexture2D_RGBA.r; float _SampleTexture2D_G = _SampleTexture2D_RGBA.g; float _SampleTexture2D_B = _SampleTexture2D_RGBA.b; float _SampleTexture2D_A = _SampleTexture2D_RGBA.a; Normal float4 _SampleTexture2D_RGBA = SAMPLE_TEXTURE2D(Texture, Sampler, UV); _SampleTexture2D_RGBA.rgb = UnpackNormalRGorAG(_SampleTexture2D_RGBA); float _SampleTexture2D_R = _SampleTexture2D_RGBA.r; float _SampleTexture2D_G = _SampleTexture2D_RGBA.g; float _SampleTexture2D_B = _SampleTexture2D_RGBA.b; float _SampleTexture2D_A = _SampleTexture2D_RGBA.a;","title":"Generated Code Example"},{"location":"ShaderGraph/Sample-Texture-3D-Node/","text":"Sample Texture 3D Node Description Samples a Texture 3D and returns a Vector 4 color value for use in the shader. You can override the UV coordinates using the UV input and define a custom Sampler State using the Sampler input. NOTE: This Node can only be used in the Fragment Shader Stage . Ports Name Direction Type Binding Description Texture Input Texture 3D None Texture 3D to sample UV Input Vector 3 None 3 dimnensional UV coordinates Sampler Input Sampler State Default sampler state Sampler for the texture RGBA Output Vector 4 None Output value as RGBA Generated Code Example The following example code represents one possible outcome of this node. float4 _SampleTexture3D_Out = SAMPLE_TEXTURE3D(Texture, Sampler, UV);","title":"Sample Texture 3D Node"},{"location":"ShaderGraph/Sample-Texture-3D-Node/#sample-texture-3d-node","text":"","title":"Sample Texture 3D Node"},{"location":"ShaderGraph/Sample-Texture-3D-Node/#description","text":"Samples a Texture 3D and returns a Vector 4 color value for use in the shader. You can override the UV coordinates using the UV input and define a custom Sampler State using the Sampler input. NOTE: This Node can only be used in the Fragment Shader Stage .","title":"Description"},{"location":"ShaderGraph/Sample-Texture-3D-Node/#ports","text":"Name Direction Type Binding Description Texture Input Texture 3D None Texture 3D to sample UV Input Vector 3 None 3 dimnensional UV coordinates Sampler Input Sampler State Default sampler state Sampler for the texture RGBA Output Vector 4 None Output value as RGBA","title":"Ports"},{"location":"ShaderGraph/Sample-Texture-3D-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. float4 _SampleTexture3D_Out = SAMPLE_TEXTURE3D(Texture, Sampler, UV);","title":"Generated Code Example"},{"location":"ShaderGraph/Sampler-State-Node/","text":"Sampler State Node Description Defines a Sampler State for sampling textures. It should be used in conjunction with sampling Nodes such as the Sample Texture 2D Node . You can set a filter mode with the dropdown parameter Filter and a wrap mode with the dropdown parameter Wrap . When using a separate Sample State Node you can sample a Texture 2D twice, with different sampler parameters, without defining the Texture 2D itself twice. Some filtering and wrap modes are only available on certain platforms. Ports Name Direction Type Binding Description Out Output Sampler State None Output value Controls Name Type Options Description Filter Dropdown Linear, Point, Trilinear Defines filtering mode for sampling. Wrap Dropdown Repeat, Clamp, Mirror, MirrorOnce Defines wrap mode for sampling. Generated Code Example The following example code represents one possible outcome of this node. SamplerState _SamplerState_Out = _SamplerState_Linear_Repeat_sampler;","title":"Sampler State Node"},{"location":"ShaderGraph/Sampler-State-Node/#sampler-state-node","text":"","title":"Sampler State Node"},{"location":"ShaderGraph/Sampler-State-Node/#description","text":"Defines a Sampler State for sampling textures. It should be used in conjunction with sampling Nodes such as the Sample Texture 2D Node . You can set a filter mode with the dropdown parameter Filter and a wrap mode with the dropdown parameter Wrap . When using a separate Sample State Node you can sample a Texture 2D twice, with different sampler parameters, without defining the Texture 2D itself twice. Some filtering and wrap modes are only available on certain platforms.","title":"Description"},{"location":"ShaderGraph/Sampler-State-Node/#ports","text":"Name Direction Type Binding Description Out Output Sampler State None Output value","title":"Ports"},{"location":"ShaderGraph/Sampler-State-Node/#controls","text":"Name Type Options Description Filter Dropdown Linear, Point, Trilinear Defines filtering mode for sampling. Wrap Dropdown Repeat, Clamp, Mirror, MirrorOnce Defines wrap mode for sampling.","title":"Controls"},{"location":"ShaderGraph/Sampler-State-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. SamplerState _SamplerState_Out = _SamplerState_Linear_Repeat_sampler;","title":"Generated Code Example"},{"location":"ShaderGraph/Saturate-Node/","text":"Saturate Node Description Returns the value of input In clamped between 0 and 1. Ports Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Saturate_float4(float4 In, out float4 Out) { Out = saturate(In); }","title":"Saturate Node"},{"location":"ShaderGraph/Saturate-Node/#saturate-node","text":"","title":"Saturate Node"},{"location":"ShaderGraph/Saturate-Node/#description","text":"Returns the value of input In clamped between 0 and 1.","title":"Description"},{"location":"ShaderGraph/Saturate-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Saturate-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Saturate_float4(float4 In, out float4 Out) { Out = saturate(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Saturation-Node/","text":"Saturation Node Description Adjusts the saturation of input In by the amount of input Saturation . A Saturation value of 1 will return the input unaltered. A Saturation value of 0 will return the input completely desaturated. Ports Name Direction Type Binding Description In Input Vector 3 None Input value Saturation Input Vector 1 None Saturation value Out Output Vector 3 None Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Saturation_float(float3 In, float Saturation, out float3 Out) { float luma = dot(In, float3(0.2126729, 0.7151522, 0.0721750)); Out = luma.xxx + Saturation.xxx * (In - luma.xxx); }","title":"Saturation Node"},{"location":"ShaderGraph/Saturation-Node/#saturation-node","text":"","title":"Saturation Node"},{"location":"ShaderGraph/Saturation-Node/#description","text":"Adjusts the saturation of input In by the amount of input Saturation . A Saturation value of 1 will return the input unaltered. A Saturation value of 0 will return the input completely desaturated.","title":"Description"},{"location":"ShaderGraph/Saturation-Node/#ports","text":"Name Direction Type Binding Description In Input Vector 3 None Input value Saturation Input Vector 1 None Saturation value Out Output Vector 3 None Output value","title":"Ports"},{"location":"ShaderGraph/Saturation-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Saturation_float(float3 In, float Saturation, out float3 Out) { float luma = dot(In, float3(0.2126729, 0.7151522, 0.0721750)); Out = luma.xxx + Saturation.xxx * (In - luma.xxx); }","title":"Generated Code Example"},{"location":"ShaderGraph/Sawtooth-Wave-Node/","text":"Sawtooth Wave Node Description Returns a sawtooth wave from the value of input In . Ports Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_SawtoothWave_float4(float4 In, out float4 Out) { Out = 2 * (In - floor(0.5 + In)); }","title":"Sawtooth Wave Node"},{"location":"ShaderGraph/Sawtooth-Wave-Node/#sawtooth-wave-node","text":"","title":"Sawtooth Wave Node"},{"location":"ShaderGraph/Sawtooth-Wave-Node/#description","text":"Returns a sawtooth wave from the value of input In .","title":"Description"},{"location":"ShaderGraph/Sawtooth-Wave-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Sawtooth-Wave-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_SawtoothWave_float4(float4 In, out float4 Out) { Out = 2 * (In - floor(0.5 + In)); }","title":"Generated Code Example"},{"location":"ShaderGraph/Scene-Color-Node/","text":"Scene Color Node Description Provides access to the current Camera 's color buffer using input UV , which is expected to be normalized screen coordinates. Note: The behaviour of this Node is undefined globally. The executed HLSL code for this Node is defined per Render Pipeline , and different Render Pipelines may produce different results. Custom Render Pipelines that wish to support this Node will also need to explicitly define the behaviour for it. If undefined this Node will return 0 (black). Note: In Lightweight Render Pipeline this Node returns the value of the Camera Opaque Texture . See the Lightweight Render Pipeline for more documentation on this feature. The contents of this texture are only available for Transparent objects. Set the Surface Type dropdown on the Material Options panel of the Master Node to Transparent to receive the correct values from this node. NOTE: This Node can only be used in the Fragment Shader Stage . Unity Pipelines Supported Lightweight Render Pipeline Ports Name Direction Type Binding Description UV Input Vector 4 Screen Position Normalized screen coordinates Out Output Vector 3 None Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_SceneColor_float(float4 UV, out float3 Out) { Out = SHADERGRAPH_SAMPLE_SCENE_COLOR(UV); }","title":"Scene Color Node"},{"location":"ShaderGraph/Scene-Color-Node/#scene-color-node","text":"","title":"Scene Color Node"},{"location":"ShaderGraph/Scene-Color-Node/#description","text":"Provides access to the current Camera 's color buffer using input UV , which is expected to be normalized screen coordinates. Note: The behaviour of this Node is undefined globally. The executed HLSL code for this Node is defined per Render Pipeline , and different Render Pipelines may produce different results. Custom Render Pipelines that wish to support this Node will also need to explicitly define the behaviour for it. If undefined this Node will return 0 (black). Note: In Lightweight Render Pipeline this Node returns the value of the Camera Opaque Texture . See the Lightweight Render Pipeline for more documentation on this feature. The contents of this texture are only available for Transparent objects. Set the Surface Type dropdown on the Material Options panel of the Master Node to Transparent to receive the correct values from this node. NOTE: This Node can only be used in the Fragment Shader Stage .","title":"Description"},{"location":"ShaderGraph/Scene-Color-Node/#unity-pipelines-supported","text":"Lightweight Render Pipeline","title":"Unity Pipelines Supported"},{"location":"ShaderGraph/Scene-Color-Node/#ports","text":"Name Direction Type Binding Description UV Input Vector 4 Screen Position Normalized screen coordinates Out Output Vector 3 None Output value","title":"Ports"},{"location":"ShaderGraph/Scene-Color-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_SceneColor_float(float4 UV, out float3 Out) { Out = SHADERGRAPH_SAMPLE_SCENE_COLOR(UV); }","title":"Generated Code Example"},{"location":"ShaderGraph/Scene-Depth-Node/","text":"Scene Depth Node Description Provides access to the current Camera 's depth buffer using input UV , which is expected to be normalized screen coordinates. Note: Depth buffer access requires depth buffer to be enabled on the active Render Pipeline . This process is different per Render Pipeline . It is recommended you read the documentation of your active Render Pipeline for information on enabling the depth buffer. If the depth buffer is unavailable this Node will return mid grey. Note: The executed HLSL code for this Node is defined per Render Pipeline , and different Render Pipelines may produce different results. Custom Render Pipelines that wish to support this Node will also need to explicitly define the behaviour for it. If undefined this Node will return 1 (white). NOTE: This Node can only be used in the Fragment Shader Stage . Unity Pipelines Supported HD Render Pipeline Lightweight Render Pipeline Ports Name Direction Type Binding Description UV Input Vector 4 Screen Position Normalized screen coordinates Out Output Vector 1 None Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_SceneDepth_float(float4 UV, out float Out) { Out = SHADERGRAPH_SAMPLE_SCENE_DEPTH(UV); }","title":"Scene Depth Node"},{"location":"ShaderGraph/Scene-Depth-Node/#scene-depth-node","text":"","title":"Scene Depth Node"},{"location":"ShaderGraph/Scene-Depth-Node/#description","text":"Provides access to the current Camera 's depth buffer using input UV , which is expected to be normalized screen coordinates. Note: Depth buffer access requires depth buffer to be enabled on the active Render Pipeline . This process is different per Render Pipeline . It is recommended you read the documentation of your active Render Pipeline for information on enabling the depth buffer. If the depth buffer is unavailable this Node will return mid grey. Note: The executed HLSL code for this Node is defined per Render Pipeline , and different Render Pipelines may produce different results. Custom Render Pipelines that wish to support this Node will also need to explicitly define the behaviour for it. If undefined this Node will return 1 (white). NOTE: This Node can only be used in the Fragment Shader Stage .","title":"Description"},{"location":"ShaderGraph/Scene-Depth-Node/#unity-pipelines-supported","text":"HD Render Pipeline Lightweight Render Pipeline","title":"Unity Pipelines Supported"},{"location":"ShaderGraph/Scene-Depth-Node/#ports","text":"Name Direction Type Binding Description UV Input Vector 4 Screen Position Normalized screen coordinates Out Output Vector 1 None Output value","title":"Ports"},{"location":"ShaderGraph/Scene-Depth-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_SceneDepth_float(float4 UV, out float Out) { Out = SHADERGRAPH_SAMPLE_SCENE_DEPTH(UV); }","title":"Generated Code Example"},{"location":"ShaderGraph/Screen-Node/","text":"Screen Node Description Provides access to parameters of the screen. Ports Name Direction Type Binding Description Width Output Vector 1 None Screen's width in pixels Height Output Vector 1 None Screen's height in pixels Generated Code Example The following example code represents one possible outcome of this node. float _Screen_Width = _ScreenParams.x; float _Screen_Height = _ScreenParams.y;","title":"Screen Node"},{"location":"ShaderGraph/Screen-Node/#screen-node","text":"","title":"Screen Node"},{"location":"ShaderGraph/Screen-Node/#description","text":"Provides access to parameters of the screen.","title":"Description"},{"location":"ShaderGraph/Screen-Node/#ports","text":"Name Direction Type Binding Description Width Output Vector 1 None Screen's width in pixels Height Output Vector 1 None Screen's height in pixels","title":"Ports"},{"location":"ShaderGraph/Screen-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. float _Screen_Width = _ScreenParams.x; float _Screen_Height = _ScreenParams.y;","title":"Generated Code Example"},{"location":"ShaderGraph/Screen-Position-Node/","text":"Screen Position Node Description Provides access to the mesh vertex or fragment's Screen Position . The mode of output value can be selected with the Mode dropdown parameter. Default Returns Screen Position . This mode divides Screen Position by the clip space position W component. Raw Returns Screen Position . This mode does not divide Screen Position by the clip space position W component. This is useful for projection. Center Returns Screen Position offset so position float2(0,0) is at the center of the screen. Tiled Returns Screen Position offset so position float2(0,0) is at the center of the screen and tiled using frac . Ports Name Direction Type Binding Description Out Output Vector 4 None Mesh's Screen Position . Controls Name Type Options Description Mode Dropdown Default, Raw, Center, Tiled Selects coordinate space of Position to output.","title":"Screen Position Node"},{"location":"ShaderGraph/Screen-Position-Node/#screen-position-node","text":"","title":"Screen Position Node"},{"location":"ShaderGraph/Screen-Position-Node/#description","text":"Provides access to the mesh vertex or fragment's Screen Position . The mode of output value can be selected with the Mode dropdown parameter. Default Returns Screen Position . This mode divides Screen Position by the clip space position W component. Raw Returns Screen Position . This mode does not divide Screen Position by the clip space position W component. This is useful for projection. Center Returns Screen Position offset so position float2(0,0) is at the center of the screen. Tiled Returns Screen Position offset so position float2(0,0) is at the center of the screen and tiled using frac .","title":"Description"},{"location":"ShaderGraph/Screen-Position-Node/#ports","text":"Name Direction Type Binding Description Out Output Vector 4 None Mesh's Screen Position .","title":"Ports"},{"location":"ShaderGraph/Screen-Position-Node/#controls","text":"Name Type Options Description Mode Dropdown Default, Raw, Center, Tiled Selects coordinate space of Position to output.","title":"Controls"},{"location":"ShaderGraph/Scripting-API/","text":"Scripting API Description This section of the documentation contains details of the scripting API that Shader Graph provides. To use this information, you should be familiar with the basic theory and practice of scripting in Unity which is explained in the Scripting section of our manual. The scripting reference is organised according to the classes available to scripts which are described along with their methods, properties and any other information relevant to their use. Contents CodeFunctionNode Port Types SlotAttribute Binding GetFunctionToConvert","title":"Scripting API"},{"location":"ShaderGraph/Scripting-API/#scripting-api","text":"","title":"Scripting API"},{"location":"ShaderGraph/Scripting-API/#description","text":"This section of the documentation contains details of the scripting API that Shader Graph provides. To use this information, you should be familiar with the basic theory and practice of scripting in Unity which is explained in the Scripting section of our manual. The scripting reference is organised according to the classes available to scripts which are described along with their methods, properties and any other information relevant to their use.","title":"Description"},{"location":"ShaderGraph/Scripting-API/#contents","text":"CodeFunctionNode Port Types SlotAttribute Binding GetFunctionToConvert","title":"Contents"},{"location":"ShaderGraph/Shader-Graph-Asset/","text":"Shader Graph Asset Description The Shader Graph Asset is the new Asset type introduced with the shader graph. You can create a Shader Graph Asset from the Project Window from the Create menu. For convenience there is a Create menu entry for PBR Graph , Unlit Graph and Sub-graph . They can be found in the Shader sub-menu. The two main graph options will create a Shader Graph Asset with the appropriate Master Node . You can open the Shader Graph Window by double clicking a Shader Graph Asset or by clicking Open Shader Editor in the Inspector when the Shader Graph Asset is selected.","title":"Shader Graph Asset"},{"location":"ShaderGraph/Shader-Graph-Asset/#shader-graph-asset","text":"","title":"Shader Graph Asset"},{"location":"ShaderGraph/Shader-Graph-Asset/#description","text":"The Shader Graph Asset is the new Asset type introduced with the shader graph. You can create a Shader Graph Asset from the Project Window from the Create menu. For convenience there is a Create menu entry for PBR Graph , Unlit Graph and Sub-graph . They can be found in the Shader sub-menu. The two main graph options will create a Shader Graph Asset with the appropriate Master Node . You can open the Shader Graph Window by double clicking a Shader Graph Asset or by clicking Open Shader Editor in the Inspector when the Shader Graph Asset is selected.","title":"Description"},{"location":"ShaderGraph/Shader-Graph-Window/","text":"Shader Graoh Window Description The Shader Graph Window contains the workspace for creating shaders using the Shader Graph system. To open the Shader Graph Window you must first create a Shader Graph Asset . For more information see the Getting Started section. The Shader Graph window contains various individual elements such as the Blackboard and Master Preview . These elements can be moved inside the workspace. They will automatically anchor to the nearest corner when scaling the Shader Graph Window . Title Bar The title bar at the top of the Shader Graph Window contains actions that can be performed on the Graph . Item Description Save Asset Saves the graph to update the Shader Graph Asset Show In Project Hightlights the Shader Graph Asset in the Project Window Workspace The workspace is where you create Node networks. You can navigate the workspace by holding Alt and left mouse button to pan and zoom with the scroll wheel. You can hold left mouse button and drag to select multiple Nodes with a marquee. There are also various shortcut keys to use for better workflow. Hotkey Windows OSX Description Cut Ctrl + X Command + X Cuts selected Nodes to the clipboard Copy Ctrl + C Command + C Copies selected Nodes to the clipboard Paste Ctrl + V Command + V Pastes Nodes in the clipboard Focus F F Focus the workspace on all or selected Nodes Create Node Spacebar Spacebar Opens the Create Node Menu Context Menu Right clicking within the workspace will open a context menu. Note that right clicking on an item within the workspace, such as a Node , will open the context menu for that item and not the workspace. Item Description Create Node Opens the Create Node Menu Cut Cuts selected Nodes to the clipboard Copy Copies selected Nodes to the clipboard Paste Pastes Nodes in the clipboard Delete Deletes selected Nodes Duplicate Duplicates selected Nodes Collapse Previews Collapses previews on all Nodes Expand Previews Expands previews on all Nodes","title":"Shader Graoh Window"},{"location":"ShaderGraph/Shader-Graph-Window/#shader-graoh-window","text":"","title":"Shader Graoh Window"},{"location":"ShaderGraph/Shader-Graph-Window/#description","text":"The Shader Graph Window contains the workspace for creating shaders using the Shader Graph system. To open the Shader Graph Window you must first create a Shader Graph Asset . For more information see the Getting Started section. The Shader Graph window contains various individual elements such as the Blackboard and Master Preview . These elements can be moved inside the workspace. They will automatically anchor to the nearest corner when scaling the Shader Graph Window .","title":"Description"},{"location":"ShaderGraph/Shader-Graph-Window/#title-bar","text":"The title bar at the top of the Shader Graph Window contains actions that can be performed on the Graph . Item Description Save Asset Saves the graph to update the Shader Graph Asset Show In Project Hightlights the Shader Graph Asset in the Project Window","title":"Title Bar"},{"location":"ShaderGraph/Shader-Graph-Window/#workspace","text":"The workspace is where you create Node networks. You can navigate the workspace by holding Alt and left mouse button to pan and zoom with the scroll wheel. You can hold left mouse button and drag to select multiple Nodes with a marquee. There are also various shortcut keys to use for better workflow. Hotkey Windows OSX Description Cut Ctrl + X Command + X Cuts selected Nodes to the clipboard Copy Ctrl + C Command + C Copies selected Nodes to the clipboard Paste Ctrl + V Command + V Pastes Nodes in the clipboard Focus F F Focus the workspace on all or selected Nodes Create Node Spacebar Spacebar Opens the Create Node Menu","title":"Workspace"},{"location":"ShaderGraph/Shader-Graph-Window/#context-menu","text":"Right clicking within the workspace will open a context menu. Note that right clicking on an item within the workspace, such as a Node , will open the context menu for that item and not the workspace. Item Description Create Node Opens the Create Node Menu Cut Cuts selected Nodes to the clipboard Copy Copies selected Nodes to the clipboard Paste Pastes Nodes in the clipboard Delete Deletes selected Nodes Duplicate Duplicates selected Nodes Collapse Previews Collapses previews on all Nodes Expand Previews Expands previews on all Nodes","title":"Context Menu"},{"location":"ShaderGraph/Shader-Graph/","text":"Shader Graph Description This section outlines the user interface and interactions of the Shader Graph system. For an introduction to Shader Graph see Getting Started . Contents Shader Graph Window Blackboard Master Preview Create Node Menu Shader Graph Asset","title":"Shader Graph"},{"location":"ShaderGraph/Shader-Graph/#shader-graph","text":"","title":"Shader Graph"},{"location":"ShaderGraph/Shader-Graph/#description","text":"This section outlines the user interface and interactions of the Shader Graph system. For an introduction to Shader Graph see Getting Started .","title":"Description"},{"location":"ShaderGraph/Shader-Graph/#contents","text":"Shader Graph Window Blackboard Master Preview Create Node Menu Shader Graph Asset","title":"Contents"},{"location":"ShaderGraph/Shader-Stage/","text":"Shader Stage Description Shader Stage refers to the part of the shader pipeline a Node or Port is part of. For example, Vertex or Fragment . In Shader Graph , Shader Stage is defined per Port but often all Ports on a Node are locked to the same Shader Stage . Ports on some Nodes are unavailable in certain Shader Stages due to limitations in the underlying shader language. See the Node Library documentation for Nodes that have Shader Stage restrictions. Shader Stage List Name Description Vertex Operations calculated per vertex Fragment Operations calculated per fragment","title":"Shader Stage"},{"location":"ShaderGraph/Shader-Stage/#shader-stage","text":"","title":"Shader Stage"},{"location":"ShaderGraph/Shader-Stage/#description","text":"Shader Stage refers to the part of the shader pipeline a Node or Port is part of. For example, Vertex or Fragment . In Shader Graph , Shader Stage is defined per Port but often all Ports on a Node are locked to the same Shader Stage . Ports on some Nodes are unavailable in certain Shader Stages due to limitations in the underlying shader language. See the Node Library documentation for Nodes that have Shader Stage restrictions.","title":"Description"},{"location":"ShaderGraph/Shader-Stage/#shader-stage-list","text":"Name Description Vertex Operations calculated per vertex Fragment Operations calculated per fragment","title":"Shader Stage List"},{"location":"ShaderGraph/Sign-Node/","text":"Sign Node Description Per component, returns -1 if the value of input In is less than zero, 0 if equal to zero and 1 if greater than zero. Ports Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Sign_float4(float4 In, out float4 Out) { Out = sign(In); }","title":"Sign Node"},{"location":"ShaderGraph/Sign-Node/#sign-node","text":"","title":"Sign Node"},{"location":"ShaderGraph/Sign-Node/#description","text":"Per component, returns -1 if the value of input In is less than zero, 0 if equal to zero and 1 if greater than zero.","title":"Description"},{"location":"ShaderGraph/Sign-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Sign-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Sign_float4(float4 In, out float4 Out) { Out = sign(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Simple-Noise-Node/","text":"Simple Noise Node Description Generates a simple, or Value , noise based on input UV . The scale of the generated noise is controlled by input Scale . Ports Name Direction Type Binding Description UV Input Vector 2 UV Input UV value Scale Input Vector 1 None Noise scale Out Output Vector 1 None Output value Generated Code Example The following example code represents one possible outcome of this node. inline float unity_noise_randomValue (float2 uv) { return frac(sin(dot(uv, float2(12.9898, 78.233)))*43758.5453); } inline float unity_noise_interpolate (float a, float b, float t) { return (1.0-t)*a + (t*b); } inline float unity_valueNoise (float2 uv) { float2 i = floor(uv); float2 f = frac(uv); f = f * f * (3.0 - 2.0 * f); uv = abs(frac(uv) - 0.5); float2 c0 = i + float2(0.0, 0.0); float2 c1 = i + float2(1.0, 0.0); float2 c2 = i + float2(0.0, 1.0); float2 c3 = i + float2(1.0, 1.0); float r0 = unity_noise_randomValue(c0); float r1 = unity_noise_randomValue(c1); float r2 = unity_noise_randomValue(c2); float r3 = unity_noise_randomValue(c3); float bottomOfGrid = unity_noise_interpolate(r0, r1, f.x); float topOfGrid = unity_noise_interpolate(r2, r3, f.x); float t = unity_noise_interpolate(bottomOfGrid, topOfGrid, f.y); return t; } void Unity_SimpleNoise_float(float2 UV, float Scale, out float Out) { float t = 0.0; float freq = pow(2.0, float(0)); float amp = pow(0.5, float(3-0)); t += unity_valueNoise(float2(UV.x*Scale/freq, UV.y*Scale/freq))*amp; freq = pow(2.0, float(1)); amp = pow(0.5, float(3-1)); t += unity_valueNoise(float2(UV.x*Scale/freq, UV.y*Scale/freq))*amp; freq = pow(2.0, float(2)); amp = pow(0.5, float(3-2)); t += unity_valueNoise(float2(UV.x*Scale/freq, UV.y*Scale/freq))*amp; Out = t; }","title":"Simple Noise Node"},{"location":"ShaderGraph/Simple-Noise-Node/#simple-noise-node","text":"","title":"Simple Noise Node"},{"location":"ShaderGraph/Simple-Noise-Node/#description","text":"Generates a simple, or Value , noise based on input UV . The scale of the generated noise is controlled by input Scale .","title":"Description"},{"location":"ShaderGraph/Simple-Noise-Node/#ports","text":"Name Direction Type Binding Description UV Input Vector 2 UV Input UV value Scale Input Vector 1 None Noise scale Out Output Vector 1 None Output value","title":"Ports"},{"location":"ShaderGraph/Simple-Noise-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. inline float unity_noise_randomValue (float2 uv) { return frac(sin(dot(uv, float2(12.9898, 78.233)))*43758.5453); } inline float unity_noise_interpolate (float a, float b, float t) { return (1.0-t)*a + (t*b); } inline float unity_valueNoise (float2 uv) { float2 i = floor(uv); float2 f = frac(uv); f = f * f * (3.0 - 2.0 * f); uv = abs(frac(uv) - 0.5); float2 c0 = i + float2(0.0, 0.0); float2 c1 = i + float2(1.0, 0.0); float2 c2 = i + float2(0.0, 1.0); float2 c3 = i + float2(1.0, 1.0); float r0 = unity_noise_randomValue(c0); float r1 = unity_noise_randomValue(c1); float r2 = unity_noise_randomValue(c2); float r3 = unity_noise_randomValue(c3); float bottomOfGrid = unity_noise_interpolate(r0, r1, f.x); float topOfGrid = unity_noise_interpolate(r2, r3, f.x); float t = unity_noise_interpolate(bottomOfGrid, topOfGrid, f.y); return t; } void Unity_SimpleNoise_float(float2 UV, float Scale, out float Out) { float t = 0.0; float freq = pow(2.0, float(0)); float amp = pow(0.5, float(3-0)); t += unity_valueNoise(float2(UV.x*Scale/freq, UV.y*Scale/freq))*amp; freq = pow(2.0, float(1)); amp = pow(0.5, float(3-1)); t += unity_valueNoise(float2(UV.x*Scale/freq, UV.y*Scale/freq))*amp; freq = pow(2.0, float(2)); amp = pow(0.5, float(3-2)); t += unity_valueNoise(float2(UV.x*Scale/freq, UV.y*Scale/freq))*amp; Out = t; }","title":"Generated Code Example"},{"location":"ShaderGraph/Sine-Node/","text":"Sine Node Description Returns the sine of the value of input In . Ports Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Sine_float4(float4 In, out float4 Out) { Out = sin(In); }","title":"Sine Node"},{"location":"ShaderGraph/Sine-Node/#sine-node","text":"","title":"Sine Node"},{"location":"ShaderGraph/Sine-Node/#description","text":"Returns the sine of the value of input In .","title":"Description"},{"location":"ShaderGraph/Sine-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Sine-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Sine_float4(float4 In, out float4 Out) { Out = sin(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Slider-Node/","text":"Slider Node Description Defines a constant Vector 1 value in the shader using a Slider field. Can be converted to a Vector 1 type Property with a Mode setting of Slider via the Node's context menu. Ports Name Direction Type Binding Description Out Output Vector 1 None Output value Controls Name Type Options Description Slider Defines the output value. Min Vector 1 Defines the slider parameter's minimum value. Max Vector 1 Defines the slider parameter's maximum value. Generated Code Example The following example code represents one possible outcome of this node. float _Slider_Out = 1.0;","title":"Slider Node"},{"location":"ShaderGraph/Slider-Node/#slider-node","text":"","title":"Slider Node"},{"location":"ShaderGraph/Slider-Node/#description","text":"Defines a constant Vector 1 value in the shader using a Slider field. Can be converted to a Vector 1 type Property with a Mode setting of Slider via the Node's context menu.","title":"Description"},{"location":"ShaderGraph/Slider-Node/#ports","text":"Name Direction Type Binding Description Out Output Vector 1 None Output value","title":"Ports"},{"location":"ShaderGraph/Slider-Node/#controls","text":"Name Type Options Description Slider Defines the output value. Min Vector 1 Defines the slider parameter's minimum value. Max Vector 1 Defines the slider parameter's maximum value.","title":"Controls"},{"location":"ShaderGraph/Slider-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. float _Slider_Out = 1.0;","title":"Generated Code Example"},{"location":"ShaderGraph/Smoothstep-Node/","text":"Smoothstep Node Description Returns the result of a smooth Hermite interpolation between 0 and 1, if the value of input In is between the values of inputs Edge1 and Edge2 respectively. Returns 0 if the value of input In is less than the value of input Step1 and 1 if greater than the value of input Step2 . This node is similar to the Lerp Node but there are two notable differences. Firstly, with this node the user specifies the range and the return value is between 0 and 1. This can be seen as the opposite of the Lerp Node . Secondly, this node uses smooth Hermite interpolation instead of linear interpolation. This means the interpolation will gradually speed up from the start and slow down toward the end. This is useful for creating natural-looking animation, fading and other transitions. Ports Name Direction Type Description Edge1 Input Dynamic Vector Minimum step value Edge2 Input Dynamic Vector Maximum step value In Input Dynamic Vector Input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Smoothstep_float4(float4 Edge1, float4 Edge2, float4 In, out float4 Out) { Out = smoothstep(Step1, Step2, In); }","title":"Smoothstep Node"},{"location":"ShaderGraph/Smoothstep-Node/#smoothstep-node","text":"","title":"Smoothstep Node"},{"location":"ShaderGraph/Smoothstep-Node/#description","text":"Returns the result of a smooth Hermite interpolation between 0 and 1, if the value of input In is between the values of inputs Edge1 and Edge2 respectively. Returns 0 if the value of input In is less than the value of input Step1 and 1 if greater than the value of input Step2 . This node is similar to the Lerp Node but there are two notable differences. Firstly, with this node the user specifies the range and the return value is between 0 and 1. This can be seen as the opposite of the Lerp Node . Secondly, this node uses smooth Hermite interpolation instead of linear interpolation. This means the interpolation will gradually speed up from the start and slow down toward the end. This is useful for creating natural-looking animation, fading and other transitions.","title":"Description"},{"location":"ShaderGraph/Smoothstep-Node/#ports","text":"Name Direction Type Description Edge1 Input Dynamic Vector Minimum step value Edge2 Input Dynamic Vector Maximum step value In Input Dynamic Vector Input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Smoothstep-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Smoothstep_float4(float4 Edge1, float4 Edge2, float4 In, out float4 Out) { Out = smoothstep(Step1, Step2, In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Sphere-Mask-Node/","text":"Sphere Mask Node Description Creates a sphere mask originating from input Center . The sphere is calculated using Distance and modified using the Radius and Hardness inputs. Sphere mask functionality works in both 2D and 3D spaces, and is based on the vector coordinates in the Coords input. Ports Name Direction Type Binding Description Coords Input Dynamic Vector None Coordinate space input Center Input Dynamic Vector None Coordinates of the sphere origin Radius Input Vector 1 None Radius of the sphere Hardness Input Vector 1 None Soften falloff of the sphere Out Output Dynamic Vector None Output mask value Generated Code Example The following example code represents one possible outcome of this node. void Unity_SphereMask_float4(float4 Coords, float4 Center, float Radius, float Hardness, out float4 Out) { Out = 1 - saturate((distance(Coords, Center) - Radius) / (1 - Hardness)); }","title":"Sphere Mask Node"},{"location":"ShaderGraph/Sphere-Mask-Node/#sphere-mask-node","text":"","title":"Sphere Mask Node"},{"location":"ShaderGraph/Sphere-Mask-Node/#description","text":"Creates a sphere mask originating from input Center . The sphere is calculated using Distance and modified using the Radius and Hardness inputs. Sphere mask functionality works in both 2D and 3D spaces, and is based on the vector coordinates in the Coords input.","title":"Description"},{"location":"ShaderGraph/Sphere-Mask-Node/#ports","text":"Name Direction Type Binding Description Coords Input Dynamic Vector None Coordinate space input Center Input Dynamic Vector None Coordinates of the sphere origin Radius Input Vector 1 None Radius of the sphere Hardness Input Vector 1 None Soften falloff of the sphere Out Output Dynamic Vector None Output mask value","title":"Ports"},{"location":"ShaderGraph/Sphere-Mask-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_SphereMask_float4(float4 Coords, float4 Center, float Radius, float Hardness, out float4 Out) { Out = 1 - saturate((distance(Coords, Center) - Radius) / (1 - Hardness)); }","title":"Generated Code Example"},{"location":"ShaderGraph/Spherize-Node/","text":"Spherize Node Description Applies a spherical warping effect similar to a fisheye camera lens to the value of input UV . The center reference point of the warping effect is defined by input Center and the overall strength of the effect is defined by the value of input Strength . Input Offset can be used to offset the individual channels of the result. Ports Name Direction Type Binding Description UV Input Vector 2 UV Input UV value Center Input Vector 2 None Center reference point Strength Input Vector 1 None Strength of the effect Offset Input Vector 2 None Individual channel offsets Out Output Vector 2 None Output UV value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Spherize_float(float2 UV, float2 Center, float Strength, float2 Offset, out float2 Out) { float2 delta = UV - Center; float delta2 = dot(delta.xy, delta.xy); float delta4 = delta2 * delta2; float2 delta_offset = delta4 * Strength; Out = UV + delta * delta_offset + Offset; }","title":"Spherize Node"},{"location":"ShaderGraph/Spherize-Node/#spherize-node","text":"","title":"Spherize Node"},{"location":"ShaderGraph/Spherize-Node/#description","text":"Applies a spherical warping effect similar to a fisheye camera lens to the value of input UV . The center reference point of the warping effect is defined by input Center and the overall strength of the effect is defined by the value of input Strength . Input Offset can be used to offset the individual channels of the result.","title":"Description"},{"location":"ShaderGraph/Spherize-Node/#ports","text":"Name Direction Type Binding Description UV Input Vector 2 UV Input UV value Center Input Vector 2 None Center reference point Strength Input Vector 1 None Strength of the effect Offset Input Vector 2 None Individual channel offsets Out Output Vector 2 None Output UV value","title":"Ports"},{"location":"ShaderGraph/Spherize-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Spherize_float(float2 UV, float2 Center, float Strength, float2 Offset, out float2 Out) { float2 delta = UV - Center; float delta2 = dot(delta.xy, delta.xy); float delta4 = delta2 * delta2; float2 delta_offset = delta4 * Strength; Out = UV + delta * delta_offset + Offset; }","title":"Generated Code Example"},{"location":"ShaderGraph/Split-Node/","text":"Split Node Description Splits the input vector In into four Vector 1 outputs R , G , B and A . These output vectors are defined by the individual channels of the input In ; red, green, blue and alpha respectively. If the input vector In 's dimension is less than 4 ( Vector 4 ) the output values not present in the input will be 0. Ports Name Direction Type Binding Description In Input Dynamic Vector None Input value R Output Vector 1 None Red channel from input G Output Vector 1 None Green channel from input B Output Vector 1 None Blue channel from input A Output Vector 1 None Alpha channel from input Generated Code Example The following example code represents one possible outcome of this node. float _Split_R = In[0]; float _Split_G = In[1]; float _Split_B = 0; float _Split_A = 0;","title":"Split Node"},{"location":"ShaderGraph/Split-Node/#split-node","text":"","title":"Split Node"},{"location":"ShaderGraph/Split-Node/#description","text":"Splits the input vector In into four Vector 1 outputs R , G , B and A . These output vectors are defined by the individual channels of the input In ; red, green, blue and alpha respectively. If the input vector In 's dimension is less than 4 ( Vector 4 ) the output values not present in the input will be 0.","title":"Description"},{"location":"ShaderGraph/Split-Node/#ports","text":"Name Direction Type Binding Description In Input Dynamic Vector None Input value R Output Vector 1 None Red channel from input G Output Vector 1 None Green channel from input B Output Vector 1 None Blue channel from input A Output Vector 1 None Alpha channel from input","title":"Ports"},{"location":"ShaderGraph/Split-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. float _Split_R = In[0]; float _Split_G = In[1]; float _Split_B = 0; float _Split_A = 0;","title":"Generated Code Example"},{"location":"ShaderGraph/Square-Root-Node/","text":"Square Root Node Description Returns the square root of input In . Ports Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_SquareRoot_float4(float4 In, out float4 Out) { Out = sqrt(In); }","title":"Square Root Node"},{"location":"ShaderGraph/Square-Root-Node/#square-root-node","text":"","title":"Square Root Node"},{"location":"ShaderGraph/Square-Root-Node/#description","text":"Returns the square root of input In .","title":"Description"},{"location":"ShaderGraph/Square-Root-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Square-Root-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_SquareRoot_float4(float4 In, out float4 Out) { Out = sqrt(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Square-Wave-Node/","text":"Square Wave Node Description Returns a square wave from the value of input In . Ports Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_SquareWave_float4(float4 In, out float4 Out) { Out = 1.0 - 2.0 * round(frac(In)); }","title":"Square Wave Node"},{"location":"ShaderGraph/Square-Wave-Node/#square-wave-node","text":"","title":"Square Wave Node"},{"location":"ShaderGraph/Square-Wave-Node/#description","text":"Returns a square wave from the value of input In .","title":"Description"},{"location":"ShaderGraph/Square-Wave-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Square-Wave-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_SquareWave_float4(float4 In, out float4 Out) { Out = 1.0 - 2.0 * round(frac(In)); }","title":"Generated Code Example"},{"location":"ShaderGraph/Step-Node/","text":"Step Node Description Per component, returns 1 if the value of input In is greater than or equal to the value of input Edge , otherwise returns 0. Ports Name Direction Type Description Edge Input Dynamic Vector Step value In Input Dynamic Vector Input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Step_float4(float4 Edge, float4 In, out float4 Out) { Out = step(Edge, In); }","title":"Step Node"},{"location":"ShaderGraph/Step-Node/#step-node","text":"","title":"Step Node"},{"location":"ShaderGraph/Step-Node/#description","text":"Per component, returns 1 if the value of input In is greater than or equal to the value of input Edge , otherwise returns 0.","title":"Description"},{"location":"ShaderGraph/Step-Node/#ports","text":"Name Direction Type Description Edge Input Dynamic Vector Step value In Input Dynamic Vector Input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Step-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Step_float4(float4 Edge, float4 In, out float4 Out) { Out = step(Edge, In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Sub-graph-Asset/","text":"Sub-graph Asset Description The Sub-graph Asset is a new Asset type introduced with the Shader Graph . A Sub-graph Asset defines a Sub-graph . This is different to a Shader Graph . You can create a Sub-graph Asset from the Project Window from the Create menu via Sub Graph in the Shader sub-menu. You can open the Shader Graph Window by double clicking a Sub-graph Asset or by clicking Open Shader Editor in the Inspector when the Sub-graph Asset is selected.","title":"Sub-graph Asset"},{"location":"ShaderGraph/Sub-graph-Asset/#sub-graph-asset","text":"","title":"Sub-graph Asset"},{"location":"ShaderGraph/Sub-graph-Asset/#description","text":"The Sub-graph Asset is a new Asset type introduced with the Shader Graph . A Sub-graph Asset defines a Sub-graph . This is different to a Shader Graph . You can create a Sub-graph Asset from the Project Window from the Create menu via Sub Graph in the Shader sub-menu. You can open the Shader Graph Window by double clicking a Sub-graph Asset or by clicking Open Shader Editor in the Inspector when the Sub-graph Asset is selected.","title":"Description"},{"location":"ShaderGraph/Sub-graph-Node/","text":"Sub-graph Node Description Provides a reference to a Sub-graph Asset . All ports on the reference node are defined by the properties and outputs defined in the Sub-graph Asset . This is useful for sharing functionality between graphs or duplicating the same functionality within a graph. Sub-graph Nodes and Shader Stages If a Node within a Sub-graph specifies a Shader Stage , such as how Sample Texture 2D Node specifies the fragment Shader Stage , then that entire Sub-graph is now locked to that stage. As such a Sub-graph Node that references the graph will also be locked to that Shader Stage . Furthermore, when an Edge connected to an output Port on a Sub-graph Node flows into a Port on a Master Node that Sub-graph Node is now locked to the Shader Stage of that Master Node Port .","title":"Sub-graph Node"},{"location":"ShaderGraph/Sub-graph-Node/#sub-graph-node","text":"","title":"Sub-graph Node"},{"location":"ShaderGraph/Sub-graph-Node/#description","text":"Provides a reference to a Sub-graph Asset . All ports on the reference node are defined by the properties and outputs defined in the Sub-graph Asset . This is useful for sharing functionality between graphs or duplicating the same functionality within a graph.","title":"Description"},{"location":"ShaderGraph/Sub-graph-Node/#sub-graph-nodes-and-shader-stages","text":"If a Node within a Sub-graph specifies a Shader Stage , such as how Sample Texture 2D Node specifies the fragment Shader Stage , then that entire Sub-graph is now locked to that stage. As such a Sub-graph Node that references the graph will also be locked to that Shader Stage . Furthermore, when an Edge connected to an output Port on a Sub-graph Node flows into a Port on a Master Node that Sub-graph Node is now locked to the Shader Stage of that Master Node Port .","title":"Sub-graph Nodes and Shader Stages"},{"location":"ShaderGraph/Sub-graph/","text":"Sub-graph Description A Sub-graph is a special type of Shader Graph . It is used to create graphs that can be referenced inside other graphs. This is useful when you wish to perform the same operations multiple times in one graph or across multiple graphs. A Sub-graph differs from a Shader Graph in 3 main ways: - Properties in the Blackboard of a Sub-graph define the input Ports of a Sub-graph Node when the Sub-graph is referenced in another graph. - A Sub-graph has its own asset type. For more information, including how to make a new Sub-graph , see Sub-graph Asset . - A Sub-graph does not have a Master Node . Instead it has a Node called SubGraphOutputs . For more information see below. For components of a Sub-graph see: * Sub-graph Asset SubGraphOutputs The SubGraphOutputs Node defines the output Ports of a Sub-graph Node when the Sub-graph is referenced in another graph. You can add and remove Ports using the Add Slot and Remove Slot buttons. Sub-graphs and Shader Stages If a Node within a Sub-graph specifies a shader stage, such as how Sample Texture 2D Node specifies the fragment shader stage, then that entire Sub-graph is now locked to that stage. No Nodes that specify a different shader stage will be able to be connected to the Sub-graph Output Node and any Sub-graph Nodes that reference the graph will also be locked to that shader stage.","title":"Sub-graph"},{"location":"ShaderGraph/Sub-graph/#sub-graph","text":"","title":"Sub-graph"},{"location":"ShaderGraph/Sub-graph/#description","text":"A Sub-graph is a special type of Shader Graph . It is used to create graphs that can be referenced inside other graphs. This is useful when you wish to perform the same operations multiple times in one graph or across multiple graphs. A Sub-graph differs from a Shader Graph in 3 main ways: - Properties in the Blackboard of a Sub-graph define the input Ports of a Sub-graph Node when the Sub-graph is referenced in another graph. - A Sub-graph has its own asset type. For more information, including how to make a new Sub-graph , see Sub-graph Asset . - A Sub-graph does not have a Master Node . Instead it has a Node called SubGraphOutputs . For more information see below. For components of a Sub-graph see: * Sub-graph Asset","title":"Description"},{"location":"ShaderGraph/Sub-graph/#subgraphoutputs","text":"The SubGraphOutputs Node defines the output Ports of a Sub-graph Node when the Sub-graph is referenced in another graph. You can add and remove Ports using the Add Slot and Remove Slot buttons.","title":"SubGraphOutputs"},{"location":"ShaderGraph/Sub-graph/#sub-graphs-and-shader-stages","text":"If a Node within a Sub-graph specifies a shader stage, such as how Sample Texture 2D Node specifies the fragment shader stage, then that entire Sub-graph is now locked to that stage. No Nodes that specify a different shader stage will be able to be connected to the Sub-graph Output Node and any Sub-graph Nodes that reference the graph will also be locked to that shader stage.","title":"Sub-graphs and Shader Stages"},{"location":"ShaderGraph/Subtract-Node/","text":"Subtract Node Description Returns the result of input A minus input B . Ports Name Direction Type Description A Input Dynamic Vector First input value B Input Dynamic Vector Second input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Subtract_float4(float4 A, float4 B, out float4 Out) { Out = A - B; }","title":"Subtract Node"},{"location":"ShaderGraph/Subtract-Node/#subtract-node","text":"","title":"Subtract Node"},{"location":"ShaderGraph/Subtract-Node/#description","text":"Returns the result of input A minus input B .","title":"Description"},{"location":"ShaderGraph/Subtract-Node/#ports","text":"Name Direction Type Description A Input Dynamic Vector First input value B Input Dynamic Vector Second input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Subtract-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Subtract_float4(float4 A, float4 B, out float4 Out) { Out = A - B; }","title":"Generated Code Example"},{"location":"ShaderGraph/Swizzle-Node/","text":"Swizzle Node Description Creates a new vector of the same dimension as the input vector. The channels of the output vector are the same as the input vector but re-ordered by the dropdown parameters on the node. This is called swizzling. Channel dropdown parameters are dynamic depending on the length of the input vector's dimension. Dropdowns for channels that are not present will be disabled and dropdowns will only contain entries for channels that exist in the vector. Ports Name Direction Type Binding Description In Input Dynamic Vector None Input value Out Output Dynamic Vector None Output value Controls Name Type Options Description Red out Dropdown Red, Green, Blue, Alpha (depending on input vector dimension) Defines which input channel should be used in the output's red channel Green out Dropdown Red, Green, Blue, Alpha (depending on input vector dimension) Defines which input channel should be used in the output's green channel Blue out Dropdown Red, Green, Blue, Alpha (depending on input vector dimension) Defines which input channel should be used in the output's blue channel Alpha out Dropdown Red, Green, Blue, Alpha (depending on input vector dimension) Defines which input channel should be used in the output's alpha channel Generated Code Example The following example code represents one possible outcome of this node. float4 _Swizzle_Out = In.xzyw;","title":"Swizzle Node"},{"location":"ShaderGraph/Swizzle-Node/#swizzle-node","text":"","title":"Swizzle Node"},{"location":"ShaderGraph/Swizzle-Node/#description","text":"Creates a new vector of the same dimension as the input vector. The channels of the output vector are the same as the input vector but re-ordered by the dropdown parameters on the node. This is called swizzling. Channel dropdown parameters are dynamic depending on the length of the input vector's dimension. Dropdowns for channels that are not present will be disabled and dropdowns will only contain entries for channels that exist in the vector.","title":"Description"},{"location":"ShaderGraph/Swizzle-Node/#ports","text":"Name Direction Type Binding Description In Input Dynamic Vector None Input value Out Output Dynamic Vector None Output value","title":"Ports"},{"location":"ShaderGraph/Swizzle-Node/#controls","text":"Name Type Options Description Red out Dropdown Red, Green, Blue, Alpha (depending on input vector dimension) Defines which input channel should be used in the output's red channel Green out Dropdown Red, Green, Blue, Alpha (depending on input vector dimension) Defines which input channel should be used in the output's green channel Blue out Dropdown Red, Green, Blue, Alpha (depending on input vector dimension) Defines which input channel should be used in the output's blue channel Alpha out Dropdown Red, Green, Blue, Alpha (depending on input vector dimension) Defines which input channel should be used in the output's alpha channel","title":"Controls"},{"location":"ShaderGraph/Swizzle-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. float4 _Swizzle_Out = In.xzyw;","title":"Generated Code Example"},{"location":"ShaderGraph/TableOfContents/","text":"Unity Manual ToC ================` Getting Started Shader Graph Shader Graph Window Blackboard Master Preview Create Node Menu Shader Graph Asset Custom Nodes with CodeFunctionNode Sub-graph Sub-graph Asset Node Port Edge Master Node Data Property Types Data Types Port Bindings Node Library Artistic Channel Mixer Contrast Hue Invert Colors Replace Color Saturation White Balance Blend Dither Channel Mask Color Mask Normal Blend Normal From Height Normal From Texture Normal Reconstruct Z Normal Strength Normal Unpack Colorspace Conversion Channel Combine Flip Split Swizzle Input Boolean Color Constant Integer Slider Time Vector 1 Vector 2 Vector 3 Vector 4 Bitangent Vector Normal Vector Position Screen Position Tangent Vector UV Vertex Color View Direction Gradient Sample Gradient Matrix 2x2 Matrix 3x3 Matrix 4x4 Transformation Matrix Dielectric Specular Metal Reflectance Ambient Camera Fog Light Probe Object Reflection Probe Scene Color Scene Depth Screen Cubemap Asset Sample Cubemap Sample Texture 2D Sample Texture 2D Array Sample Texture 2D LOD Sample Texture 3D Sampler State Texel Size Texture 2D Array Asset Texture 2D Asset Texture 3D Asset Master PBR Unlit Math Add Divide Multiply Power Square Root Subtract Absolute Exponential Length Log Modulo Negate Normalize Posterize Reciprocal Reciprocal Square Root DDX DDXY DDY Inverse Lerp Lerp Smoothstep Matrix Construction Matrix Determinant Matrix Split Matrix Transpose Clamp Fraction Maximum Minimum One Minus Random Range Remap Saturate Ceiling Floor Round Sign Step Truncate Arccosine Arcsine Arctangent Arctangent2 Cosine Degrees To Radians Hyperbolic Cosine Hyperbolic Sine Hyperbolic Tangent Radians To Degrees Sine Tangent Cross Product Distance Dot Product Fresnel Effect Projection Reflection Rejection Rotate About Axis Sphere Mask Transform Noise Sine Wave Sawtooth Wave Square Wave Triangle Wave Procedural Checkerboard Gradient Noise Simple Noise Voronoi Ellipse Polygon Rectangle Rounded Rectangle Utility ` Preview Sub-graph All And Any Branch Comparison Is Front Face Is Infinite Is NaN Nand Not Or UV Flipbook Polar Coordinates Radial Shear Rotate Spherize Tiling And Offset Triplanar Twirl Scripting API CodeFunctionNode Port Types SlotAttribute Binding GetFunctionToConvert","title":"TableOfContents"},{"location":"ShaderGraph/Tangent-Node/","text":"Tangent Node Description Returns the tangent of the value of input In . Ports Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Tangent_float4(float4 In, out float4 Out) { Out = tan(In); }","title":"Tangent Node"},{"location":"ShaderGraph/Tangent-Node/#tangent-node","text":"","title":"Tangent Node"},{"location":"ShaderGraph/Tangent-Node/#description","text":"Returns the tangent of the value of input In .","title":"Description"},{"location":"ShaderGraph/Tangent-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Tangent-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Tangent_float4(float4 In, out float4 Out) { Out = tan(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Tangent-Vector-Node/","text":"Description Provides access to the mesh vertex or fragment's Tangent Vector . The coordinate space of the output value can be selected with the Space dropdown parameter. Ports Name Direction Type Binding Description Out Output Vector 3 None Mesh's Tangent Vector . Parameters Name Type Options Description Space Dropdown Object, View, World, Tangent Selects coordinate space of Tangent Vector to output.","title":"Tangent Vector Node"},{"location":"ShaderGraph/Tangent-Vector-Node/#description","text":"Provides access to the mesh vertex or fragment's Tangent Vector . The coordinate space of the output value can be selected with the Space dropdown parameter.","title":"Description"},{"location":"ShaderGraph/Tangent-Vector-Node/#ports","text":"Name Direction Type Binding Description Out Output Vector 3 None Mesh's Tangent Vector .","title":"Ports"},{"location":"ShaderGraph/Tangent-Vector-Node/#parameters","text":"Name Type Options Description Space Dropdown Object, View, World, Tangent Selects coordinate space of Tangent Vector to output.","title":"Parameters"},{"location":"ShaderGraph/Texel-Size-Node/","text":"Texel Size Node Description Returns the Width and Height of the texel size of Texture 2D input. Uses the built in variable {texturename}_TexelSize to access special properties of a Texture 2D . Note: Do not use the default input to reference your Texture 2D . It makes your graph perform worse. Instead connect this node to a separate Texture 2D Asset Node and re-use this definition for sampling. Ports Name Direction Type Binding Description Texture Input Texture None Texture asset Width Output Vector 1 None Texel width Height Output Vector 1 None Texel height Generated Code Example The following example code represents one possible outcome of this node. float _TexelSize_Width = Texture_TexelSize.z; float _TexelSize_Height = Texture_TexelSize.w;","title":"Texel Size Node"},{"location":"ShaderGraph/Texel-Size-Node/#texel-size-node","text":"","title":"Texel Size Node"},{"location":"ShaderGraph/Texel-Size-Node/#description","text":"Returns the Width and Height of the texel size of Texture 2D input. Uses the built in variable {texturename}_TexelSize to access special properties of a Texture 2D . Note: Do not use the default input to reference your Texture 2D . It makes your graph perform worse. Instead connect this node to a separate Texture 2D Asset Node and re-use this definition for sampling.","title":"Description"},{"location":"ShaderGraph/Texel-Size-Node/#ports","text":"Name Direction Type Binding Description Texture Input Texture None Texture asset Width Output Vector 1 None Texel width Height Output Vector 1 None Texel height","title":"Ports"},{"location":"ShaderGraph/Texel-Size-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. float _TexelSize_Width = Texture_TexelSize.z; float _TexelSize_Height = Texture_TexelSize.w;","title":"Generated Code Example"},{"location":"ShaderGraph/Texture-2D-Array-Asset-Node/","text":"Texture 2D Array Asset Node Description Defines a constant Texture 2D Array Asset for use in the shader. To sample the Texture 2D Array Asset it should be used in conjunction with a Sample Texture 2D Array Node . When using a separate Texture 2D Array Asset Node , you can sample a Texture 2D Array twice, with different parameters, without defining the Texture 2D Array itself twice. Ports Name Direction Type Description Out Output Texture 2D Array Output value Controls Name Type Options Description Object Field (Texture 2D Array) Defines the texture 2D array asset from the project. Generated Code Example The following example code represents one possible outcome of this node. TEXTURE2D_ARRAY(_Texture2DArrayAsset); SAMPLER(sampler_Texture2DArrayAsset);","title":"Texture 2D Array Asset Node"},{"location":"ShaderGraph/Texture-2D-Array-Asset-Node/#texture-2d-array-asset-node","text":"","title":"Texture 2D Array Asset Node"},{"location":"ShaderGraph/Texture-2D-Array-Asset-Node/#description","text":"Defines a constant Texture 2D Array Asset for use in the shader. To sample the Texture 2D Array Asset it should be used in conjunction with a Sample Texture 2D Array Node . When using a separate Texture 2D Array Asset Node , you can sample a Texture 2D Array twice, with different parameters, without defining the Texture 2D Array itself twice.","title":"Description"},{"location":"ShaderGraph/Texture-2D-Array-Asset-Node/#ports","text":"Name Direction Type Description Out Output Texture 2D Array Output value","title":"Ports"},{"location":"ShaderGraph/Texture-2D-Array-Asset-Node/#controls","text":"Name Type Options Description Object Field (Texture 2D Array) Defines the texture 2D array asset from the project.","title":"Controls"},{"location":"ShaderGraph/Texture-2D-Array-Asset-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. TEXTURE2D_ARRAY(_Texture2DArrayAsset); SAMPLER(sampler_Texture2DArrayAsset);","title":"Generated Code Example"},{"location":"ShaderGraph/Texture-2D-Asset-Node/","text":"Texture 2D Asset Node Description Defines a constant Texture 2D Asset for use in the shader. To sample the Texture 2D Asset it should be used in conjunction with a Sample Texture 2D Node . When using a separate Texture 2D Asset Node , you can sample a Texture 2D twice, with different parameters, without defining the Texture 2D itself twice. Ports Name Direction Type Description Out Output Texture 2D Output value Controls Name Type Options Description Object Field (Texture) Defines the texture 3D asset from the project. Generated Code Example The following example code represents one possible outcome of this node. TEXTURE2D(_Texture2DAsset); SAMPLER(sampler_Texture2DAsset);","title":"Texture 2D Asset Node"},{"location":"ShaderGraph/Texture-2D-Asset-Node/#texture-2d-asset-node","text":"","title":"Texture 2D Asset Node"},{"location":"ShaderGraph/Texture-2D-Asset-Node/#description","text":"Defines a constant Texture 2D Asset for use in the shader. To sample the Texture 2D Asset it should be used in conjunction with a Sample Texture 2D Node . When using a separate Texture 2D Asset Node , you can sample a Texture 2D twice, with different parameters, without defining the Texture 2D itself twice.","title":"Description"},{"location":"ShaderGraph/Texture-2D-Asset-Node/#ports","text":"Name Direction Type Description Out Output Texture 2D Output value","title":"Ports"},{"location":"ShaderGraph/Texture-2D-Asset-Node/#controls","text":"Name Type Options Description Object Field (Texture) Defines the texture 3D asset from the project.","title":"Controls"},{"location":"ShaderGraph/Texture-2D-Asset-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. TEXTURE2D(_Texture2DAsset); SAMPLER(sampler_Texture2DAsset);","title":"Generated Code Example"},{"location":"ShaderGraph/Texture-3D-Asset-Node/","text":"Texture 3D Asset Node Description Defines a constant Texture 3D Asset for use in the shader. To sample the Texture 3D Asset it should be used in conjunction with a Sample Texture 3D Node . When using a separate Texture 3D Asset Node , you can sample a Texture 3D twice, with different parameters, without defining the Texture 3D itself twice. Ports Name Direction Type Description Out Output Texture 3D Output value Controls Name Type Options Description Object Field (Texture 3D) Defines the texture 3D asset from the project. Generated Code Example The following example code represents one possible outcome of this node. TEXTURE3D(_Texture3DAsset); SAMPLER(sampler_Texture3DAsset);","title":"Texture 3D Asset Node"},{"location":"ShaderGraph/Texture-3D-Asset-Node/#texture-3d-asset-node","text":"","title":"Texture 3D Asset Node"},{"location":"ShaderGraph/Texture-3D-Asset-Node/#description","text":"Defines a constant Texture 3D Asset for use in the shader. To sample the Texture 3D Asset it should be used in conjunction with a Sample Texture 3D Node . When using a separate Texture 3D Asset Node , you can sample a Texture 3D twice, with different parameters, without defining the Texture 3D itself twice.","title":"Description"},{"location":"ShaderGraph/Texture-3D-Asset-Node/#ports","text":"Name Direction Type Description Out Output Texture 3D Output value","title":"Ports"},{"location":"ShaderGraph/Texture-3D-Asset-Node/#controls","text":"Name Type Options Description Object Field (Texture 3D) Defines the texture 3D asset from the project.","title":"Controls"},{"location":"ShaderGraph/Texture-3D-Asset-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. TEXTURE3D(_Texture3DAsset); SAMPLER(sampler_Texture3DAsset);","title":"Generated Code Example"},{"location":"ShaderGraph/Tiling-And-Offset-Node/","text":"Tiling And Offset Node Description Tiles and offsets the value of input UV by the inputs Tiling and Offset respectively. This is commonly used for detail maps and scrolling textures over Time . Ports Name Direction Type Binding Description UV Input Vector 2 UV Input UV value Tiling Input Vector 2 None Amount of tiling to apply per channel Offset Input Vector 2 None Amount of offset to apply per channel Out Output Vector 2 None Output UV value Generated Code Example The following example code represents one possible outcome of this node. void Unity_TilingAndOffset_float(float2 UV, float2 Tiling, float2 Offset, out float2 Out) { Out = UV * Tiling + Offset; }","title":"Tiling And Offset Node"},{"location":"ShaderGraph/Tiling-And-Offset-Node/#tiling-and-offset-node","text":"","title":"Tiling And Offset Node"},{"location":"ShaderGraph/Tiling-And-Offset-Node/#description","text":"Tiles and offsets the value of input UV by the inputs Tiling and Offset respectively. This is commonly used for detail maps and scrolling textures over Time .","title":"Description"},{"location":"ShaderGraph/Tiling-And-Offset-Node/#ports","text":"Name Direction Type Binding Description UV Input Vector 2 UV Input UV value Tiling Input Vector 2 None Amount of tiling to apply per channel Offset Input Vector 2 None Amount of offset to apply per channel Out Output Vector 2 None Output UV value","title":"Ports"},{"location":"ShaderGraph/Tiling-And-Offset-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_TilingAndOffset_float(float2 UV, float2 Tiling, float2 Offset, out float2 Out) { Out = UV * Tiling + Offset; }","title":"Generated Code Example"},{"location":"ShaderGraph/Time-Node/","text":"Time Node Description Provides access to various Time parameters in the shader. Ports Name Direction Type Binding Description Time Output Vector 1 None Time value Sine Time Output Vector 1 None Sine of Time value Cosine Time Output Vector 1 None Cosine of Time value Delta Time Output Vector 1 None Current frame time Smooth Delta Output Vector 1 None Current frame time smoothed Generated Code Example The following example code represents one possible outcome of this node. float Time_Time = _Time.y; float Time_SineTime = _SinTime.w; float Time_CosineTime = _CosTime.w; float Time_DeltaTime = unity_DeltaTime.x; float Time_SmoothDelta = unity_DeltaTime.z;","title":"Time Node"},{"location":"ShaderGraph/Time-Node/#time-node","text":"","title":"Time Node"},{"location":"ShaderGraph/Time-Node/#description","text":"Provides access to various Time parameters in the shader.","title":"Description"},{"location":"ShaderGraph/Time-Node/#ports","text":"Name Direction Type Binding Description Time Output Vector 1 None Time value Sine Time Output Vector 1 None Sine of Time value Cosine Time Output Vector 1 None Cosine of Time value Delta Time Output Vector 1 None Current frame time Smooth Delta Output Vector 1 None Current frame time smoothed","title":"Ports"},{"location":"ShaderGraph/Time-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. float Time_Time = _Time.y; float Time_SineTime = _SinTime.w; float Time_CosineTime = _CosTime.w; float Time_DeltaTime = unity_DeltaTime.x; float Time_SmoothDelta = unity_DeltaTime.z;","title":"Generated Code Example"},{"location":"ShaderGraph/Transform-Node/","text":"Transform Node Description Returns the result of transforming the value of input In from one coordinate space to another. The spaces to transform from and to are defined the values of the dropdowns on the node. Ports Name Direction Type Description In Input Vector 3 Input value Out Output Vector 3 Output value Controls Name Type Options Description From Dropdown Object, View, World, Tangent Selects the space to convert from To Dropdown Object, View, World, Tangent Selects the space to convert to Generated Code Example The following example code represents one possible outcome of this node per Base mode. World > World float3 _Transform_Out = In; World > Object float3 _Transform_Out = TransformWorldToObject(In); World > Tangent float3x3 tangentTransform_World = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal); float3 _Transform_Out = TransformWorldToTangent(In, tangentTransform_World); World > View float3 _Transform_Out = TransformWorldToView(In); Object > World float3 _Transform_Out = TransformObjectToWorld(In); Object > Object float3 _Transform_Out = In; Object > Tangent float3x3 tangentTransform_World = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal); float3 _Transform_Out = TransformWorldToTangent(TransformObjectToWorld(In), tangentTransform_World); Object > View float3 _Transform_Out = TransformWorldToView(TransformObjectToWorld(In)); Tangent > World float3x3 transposeTangent = transpose(float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal)); float3 _Transform_Out = mul(In, transposeTangent).xyz; Tangent > Object float3x3 transposeTangent = transpose(float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal)); float3 _Transform_Out = TransformWorldToObject(mul(In, transposeTangent).xyz); Tangent > Tangent float3 _Transform_Out = In; Tangent > View float3x3 transposeTangent = transpose(float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal)); float3 _Transform_Out = TransformWorldToView(mul(In, transposeTangent).xyz); View > World float3 _Transform_Out = mul(UNITY_MATRIX_I_V, float4(In, 1)).xyz; View > Object float3 _Transform_Out = TransformWorldToObject(mul(UNITY_MATRIX_I_V, float4(In, 1) ).xyz); View > Tangent float3x3 tangentTransform_World = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal); float3 _Transform_Out = TransformWorldToTangent(mul(UNITY_MATRIX_I_V, float4(In, 1) ).xyz, tangentTransform_World); View > View float3 _Transform_Out = In;","title":"Transform Node"},{"location":"ShaderGraph/Transform-Node/#transform-node","text":"","title":"Transform Node"},{"location":"ShaderGraph/Transform-Node/#description","text":"Returns the result of transforming the value of input In from one coordinate space to another. The spaces to transform from and to are defined the values of the dropdowns on the node.","title":"Description"},{"location":"ShaderGraph/Transform-Node/#ports","text":"Name Direction Type Description In Input Vector 3 Input value Out Output Vector 3 Output value","title":"Ports"},{"location":"ShaderGraph/Transform-Node/#controls","text":"Name Type Options Description From Dropdown Object, View, World, Tangent Selects the space to convert from To Dropdown Object, View, World, Tangent Selects the space to convert to","title":"Controls"},{"location":"ShaderGraph/Transform-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node per Base mode. World > World float3 _Transform_Out = In; World > Object float3 _Transform_Out = TransformWorldToObject(In); World > Tangent float3x3 tangentTransform_World = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal); float3 _Transform_Out = TransformWorldToTangent(In, tangentTransform_World); World > View float3 _Transform_Out = TransformWorldToView(In); Object > World float3 _Transform_Out = TransformObjectToWorld(In); Object > Object float3 _Transform_Out = In; Object > Tangent float3x3 tangentTransform_World = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal); float3 _Transform_Out = TransformWorldToTangent(TransformObjectToWorld(In), tangentTransform_World); Object > View float3 _Transform_Out = TransformWorldToView(TransformObjectToWorld(In)); Tangent > World float3x3 transposeTangent = transpose(float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal)); float3 _Transform_Out = mul(In, transposeTangent).xyz; Tangent > Object float3x3 transposeTangent = transpose(float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal)); float3 _Transform_Out = TransformWorldToObject(mul(In, transposeTangent).xyz); Tangent > Tangent float3 _Transform_Out = In; Tangent > View float3x3 transposeTangent = transpose(float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal)); float3 _Transform_Out = TransformWorldToView(mul(In, transposeTangent).xyz); View > World float3 _Transform_Out = mul(UNITY_MATRIX_I_V, float4(In, 1)).xyz; View > Object float3 _Transform_Out = TransformWorldToObject(mul(UNITY_MATRIX_I_V, float4(In, 1) ).xyz); View > Tangent float3x3 tangentTransform_World = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal); float3 _Transform_Out = TransformWorldToTangent(mul(UNITY_MATRIX_I_V, float4(In, 1) ).xyz, tangentTransform_World); View > View float3 _Transform_Out = In;","title":"Generated Code Example"},{"location":"ShaderGraph/Transformation-Matrix-Node/","text":"Transformation Matrix Node Description Defines a constant Matrix 4x4 value for a common Transformation Matrix in the shader. The Transformation Matrix can be selected from the dropdown parameter. Ports Name Direction Type Binding Description Out Output Matrix 4 None Output value Controls Name Type Options Description Dropdown Model, InverseModel, View, InverseView, Projection, InverseProjection, ViewProjection, InverseViewProjection Sets output value Generated Code Example The following example code represents one possible outcome of this node per mode. Model float4x4 _TransformationMatrix_Out = UNITY_MATRIX_M; InverseModel float4x4 _TransformationMatrix_Out = UNITY_MATRIX_I_M; View float4x4 _TransformationMatrix_Out = UNITY_MATRIX_V; InverseView float4x4 _TransformationMatrix_Out = UNITY_MATRIX_I_V; Projection float4x4 _TransformationMatrix_Out = UNITY_MATRIX_P; InverseProjection float4x4 _TransformationMatrix_Out = UNITY_MATRIX_I_P; ViewProjection float4x4 _TransformationMatrix_Out = UNITY_MATRIX_VP; InverseViewProjection float4x4 _TransformationMatrix_Out = UNITY_MATRIX_I_VP;","title":"Transformation Matrix Node"},{"location":"ShaderGraph/Transformation-Matrix-Node/#transformation-matrix-node","text":"","title":"Transformation Matrix Node"},{"location":"ShaderGraph/Transformation-Matrix-Node/#description","text":"Defines a constant Matrix 4x4 value for a common Transformation Matrix in the shader. The Transformation Matrix can be selected from the dropdown parameter.","title":"Description"},{"location":"ShaderGraph/Transformation-Matrix-Node/#ports","text":"Name Direction Type Binding Description Out Output Matrix 4 None Output value","title":"Ports"},{"location":"ShaderGraph/Transformation-Matrix-Node/#controls","text":"Name Type Options Description Dropdown Model, InverseModel, View, InverseView, Projection, InverseProjection, ViewProjection, InverseViewProjection Sets output value","title":"Controls"},{"location":"ShaderGraph/Transformation-Matrix-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node per mode. Model float4x4 _TransformationMatrix_Out = UNITY_MATRIX_M; InverseModel float4x4 _TransformationMatrix_Out = UNITY_MATRIX_I_M; View float4x4 _TransformationMatrix_Out = UNITY_MATRIX_V; InverseView float4x4 _TransformationMatrix_Out = UNITY_MATRIX_I_V; Projection float4x4 _TransformationMatrix_Out = UNITY_MATRIX_P; InverseProjection float4x4 _TransformationMatrix_Out = UNITY_MATRIX_I_P; ViewProjection float4x4 _TransformationMatrix_Out = UNITY_MATRIX_VP; InverseViewProjection float4x4 _TransformationMatrix_Out = UNITY_MATRIX_I_VP;","title":"Generated Code Example"},{"location":"ShaderGraph/Triange-Wave-Node/","text":"Triangle Wave Node Description Returns a triangle wave from the value of input In . Ports Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_TriangleWave_float4(float4 In, out float4 Out) { Out = 2.0 * abs( 2 * (In - floor(0.5 + In)) ) - 1.0; }","title":"Triangle Wave Node"},{"location":"ShaderGraph/Triange-Wave-Node/#triangle-wave-node","text":"","title":"Triangle Wave Node"},{"location":"ShaderGraph/Triange-Wave-Node/#description","text":"Returns a triangle wave from the value of input In .","title":"Description"},{"location":"ShaderGraph/Triange-Wave-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Triange-Wave-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_TriangleWave_float4(float4 In, out float4 Out) { Out = 2.0 * abs( 2 * (In - floor(0.5 + In)) ) - 1.0; }","title":"Generated Code Example"},{"location":"ShaderGraph/Triplanar-Node/","text":"Triplanar Node Description Triplanar is a method of generating UVs and sampling a texture by projecting in world space. The input Texture is sampled 3 times, once in each of the world x, y and z axises, and the resulting information is planar projected onto the model, blended by the normal, or surface angle. The generated UVs can be scaled with the input Tile and the final blending strength can be controlled with the input Blend . The projection can be modified by overriding the inputs Position and Normal . This is commonly used to texture large models such as terrain, where hand authoring UV coordinates would be problematic or not performant. The expected type of the input Texture can be switched with the dropdown Type . If set to Normal the normals will be converted into world space so new tangents can be constructed then converted back to tangent space before output. NOTE: This Node can only be used in the Fragment shader stage. Ports Name Direction Type Binding Description Texture Input Texture None Input texture value Sampler Input Sampler State None Sampler for input Texture Position Input Vector 3 World Space Position Fragment position Normal Input Vector 3 World Space Normal Fragment normal Tile Input Vector 1 None Tiling amount for generated UVs Blend Input Vector 1 None Blend factor between different samples Out Output Vector 4 None Output value Controls Name Type Options Description Type Dropdown Default, Normal Type of input Texture Generated Code Example The following example code represents one possible outcome of this node. Default float3 Node_UV = Position * Tile; float3 Node_Blend = pow(abs(Normal), Blend); Node_Blend /= dot(Node_Blend, 1.0); float4 Node_X = SAMPLE_TEXTURE2D(Texture, Sampler, Node_UV.zy); float4 Node_Y = SAMPLE_TEXTURE2D(Texture, Sampler, Node_UV.xz); float4 Node_Z = SAMPLE_TEXTURE2D(Texture, Sampler, Node_UV.xy); float4 Out = Node_X * Node_Blend.x + Node_Y * Node_Blend.y + Node_Z * Node_Blend.z; Normal float3 Node_UV = Position * Tile; float3 Node_Blend = max(pow(abs(Normal), Blend), 0); Node_Blend /= (Node_Blend.x + Node_Blend.y + Node_Blend.z ).xxx; float3 Node_X = UnpackNormalmapRGorAG(SAMPLE_TEXTURE2D(Texture, Sampler, Node_UV.zy)); float3 Node_Y = UnpackNormalmapRGorAG(SAMPLE_TEXTURE2D(Texture, Sampler, Node_UV.xz)); float3 Node_Z = UnpackNormalmapRGorAG(SAMPLE_TEXTURE2D(Texture, Sampler, Node_UV.xy)); Node_X = float3(Node_X.xy + Normal.zy, abs(Node_X.z) * Normal.x); Node_Y = float3(Node_Y.xy + Normal.xz, abs(Node_Y.z) * Normal.y); Node_Z = float3(Node_Z.xy + Normal.xy, abs(Node_Z.z) * Normal.z); float4 Out = float4(normalize(Node_X.zyx * Node_Blend.x + Node_Y.xzy * Node_Blend.y + Node_Z.xyz * Node_Blend.z), 1); float3x3 Node_Transform = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal); Out.rgb = TransformWorldToTangent(Out.rgb, Node_Transform);","title":"Triplanar Node"},{"location":"ShaderGraph/Triplanar-Node/#triplanar-node","text":"","title":"Triplanar Node"},{"location":"ShaderGraph/Triplanar-Node/#description","text":"Triplanar is a method of generating UVs and sampling a texture by projecting in world space. The input Texture is sampled 3 times, once in each of the world x, y and z axises, and the resulting information is planar projected onto the model, blended by the normal, or surface angle. The generated UVs can be scaled with the input Tile and the final blending strength can be controlled with the input Blend . The projection can be modified by overriding the inputs Position and Normal . This is commonly used to texture large models such as terrain, where hand authoring UV coordinates would be problematic or not performant. The expected type of the input Texture can be switched with the dropdown Type . If set to Normal the normals will be converted into world space so new tangents can be constructed then converted back to tangent space before output. NOTE: This Node can only be used in the Fragment shader stage.","title":"Description"},{"location":"ShaderGraph/Triplanar-Node/#ports","text":"Name Direction Type Binding Description Texture Input Texture None Input texture value Sampler Input Sampler State None Sampler for input Texture Position Input Vector 3 World Space Position Fragment position Normal Input Vector 3 World Space Normal Fragment normal Tile Input Vector 1 None Tiling amount for generated UVs Blend Input Vector 1 None Blend factor between different samples Out Output Vector 4 None Output value","title":"Ports"},{"location":"ShaderGraph/Triplanar-Node/#controls","text":"Name Type Options Description Type Dropdown Default, Normal Type of input Texture","title":"Controls"},{"location":"ShaderGraph/Triplanar-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. Default float3 Node_UV = Position * Tile; float3 Node_Blend = pow(abs(Normal), Blend); Node_Blend /= dot(Node_Blend, 1.0); float4 Node_X = SAMPLE_TEXTURE2D(Texture, Sampler, Node_UV.zy); float4 Node_Y = SAMPLE_TEXTURE2D(Texture, Sampler, Node_UV.xz); float4 Node_Z = SAMPLE_TEXTURE2D(Texture, Sampler, Node_UV.xy); float4 Out = Node_X * Node_Blend.x + Node_Y * Node_Blend.y + Node_Z * Node_Blend.z; Normal float3 Node_UV = Position * Tile; float3 Node_Blend = max(pow(abs(Normal), Blend), 0); Node_Blend /= (Node_Blend.x + Node_Blend.y + Node_Blend.z ).xxx; float3 Node_X = UnpackNormalmapRGorAG(SAMPLE_TEXTURE2D(Texture, Sampler, Node_UV.zy)); float3 Node_Y = UnpackNormalmapRGorAG(SAMPLE_TEXTURE2D(Texture, Sampler, Node_UV.xz)); float3 Node_Z = UnpackNormalmapRGorAG(SAMPLE_TEXTURE2D(Texture, Sampler, Node_UV.xy)); Node_X = float3(Node_X.xy + Normal.zy, abs(Node_X.z) * Normal.x); Node_Y = float3(Node_Y.xy + Normal.xz, abs(Node_Y.z) * Normal.y); Node_Z = float3(Node_Z.xy + Normal.xy, abs(Node_Z.z) * Normal.z); float4 Out = float4(normalize(Node_X.zyx * Node_Blend.x + Node_Y.xzy * Node_Blend.y + Node_Z.xyz * Node_Blend.z), 1); float3x3 Node_Transform = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal); Out.rgb = TransformWorldToTangent(Out.rgb, Node_Transform);","title":"Generated Code Example"},{"location":"ShaderGraph/Truncate-Node/","text":"Truncate Node Description Returns the integer, or whole number, component of the value of input In . For example, given an input value of 1.7, this node will return the value 1.0. Ports Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Truncate_float4(float4 In, out float4 Out) { Out = trunc(In); }","title":"Truncate Node"},{"location":"ShaderGraph/Truncate-Node/#truncate-node","text":"","title":"Truncate Node"},{"location":"ShaderGraph/Truncate-Node/#description","text":"Returns the integer, or whole number, component of the value of input In . For example, given an input value of 1.7, this node will return the value 1.0.","title":"Description"},{"location":"ShaderGraph/Truncate-Node/#ports","text":"Name Direction Type Description In Input Dynamic Vector Input value Out Output Dynamic Vector Output value","title":"Ports"},{"location":"ShaderGraph/Truncate-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Truncate_float4(float4 In, out float4 Out) { Out = trunc(In); }","title":"Generated Code Example"},{"location":"ShaderGraph/Twirl-Node/","text":"Twirl Node Description Applies a twirl warping effect similar to a black hole to the value of input UV . The center reference point of the warping effect is defined by input Center and the overall strength of the effect is defined by the value of input Strength . Input Offset can be used to offset the individual channels of the result. Ports Name Direction Type Binding Description UV Input Vector 2 UV Input UV value Center Input Vector 2 None Center reference point Strength Input Vector 1 None Strength of the effect Offset Input Vector 2 None Individual channel offsets Out Output Vector 2 None Output UV value Generated Code Example The following example code represents one possible outcome of this node. void Unity_Twirl_float(float2 UV, float2 Center, float Strength, float2 Offset, out float2 Out) { float2 delta = UV - Center; float angle = Strength * length(delta); float x = cos(angle) * delta.x - sin(angle) * delta.y; float y = sin(angle) * delta.x + cos(angle) * delta.y; Out = float2(x + Center.x + Offset.x, y + Center.y + Offset.y); }","title":"Twirl Node"},{"location":"ShaderGraph/Twirl-Node/#twirl-node","text":"","title":"Twirl Node"},{"location":"ShaderGraph/Twirl-Node/#description","text":"Applies a twirl warping effect similar to a black hole to the value of input UV . The center reference point of the warping effect is defined by input Center and the overall strength of the effect is defined by the value of input Strength . Input Offset can be used to offset the individual channels of the result.","title":"Description"},{"location":"ShaderGraph/Twirl-Node/#ports","text":"Name Direction Type Binding Description UV Input Vector 2 UV Input UV value Center Input Vector 2 None Center reference point Strength Input Vector 1 None Strength of the effect Offset Input Vector 2 None Individual channel offsets Out Output Vector 2 None Output UV value","title":"Ports"},{"location":"ShaderGraph/Twirl-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_Twirl_float(float2 UV, float2 Center, float Strength, float2 Offset, out float2 Out) { float2 delta = UV - Center; float angle = Strength * length(delta); float x = cos(angle) * delta.x - sin(angle) * delta.y; float y = sin(angle) * delta.x + cos(angle) * delta.y; Out = float2(x + Center.x + Offset.x, y + Center.y + Offset.y); }","title":"Generated Code Example"},{"location":"ShaderGraph/UV-Node/","text":"UV Node Description Provides access to the mesh vertex or fragment's UV coordinates. The coordinate channel of the output value can be selected with the Channel dropdown parameter. Ports Name Direction Type Binding Description Out Output Vector 4 None Mesh's UV coordinates. Controls Name Type Options Description Channel Dropdown UV0, UV1, UV2, UV3 Selects coordinate channel of UV to output.","title":"UV Node"},{"location":"ShaderGraph/UV-Node/#uv-node","text":"","title":"UV Node"},{"location":"ShaderGraph/UV-Node/#description","text":"Provides access to the mesh vertex or fragment's UV coordinates. The coordinate channel of the output value can be selected with the Channel dropdown parameter.","title":"Description"},{"location":"ShaderGraph/UV-Node/#ports","text":"Name Direction Type Binding Description Out Output Vector 4 None Mesh's UV coordinates.","title":"Ports"},{"location":"ShaderGraph/UV-Node/#controls","text":"Name Type Options Description Channel Dropdown UV0, UV1, UV2, UV3 Selects coordinate channel of UV to output.","title":"Controls"},{"location":"ShaderGraph/UV-Nodes/","text":"UV Nodes Flipbook Polar Coordinates Creates a flipbook, or texture sheet animation, of the UVs supplied to input In. Converts the value of input UV to polar coordinates. Radial Shear Rotate Applies a radial shear warping effect similar to a wave to the value of input UV. Rotates the value of input UV around a reference point defined by input Center by the amount of input Rotation. Spherize Tiling and Offset Applies a spherical warping effect similar to a fisheye camera lens to the value of input UV. Tiles and offsets the value of input UV by the inputs Tiling and Offset respectively. Triplanar Twirl A method of generating UVs and sampling a texture by projecting in world space. Applies a twirl warping effect similar to a black hole to the value of input UV.","title":"UV Nodes"},{"location":"ShaderGraph/UV-Nodes/#uv-nodes","text":"Flipbook Polar Coordinates Creates a flipbook, or texture sheet animation, of the UVs supplied to input In. Converts the value of input UV to polar coordinates. Radial Shear Rotate Applies a radial shear warping effect similar to a wave to the value of input UV. Rotates the value of input UV around a reference point defined by input Center by the amount of input Rotation. Spherize Tiling and Offset Applies a spherical warping effect similar to a fisheye camera lens to the value of input UV. Tiles and offsets the value of input UV by the inputs Tiling and Offset respectively. Triplanar Twirl A method of generating UVs and sampling a texture by projecting in world space. Applies a twirl warping effect similar to a black hole to the value of input UV.","title":"UV Nodes"},{"location":"ShaderGraph/Unlit-Master-Node/","text":"Unlit Master Node Description A Master Node for unlit materials. Ports Name Direction Type Stage Binding Description Position Input Vector 3 Vertex None Defines the absolute object space vertex position per vertex Color Input Vector 3 Fragment None Defines material's color value. Expected range 0 - 1. Alpha Input Vector 1 Fragment None Defines material's alpha value. Used for transparency and/or alpha clip. Expected range 0 - 1. Alpha Clip Threshold Input Vector 1 Fragment None Fragments with an alpha below this value will be discarded. Requires a node connection. Expected range 0 - 1. Material Options Unlit Master Node material options can be accessed by clicking the cog icon in the top right corner of the Unlit Master Node . Name Type Options Description Surface Dropdown Opaque, Transparent Defines if the material is transparent Blend Dropdown Alpha, Premultiply, Additive, Multiply Defines blend mode of a transparent material Two Sided Toggle True, False If true both front and back faces of the mesh are rendered","title":"Unlit Master Node"},{"location":"ShaderGraph/Unlit-Master-Node/#unlit-master-node","text":"","title":"Unlit Master Node"},{"location":"ShaderGraph/Unlit-Master-Node/#description","text":"A Master Node for unlit materials.","title":"Description"},{"location":"ShaderGraph/Unlit-Master-Node/#ports","text":"Name Direction Type Stage Binding Description Position Input Vector 3 Vertex None Defines the absolute object space vertex position per vertex Color Input Vector 3 Fragment None Defines material's color value. Expected range 0 - 1. Alpha Input Vector 1 Fragment None Defines material's alpha value. Used for transparency and/or alpha clip. Expected range 0 - 1. Alpha Clip Threshold Input Vector 1 Fragment None Fragments with an alpha below this value will be discarded. Requires a node connection. Expected range 0 - 1.","title":"Ports"},{"location":"ShaderGraph/Unlit-Master-Node/#material-options","text":"Unlit Master Node material options can be accessed by clicking the cog icon in the top right corner of the Unlit Master Node . Name Type Options Description Surface Dropdown Opaque, Transparent Defines if the material is transparent Blend Dropdown Alpha, Premultiply, Additive, Multiply Defines blend mode of a transparent material Two Sided Toggle True, False If true both front and back faces of the mesh are rendered","title":"Material Options"},{"location":"ShaderGraph/Utility-Nodes/","text":"Utility Nodes Preview Sub-Graph Provides a preview window and passes the input value through without modification. Provides a reference to a Sub-graph asset. Logic All And Provides a preview window and passes the input value through without modification. Provides a reference to a Sub-graph asset. Any Branch Returns true if any of the components of the input In are non-zero. Provides a dynamic branch to the shader. Comparison Is Infinite Compares the two input values A and B based on the condition selected on the dropdown. Returns true if any of the components of the input In is an infinite value. Is NaN Nand Returns true if any of the components of the input In is not a number (NaN). Returns true if both the inputs A and B are false. Not Or Returns the opposite of input In. If In is true the output will be false, otherwise it will be true. Returns true if either of the inputs A and B are true.","title":"Utility Nodes"},{"location":"ShaderGraph/Utility-Nodes/#utility-nodes","text":"Preview Sub-Graph Provides a preview window and passes the input value through without modification. Provides a reference to a Sub-graph asset.","title":"Utility Nodes"},{"location":"ShaderGraph/Utility-Nodes/#logic","text":"All And Provides a preview window and passes the input value through without modification. Provides a reference to a Sub-graph asset. Any Branch Returns true if any of the components of the input In are non-zero. Provides a dynamic branch to the shader. Comparison Is Infinite Compares the two input values A and B based on the condition selected on the dropdown. Returns true if any of the components of the input In is an infinite value. Is NaN Nand Returns true if any of the components of the input In is not a number (NaN). Returns true if both the inputs A and B are false. Not Or Returns the opposite of input In. If In is true the output will be false, otherwise it will be true. Returns true if either of the inputs A and B are true.","title":"Logic"},{"location":"ShaderGraph/Vector-1-Node/","text":"Vector 1 Node Description Defines a Vector 1 value in the shader. If Port X is not connected with an Edge this Node defines a constant Vector 1 . Ports Name Direction Type Binding Description X Input Vector 1 None Input x component value Out Output Vector 1 None Output value Generated Code Example The following example code represents one possible outcome of this node. float _Vector1_Out = X;","title":"Vector 1 Node"},{"location":"ShaderGraph/Vector-1-Node/#vector-1-node","text":"","title":"Vector 1 Node"},{"location":"ShaderGraph/Vector-1-Node/#description","text":"Defines a Vector 1 value in the shader. If Port X is not connected with an Edge this Node defines a constant Vector 1 .","title":"Description"},{"location":"ShaderGraph/Vector-1-Node/#ports","text":"Name Direction Type Binding Description X Input Vector 1 None Input x component value Out Output Vector 1 None Output value","title":"Ports"},{"location":"ShaderGraph/Vector-1-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. float _Vector1_Out = X;","title":"Generated Code Example"},{"location":"ShaderGraph/Vector-2-Node/","text":"Vector 2 Node Description Defines a Vector 2 value in the shader. If Ports X and Y are not connected with Edges this Node defines a constant Vector 2 , otherwise this Node can be used to combine various Vector 1 values. Ports Name Direction Type Binding Description X Input Vector 1 None Input x component value Y Input Vector 1 None Input y component value Out Output Vector 2 None Output value Generated Code Example The following example code represents one possible outcome of this node. float2 _Vector2_Out = float2(X, Y);","title":"Vector 2 Node"},{"location":"ShaderGraph/Vector-2-Node/#vector-2-node","text":"","title":"Vector 2 Node"},{"location":"ShaderGraph/Vector-2-Node/#description","text":"Defines a Vector 2 value in the shader. If Ports X and Y are not connected with Edges this Node defines a constant Vector 2 , otherwise this Node can be used to combine various Vector 1 values.","title":"Description"},{"location":"ShaderGraph/Vector-2-Node/#ports","text":"Name Direction Type Binding Description X Input Vector 1 None Input x component value Y Input Vector 1 None Input y component value Out Output Vector 2 None Output value","title":"Ports"},{"location":"ShaderGraph/Vector-2-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. float2 _Vector2_Out = float2(X, Y);","title":"Generated Code Example"},{"location":"ShaderGraph/Vector-3-Node/","text":"Vector 3 Node Description Defines a Vector 3 value in the shader. If Ports X , Y and Z are not connected with Edges this Node defines a constant Vector 3 , otherwise this Node can be used to combine various Vector 1 values. Ports Name Direction Type Binding Description X Input Vector 1 None Input x component value Y Input Vector 1 None Input y component value Z Input Vector 1 None Input z component value Out Output Vector 3 None Output value Generated Code Example The following example code represents one possible outcome of this node. float3 _Vector3_Out = float3(X, Y, Z);","title":"Vector 3 Node"},{"location":"ShaderGraph/Vector-3-Node/#vector-3-node","text":"","title":"Vector 3 Node"},{"location":"ShaderGraph/Vector-3-Node/#description","text":"Defines a Vector 3 value in the shader. If Ports X , Y and Z are not connected with Edges this Node defines a constant Vector 3 , otherwise this Node can be used to combine various Vector 1 values.","title":"Description"},{"location":"ShaderGraph/Vector-3-Node/#ports","text":"Name Direction Type Binding Description X Input Vector 1 None Input x component value Y Input Vector 1 None Input y component value Z Input Vector 1 None Input z component value Out Output Vector 3 None Output value","title":"Ports"},{"location":"ShaderGraph/Vector-3-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. float3 _Vector3_Out = float3(X, Y, Z);","title":"Generated Code Example"},{"location":"ShaderGraph/Vector-4-Node/","text":"Vector 4 Node Description Defines a Vector 4 value in the shader. If Ports X , Y , Z and W are not connected with Edges this Node defines a constant Vector 4 , otherwise this Node can be used to combine various Vector 1 values. Ports Name Direction Type Binding Description X Input Vector 1 None Input x component value Y Input Vector 1 None Input y component value Z Input Vector 1 None Input z component value W Input Vector 1 None Input w component value Out Output Vector 4 None Output value Generated Code Example The following example code represents one possible outcome of this node. float4 _Vector4_Out = float4(X, Y, Z, W);","title":"Vector 4 Node"},{"location":"ShaderGraph/Vector-4-Node/#vector-4-node","text":"","title":"Vector 4 Node"},{"location":"ShaderGraph/Vector-4-Node/#description","text":"Defines a Vector 4 value in the shader. If Ports X , Y , Z and W are not connected with Edges this Node defines a constant Vector 4 , otherwise this Node can be used to combine various Vector 1 values.","title":"Description"},{"location":"ShaderGraph/Vector-4-Node/#ports","text":"Name Direction Type Binding Description X Input Vector 1 None Input x component value Y Input Vector 1 None Input y component value Z Input Vector 1 None Input z component value W Input Vector 1 None Input w component value Out Output Vector 4 None Output value","title":"Ports"},{"location":"ShaderGraph/Vector-4-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. float4 _Vector4_Out = float4(X, Y, Z, W);","title":"Generated Code Example"},{"location":"ShaderGraph/Vertex-Color-Node/","text":"Vertex Color Node Description Provides access to the mesh vertex or fragment's Vertex Color value. Ports Name Direction Type Binding Description Out Output Vector 4 None Vertex Color for the Mesh Vertex/Fragment.","title":"Vertex Color Node"},{"location":"ShaderGraph/Vertex-Color-Node/#vertex-color-node","text":"","title":"Vertex Color Node"},{"location":"ShaderGraph/Vertex-Color-Node/#description","text":"Provides access to the mesh vertex or fragment's Vertex Color value.","title":"Description"},{"location":"ShaderGraph/Vertex-Color-Node/#ports","text":"Name Direction Type Binding Description Out Output Vector 4 None Vertex Color for the Mesh Vertex/Fragment.","title":"Ports"},{"location":"ShaderGraph/View-Direction-Node/","text":"View Direction Node Description Provides access to the mesh vertex or fragment's View Direction vector. This is the vector from the vertex or fragment to the camera. The coordinate space of the output value can be selected with the Space dropdown parameter. Ports Name Direction Type Binding Description Out Output Vector 3 None View Direction for the Mesh Vertex/Fragment. Controls Name Type Options Description Space Dropdown Object, View, World, Tangent Selects coordinate space of View Direction to output.","title":"View Direction Node"},{"location":"ShaderGraph/View-Direction-Node/#view-direction-node","text":"","title":"View Direction Node"},{"location":"ShaderGraph/View-Direction-Node/#description","text":"Provides access to the mesh vertex or fragment's View Direction vector. This is the vector from the vertex or fragment to the camera. The coordinate space of the output value can be selected with the Space dropdown parameter.","title":"Description"},{"location":"ShaderGraph/View-Direction-Node/#ports","text":"Name Direction Type Binding Description Out Output Vector 3 None View Direction for the Mesh Vertex/Fragment.","title":"Ports"},{"location":"ShaderGraph/View-Direction-Node/#controls","text":"Name Type Options Description Space Dropdown Object, View, World, Tangent Selects coordinate space of View Direction to output.","title":"Controls"},{"location":"ShaderGraph/Voronoi-Node/","text":"Voronoi Node Description Generates a Voronoi, or Worley , noise based on input UV . Voronoi noise is generated by calculating distances between a pixel and a lattice of points. By offsetting these points by a pseudo-random number, controlled by input Angle Offset , a cluster of cells can be generated. The scale of these cells, and the resulting noise, is controlled by input Cell Density . The output Cells contains the raw cell data. Ports Name Direction Type Binding Description UV Input Vector 2 UV Input UV value Angle Offset Input Vector 1 None Offset value for points Cell Density Input Vector 1 None Density of cells generated Out Output Vector 1 None Output noise value Cells Output Vector 1 None Raw cell data Generated Code Example The following example code represents one possible outcome of this node. inline float2 unity_voronoi_noise_randomVector (float2 UV, float offset) { float2x2 m = float2x2(15.27, 47.63, 99.41, 89.98); UV = frac(sin(mul(UV, m)) * 46839.32); return float2(sin(UV.y*+offset)*0.5+0.5, cos(UV.x*offset)*0.5+0.5); } void Unity_Voronoi_float(float2 UV, float AngleOffset, float CellDensity, out float Out, out float Cells) { float2 g = floor(UV * CellDensity); float2 f = frac(UV * CellDensity); float t = 8.0; float3 res = float3(8.0, 0.0, 0.0); for(int y=-1; y<=1; y++) { for(int x=-1; x<=1; x++) { float2 lattice = float2(x,y); float2 offset = unity_voronoi_noise_randomVector(lattice + g, AngleOffset); float d = distance(lattice + offset, f); if(d < res.x) { res = float3(d, offset.x, offset.y); Out = res.x; Cells = res.y; } } } }","title":"Voronoi Node"},{"location":"ShaderGraph/Voronoi-Node/#voronoi-node","text":"","title":"Voronoi Node"},{"location":"ShaderGraph/Voronoi-Node/#description","text":"Generates a Voronoi, or Worley , noise based on input UV . Voronoi noise is generated by calculating distances between a pixel and a lattice of points. By offsetting these points by a pseudo-random number, controlled by input Angle Offset , a cluster of cells can be generated. The scale of these cells, and the resulting noise, is controlled by input Cell Density . The output Cells contains the raw cell data.","title":"Description"},{"location":"ShaderGraph/Voronoi-Node/#ports","text":"Name Direction Type Binding Description UV Input Vector 2 UV Input UV value Angle Offset Input Vector 1 None Offset value for points Cell Density Input Vector 1 None Density of cells generated Out Output Vector 1 None Output noise value Cells Output Vector 1 None Raw cell data","title":"Ports"},{"location":"ShaderGraph/Voronoi-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. inline float2 unity_voronoi_noise_randomVector (float2 UV, float offset) { float2x2 m = float2x2(15.27, 47.63, 99.41, 89.98); UV = frac(sin(mul(UV, m)) * 46839.32); return float2(sin(UV.y*+offset)*0.5+0.5, cos(UV.x*offset)*0.5+0.5); } void Unity_Voronoi_float(float2 UV, float AngleOffset, float CellDensity, out float Out, out float Cells) { float2 g = floor(UV * CellDensity); float2 f = frac(UV * CellDensity); float t = 8.0; float3 res = float3(8.0, 0.0, 0.0); for(int y=-1; y<=1; y++) { for(int x=-1; x<=1; x++) { float2 lattice = float2(x,y); float2 offset = unity_voronoi_noise_randomVector(lattice + g, AngleOffset); float d = distance(lattice + offset, f); if(d < res.x) { res = float3(d, offset.x, offset.y); Out = res.x; Cells = res.y; } } } }","title":"Generated Code Example"},{"location":"ShaderGraph/White-Balance-Node/","text":"White Balance Node Description Adjusts the temperature and tint of input In by the amount of inputs Temperature and Tint respectively. Temperature has the effect of shifting the values towards yellow or blue. Tint has the effect of shifting towards pink or green. Ports Name Direction Type Binding Description In Input Vector 3 None Input value Temperature Input Vector 1 None Temperature offset value Tint Input Vector 1 None Tint offset value Out Output Vector 3 None Output value Generated Code Example The following example code represents one possible outcome of this node. void Unity_WhiteBalance_float(float3 In, float Temperature, float Tint, out float3 Out) { // Range ~[-1.67;1.67] works best float t1 = Temperature * 10 / 6; float t2 = Tint * 10 / 6; // Get the CIE xy chromaticity of the reference white point. // Note: 0.31271 = x value on the D65 white point float x = 0.31271 - t1 * (t1 < 0 ? 0.1 : 0.05); float standardIlluminantY = 2.87 * x - 3 * x * x - 0.27509507; float y = standardIlluminantY + t2 * 0.05; // Calculate the coefficients in the LMS space. float3 w1 = float3(0.949237, 1.03542, 1.08728); // D65 white point // CIExyToLMS float Y = 1; float X = Y * x / y; float Z = Y * (1 - x - y) / y; float L = 0.7328 * X + 0.4296 * Y - 0.1624 * Z; float M = -0.7036 * X + 1.6975 * Y + 0.0061 * Z; float S = 0.0030 * X + 0.0136 * Y + 0.9834 * Z; float3 w2 = float3(L, M, S); float3 balance = float3(w1.x / w2.x, w1.y / w2.y, w1.z / w2.z); float3x3 LIN_2_LMS_MAT = { 3.90405e-1, 5.49941e-1, 8.92632e-3, 7.08416e-2, 9.63172e-1, 1.35775e-3, 2.31082e-2, 1.28021e-1, 9.36245e-1 }; float3x3 LMS_2_LIN_MAT = { 2.85847e+0, -1.62879e+0, -2.48910e-2, -2.10182e-1, 1.15820e+0, 3.24281e-4, -4.18120e-2, -1.18169e-1, 1.06867e+0 }; float3 lms = mul(LIN_2_LMS_MAT, In); lms *= balance; Out = mul(LMS_2_LIN_MAT, lms); }","title":"White Balance Node"},{"location":"ShaderGraph/White-Balance-Node/#white-balance-node","text":"","title":"White Balance Node"},{"location":"ShaderGraph/White-Balance-Node/#description","text":"Adjusts the temperature and tint of input In by the amount of inputs Temperature and Tint respectively. Temperature has the effect of shifting the values towards yellow or blue. Tint has the effect of shifting towards pink or green.","title":"Description"},{"location":"ShaderGraph/White-Balance-Node/#ports","text":"Name Direction Type Binding Description In Input Vector 3 None Input value Temperature Input Vector 1 None Temperature offset value Tint Input Vector 1 None Tint offset value Out Output Vector 3 None Output value","title":"Ports"},{"location":"ShaderGraph/White-Balance-Node/#generated-code-example","text":"The following example code represents one possible outcome of this node. void Unity_WhiteBalance_float(float3 In, float Temperature, float Tint, out float3 Out) { // Range ~[-1.67;1.67] works best float t1 = Temperature * 10 / 6; float t2 = Tint * 10 / 6; // Get the CIE xy chromaticity of the reference white point. // Note: 0.31271 = x value on the D65 white point float x = 0.31271 - t1 * (t1 < 0 ? 0.1 : 0.05); float standardIlluminantY = 2.87 * x - 3 * x * x - 0.27509507; float y = standardIlluminantY + t2 * 0.05; // Calculate the coefficients in the LMS space. float3 w1 = float3(0.949237, 1.03542, 1.08728); // D65 white point // CIExyToLMS float Y = 1; float X = Y * x / y; float Z = Y * (1 - x - y) / y; float L = 0.7328 * X + 0.4296 * Y - 0.1624 * Z; float M = -0.7036 * X + 1.6975 * Y + 0.0061 * Z; float S = 0.0030 * X + 0.0136 * Y + 0.9834 * Z; float3 w2 = float3(L, M, S); float3 balance = float3(w1.x / w2.x, w1.y / w2.y, w1.z / w2.z); float3x3 LIN_2_LMS_MAT = { 3.90405e-1, 5.49941e-1, 8.92632e-3, 7.08416e-2, 9.63172e-1, 1.35775e-3, 2.31082e-2, 1.28021e-1, 9.36245e-1 }; float3x3 LMS_2_LIN_MAT = { 2.85847e+0, -1.62879e+0, -2.48910e-2, -2.10182e-1, 1.15820e+0, 3.24281e-4, -4.18120e-2, -1.18169e-1, 1.06867e+0 }; float3 lms = mul(LIN_2_LMS_MAT, In); lms *= balance; Out = mul(LMS_2_LIN_MAT, lms); }","title":"Generated Code Example"}]}