// We need 2 bounces given that we want to see the direct lighting of the reflected surfaces
#pragma max_recursion_depth 2

// HDRP include
#include "UnityShaderVariables.cginc"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Macros.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Packing.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/RaytracingIntersection.hlsl"

// The target acceleration structure that we will evaluate the reflexion in
Texture2D<float>			          	_StencilTexture;
Texture2D<float>						_DepthTexture;

// Ray data used for the intersections
float 									_RayBias;
float 									_RayMaxLength;
float4x4 								_ViewMatrix;
float4x4 								_InvViewProjMatrix;

// Flag value that defines if a given pixel recieves reflections or not
// int   									_SsrStencilExclusionValue;

// The target acceleration acceleration structure
RaytracingAccelerationStructure 		_RaytracingAccelerationStructure;
TextureCube 							_SkyTexture;
SamplerState 							s_trilinear_clamp_sampler;

[shader("miss")]
void MissShaderReflections(inout RayIntersection rayIntersection : SV_RayPayload)
{
	rayIntersection.color = SAMPLE_TEXTURECUBE_LOD(_SkyTexture, s_trilinear_clamp_sampler, rayIntersection.incidentDirection, 0);
}

// Output structure of the reflection raytrace shader
RWTexture2D<float4> 					_SsrLightingTextureRW;

[shader("raygeneration")]
void RayGenReflections()
{
	uint2 LaunchIndex = DispatchRaysIndex();
    uint2 LaunchDim = DispatchRaysDimensions();

	// Pixel coordinate of the current pixel
    uint2 currentPixelCoord = uint2(LaunchIndex.x, LaunchDim.y - LaunchIndex.y - 1);
	
    /*
    // Read the stencil value of the pixel
    uint stencilVal = UnpackByte(LOAD_TEXTURE2D(_StencilTexture, currentPixelCoord).r);
    
    // Check if this pixel should not recieve ssr, for the moment we compute it for everyone
    bool doesntReceiveSSR = (stencilVal & _SsrStencilExclusionValue) != 0;
    if (doesntReceiveSSR)
    {
        return;
    }
	*/

	// Read the depth value
	float depthValue  = _DepthTexture[currentPixelCoord];
	if(depthValue == 0.0f)
		return;

	// Convert this to a world space position
	PositionInputs posInput = GetPositionInput(currentPixelCoord, 1.0/LaunchDim.xy, depthValue, _InvViewProjMatrix, _ViewMatrix, 0);
	posInput.positionWS += _WorldSpaceCameraPos;

	// Compute the incident vector on the surfaces
	float3 incidentWS = normalize(posInput.positionWS - _WorldSpaceCameraPos);
	
	// Decode the world space normal
    NormalData normalData;	
    DecodeFromNormalBuffer(currentPixelCoord, normalData);
	
	// Create the ray descriptor for this pixel
	RayDesc rayDescriptor;
	rayDescriptor.Origin = posInput.positionWS + normalData.normalWS * _RayBias;
	rayDescriptor.Direction = reflect(incidentWS, normalData.normalWS);
	rayDescriptor.TMin = 0;
	rayDescriptor.TMax = _RayMaxLength;

	// Create and init the RayIntersection structure for this
	RayIntersection rayIntersection;
	rayIntersection.color = float3(0.0, 0.0, 0.0);
	rayIntersection.incidentDirection = rayDescriptor.Direction;
	rayIntersection.boundIndex = 0;
	
	// Evaluate the ray intersection
	TraceRay(_RaytracingAccelerationStructure, RAY_FLAG_FORCE_OPAQUE | RAY_FLAG_CULL_BACK_FACING_TRIANGLES, 0xFF, 0, 1, 0, rayDescriptor, rayIntersection);
	
	// Alright we are done :D
    _SsrLightingTextureRW[currentPixelCoord] = float4(rayIntersection.color, 1.0f);
}
