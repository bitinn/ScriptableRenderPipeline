// We need 2 bounces given that we want to see the direct lighting of the reflected surfaces
#pragma max_recursion_depth 2

// HDRP include
#include "UnityShaderVariables.cginc"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Macros.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Packing.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl"
#include "Packages/com.unity.render-pipelines.core\ShaderLibrary\Sampling\Sampling.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingIntersection.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingSampling.hlsl"

// The target acceleration structure that we will evaluate the reflexion in
Texture2D<float>			          	_StencilTexture;
Texture2D<float>						_DepthTexture;

// Ray data used for the intersections
float4x4 								_ViewMatrix;
float4x4 								_InvViewProjMatrix;

// Flag value that defines if a given pixel recieves reflections or not
// int   									_SsrStencilExclusionValue;
TextureCube 							_SkyTexture;
SamplerState 							s_trilinear_clamp_sampler;

// Output structure of the reflection raytrace shader
RWTexture2D<float4> 					_SsrLightingTextureRW;

[shader("miss")]
void MissShaderReflections(inout RayIntersection rayIntersection : SV_RayPayload)
{
	rayIntersection.color = SAMPLE_TEXTURECUBE_LOD(_SkyTexture, s_trilinear_clamp_sampler, rayIntersection.incidentDirection, 0);
}

[shader("raygeneration")]
void RayGenReflections()
{
	uint2 LaunchIndex = DispatchRaysIndex();
    uint2 LaunchDim = DispatchRaysDimensions();

	// Pixel coordinate of the current pixel
    uint2 currentPixelCoord = uint2(LaunchIndex.x, LaunchDim.y - LaunchIndex.y - 1);
    _SsrLightingTextureRW[currentPixelCoord] = float4(0.0f, 0.0, 0.0, 0.0f);
	
    /*
    // Read the stencil value of the pixel
    uint stencilVal = UnpackByte(LOAD_TEXTURE2D(_StencilTexture, currentPixelCoord).r);
    
    // Check if this pixel should not recieve ssr, for the moment we compute it for everyone
    bool doesntReceiveSSR = (stencilVal & _SsrStencilExclusionValue) != 0;
    if (doesntReceiveSSR)
    {
        return;
    }
	*/

	// Read the depth value
	float depthValue  = _DepthTexture[currentPixelCoord];
	if(depthValue == 0.0f)
		return;

	// Convert this to a world space position
	PositionInputs posInput = GetPositionInput(currentPixelCoord, 1.0/LaunchDim.xy, depthValue, _InvViewProjMatrix, _ViewMatrix, 0);
	float depth = length(posInput.positionWS);
	posInput.positionWS += _WorldSpaceCameraPos;

	// Compute the incident vector on the surfaces
	float3 incidentWS = normalize(posInput.positionWS - _WorldSpaceCameraPos);
	
	// Decode the world space normal
    NormalData normalData;	
    DecodeFromNormalBuffer(currentPixelCoord, normalData);
	
    // Create the local ortho basis
	float3 b1, b2;
	CreatePixarOrthoNormalBasis(normalData.normalWS, b1, b2);

	// Compute the actual roughness
	float roughness = normalData.perceptualRoughness * normalData.perceptualRoughness;

	// the number of samples based on the roughness
	int numSamples = lerp(1, 13, sqrt(normalData.perceptualRoughness));

	// Variable that accumulate the radiance
	float3 completeColor = float3(0.0, 0.0, 0.0);

	// Let's loop through th e samples
	for(int i = 0; i < numSamples; ++i)
	{
		// Get the following noise value
    	float2 noiseValue = GetRaytracingNoiseSample(currentPixelCoord, i);

    	// Importance sample the direction
	    float3 sampleDir = SampleGGXDir(noiseValue, roughness);

	    // Move the direction to world space
	    sampleDir = sampleDir.x * b1 + sampleDir.y * b2 + sampleDir.z * normalData.normalWS;

	    // Compute the reflected direction
	    float3 reflectDir = reflect(incidentWS, sampleDir);

		// Create the ray descriptor for this pixel
		RayDesc rayDescriptor;
		rayDescriptor.Origin = posInput.positionWS + reflectDir * _RaytracingRayBias;
		rayDescriptor.Direction = reflectDir;
		rayDescriptor.TMin = 0;
		rayDescriptor.TMax = _RaytracingRayMaxLength;

		// Create and init the RayIntersection structure for this
		RayIntersection rayIntersection;
		rayIntersection.color = float3(0.0, 0.0, 0.0);
		rayIntersection.incidentDirection = rayDescriptor.Direction;
		rayIntersection.origin = rayDescriptor.Origin;

		// In order to achieve filtering for the textures, we need to compute the spread angle of the pixel
		rayIntersection.cone.spreadAngle = _PixelSpreadAngle;
		rayIntersection.cone.width = depth * _PixelSpreadAngle;
		
		// Evaluate the ray intersection
		TraceRay(_RaytracingAccelerationStructure, RAY_FLAG_FORCE_OPAQUE | RAY_FLAG_CULL_BACK_FACING_TRIANGLES, 0xFF, 0, 1, 0, rayDescriptor, rayIntersection);
		
		// Accumulate this value
		completeColor += rayIntersection.color;
	}

	// Normalize the radiance
	completeColor /= (float)numSamples;

	// Alright we are done :D
    _SsrLightingTextureRW[currentPixelCoord] = float4(completeColor, 1.0f);
}
